'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var DayPicker = require('react-day-picker');
var DayPicker__default = _interopDefault(DayPicker);
var get = _interopDefault(require('lodash/get'));
var map = _interopDefault(require('lodash/map'));
var findIndex = _interopDefault(require('lodash/findIndex'));
var some = _interopDefault(require('lodash/some'));
var castArray = _interopDefault(require('lodash/castArray'));
var parse = _interopDefault(require('date-fns/parse'));
var isAfter = _interopDefault(require('date-fns/is_after'));
var isBefore = _interopDefault(require('date-fns/is_before'));
var endOfDay = _interopDefault(require('date-fns/end_of_day'));
var startOfDay = _interopDefault(require('date-fns/start_of_day'));
var styles = _interopDefault(require('./index.module.scss'));

function throwError(message) {
  throw new Error("TUI DatePicker: ".concat(message));
}

function normaliseValue(value) {
  var valueArr = castArray(value);
  return map(valueArr, function (d) {
    return parse(d);
  });
} // Returns true any of the given `dates` fall on a day before the day of `cutoff`.

function hasAnyPastDays(dates) {
  var cutoff = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date();
  return some(dates, function (date) {
    return isBefore(endOfDay(date), cutoff);
  });
} // Returns true any of the given `dates` fall on a day after the day of `cutoff`.

function hasAnyFutureDays(dates) {
  var cutoff = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date();
  return some(dates, function (date) {
    return isAfter(startOfDay(date), cutoff);
  });
}
function validateProps(props) {
  var days = normaliseValue(props.value);

  if (!props.allowMultiSelection && days.length > 1) {
    throwError('`allowMultiSelection` is `false` but multiple dates were provided');
  }

  var _ref = props.disabledDays || {},
      before = _ref.before,
      after = _ref.after;

  if (before && hasAnyPastDays(days, before)) {
    throwError("Days before ".concat(before, " are disabled but one or more provided days fall before that."));
  }

  if (after && hasAnyFutureDays(days, after)) {
    throwError("Days after ".concat(after, " are disabled but one or more provided days fall after that."));
  }
}

/**
 * Thin wrapper around `react-day-picker` that renders a calendar.
 */
var Calendar = function Calendar(_ref2) {
  var _ref2$value = _ref2.value,
      value = _ref2$value === void 0 ? [] : _ref2$value,
      onChange = _ref2.onChange,
      onMonthChange = _ref2.onMonthChange,
      _ref2$disabledDays = _ref2.disabledDays,
      disabledDays = _ref2$disabledDays === void 0 ? {
    before: new Date()
  } : _ref2$disabledDays,
      month = _ref2.month,
      lastMonth = _ref2.lastMonth,
      _ref2$allowMultiSelec = _ref2.allowMultiSelection,
      allowMultiSelection = _ref2$allowMultiSelec === void 0 ? false : _ref2$allowMultiSelec,
      daysThemeDotIndicator = _ref2.daysThemeDotIndicator,
      daysThemeStrikeout = _ref2.daysThemeStrikeout;
  validateProps({
    value: value,
    onChange: onChange,
    disabledDays: disabledDays,
    month: month,
    lastMonth: lastMonth,
    allowMultiSelection: allowMultiSelection,
    onMonthChange: onMonthChange,
    daysThemeDotIndicator: daysThemeDotIndicator,
    daysThemeStrikeout: daysThemeStrikeout
  });
  var selectedDays = normaliseValue(value);
  var modifiers = {};

  if (typeof daysThemeDotIndicator === 'function') {
    modifiers['theme-dot'] = daysThemeDotIndicator;
  }

  if (typeof daysThemeStrikeout === 'function') {
    modifiers['theme-strikeout'] = daysThemeStrikeout;
  }

  return React__default.createElement("div", {
    className: styles.root
  }, React__default.createElement(DayPicker__default, {
    disabledDays: disabledDays,
    fromMonth: get(disabledDays, 'before', null),
    toMonth: lastMonth,
    month: month || selectedDays[0],
    initialMonth: month || selectedDays[0],
    selectedDays: selectedDays,
    onMonthChange: onMonthChange,
    modifiers: modifiers,
    onDayClick: function onDayClick(day, _ref3) {
      var selected = _ref3.selected,
          disabled = _ref3.disabled;

      if (disabled) {
        return;
      }

      var newSelectedDays = normaliseValue(value);

      if (allowMultiSelection) {
        if (selected) {
          var selectedIndex = findIndex(newSelectedDays, function (selectedDay) {
            return DayPicker.DateUtils.isSameDay(selectedDay, day);
          });
          newSelectedDays.splice(selectedIndex, 1);
        } else {
          newSelectedDays.push(day);
        }
      } else {
        newSelectedDays = [day];
      }

      onChange(map(newSelectedDays, startOfDay));
    }
  }));
};

exports.default = Calendar;
exports.hasAnyFutureDays = hasAnyFutureDays;
exports.hasAnyPastDays = hasAnyPastDays;
exports.normaliseValue = normaliseValue;
exports.validateProps = validateProps;
//# sourceMappingURL=index.js.map

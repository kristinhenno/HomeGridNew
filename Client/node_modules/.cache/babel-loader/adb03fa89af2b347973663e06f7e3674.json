{"ast":null,"code":"import { Component } from 'react';\nimport PropTypes from 'prop-types';\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\nvar namespace = 'Muuri';\nvar gridInstances = {};\nvar eventSynchronize = 'synchronize';\nvar eventLayoutStart = 'layoutStart';\nvar eventLayoutEnd = 'layoutEnd';\nvar eventAdd = 'add';\nvar eventRemove = 'remove';\nvar eventShowStart = 'showStart';\nvar eventShowEnd = 'showEnd';\nvar eventHideStart = 'hideStart';\nvar eventHideEnd = 'hideEnd';\nvar eventFilter = 'filter';\nvar eventSort = 'sort';\nvar eventMove = 'move';\nvar eventSend = 'send';\nvar eventBeforeSend = 'beforeSend';\nvar eventReceive = 'receive';\nvar eventBeforeReceive = 'beforeReceive';\nvar eventDragInit = 'dragInit';\nvar eventDragStart = 'dragStart';\nvar eventDragMove = 'dragMove';\nvar eventDragScroll = 'dragScroll';\nvar eventDragEnd = 'dragEnd';\nvar eventDragReleaseStart = 'dragReleaseStart';\nvar eventDragReleaseEnd = 'dragReleaseEnd';\nvar eventDestroy = 'destroy';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n/**\r\n * Muuri Emitter\r\n * Copyright (c) 2018-present, Niklas Rämö <inramo@gmail.com>\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/src/Emitter/LICENSE.md\r\n */\n\n/**\r\n * Event emitter constructor.\r\n *\r\n * @class\r\n */\n\n\nvar Emitter = function (_Component) {\n  inherits(Emitter, _Component);\n\n  function Emitter() {\n    classCallCheck(this, Emitter);\n\n    var _this = possibleConstructorReturn(this, (Emitter.__proto__ || Object.getPrototypeOf(Emitter)).call(this));\n\n    _this._events = {};\n    _this._queue = [];\n    _this._counter = 0;\n    _this._isDestroyed = false;\n    return _this;\n  }\n  /**\r\n   * Public prototype methods\r\n   * ************************\r\n   */\n\n  /**\r\n   * Bind an event listener.\r\n   *\r\n   * @public\r\n   * @memberof Emitter.prototype\r\n   * @param {String} event\r\n   * @param {Function} listener\r\n   * @returns {Emitter}\r\n   */\n\n\n  createClass(Emitter, [{\n    key: 'on',\n    value: function on(event, listener) {\n      if (this._isDestroyed) return this; // Get listeners queue and create it if it does not exist.\n\n      var listeners = this._events[event];\n      if (!listeners) listeners = this._events[event] = []; // Add the listener to the queue.\n\n      listeners.push(listener);\n      return this;\n    }\n    /**\r\n     * Bind an event listener that is triggered only once.\r\n     *\r\n     * @public\r\n     * @memberof Emitter.prototype\r\n     * @param {String} event\r\n     * @param {Function} listener\r\n     * @returns {Emitter}\r\n     */\n\n  }, {\n    key: 'once',\n    value: function once(event, listener) {\n      if (this._isDestroyed) return this;\n\n      var callback = function () {\n        this.off(event, callback);\n        listener.apply(undefined, arguments);\n      }.bind(this);\n\n      return this.on(event, callback);\n    }\n    /**\r\n     * Unbind all event listeners that match the provided listener function.\r\n     *\r\n     * @public\r\n     * @memberof Emitter.prototype\r\n     * @param {String} event\r\n     * @param {Function} [listener]\r\n     * @returns {Emitter}\r\n     */\n\n  }, {\n    key: 'off',\n    value: function off(event, listener) {\n      if (this._isDestroyed) return this; // Get listeners and return immediately if none is found.\n\n      var listeners = this._events[event];\n      if (!listeners || !listeners.length) return this; // If no specific listener is provided remove all listeners.\n\n      if (!listener) {\n        listeners.length = 0;\n        return this;\n      } // Remove all matching listeners.\n\n\n      var i = listeners.length;\n\n      while (i--) {\n        if (listener === listeners[i]) listeners.splice(i, 1);\n      }\n\n      return this;\n    }\n    /**\r\n     * Emit all listeners in a specified event with the provided arguments.\r\n     *\r\n     * @public\r\n     * @memberof Emitter.prototype\r\n     * @param {String} event\r\n     * @param {*} [arg1]\r\n     * @param {*} [arg2]\r\n     * @param {*} [arg3]\r\n     * @returns {Emitter}\r\n     */\n\n  }, {\n    key: 'emit',\n    value: function emit(event, arg1, arg2, arg3) {\n      if (this._isDestroyed) return this; // Get event listeners and quit early if there's no listeners.\n\n      var listeners = this._events[event];\n      if (!listeners || !listeners.length) return this;\n      var queue = this._queue;\n      var qLength = queue.length;\n      var aLength = arguments.length - 1;\n      var i = void 0; // Add the current listeners to the callback queue before we process them.\n      // This is necessary to guarantee that all of the listeners are called in\n      // correct order even if new event listeners are removed/added during\n      // processing and/or events are emitted during processing.\n\n      for (i = 0; i < listeners.length; i++) {\n        queue.push(listeners[i]);\n      } // Increment queue counter. This is needed for the scenarios where emit is\n      // triggered while the queue is already processing. We need to keep track of\n      // how many \"queue processors\" there are active so that we can safely reset\n      // the queue in the end when the last queue processor is finished.\n\n\n      ++this._counter; // Process the queue (the specific part of it for this emit).\n\n      for (i = qLength, qLength = queue.length; i < qLength; i++) {\n        // prettier-ignore\n        aLength === 0 ? queue[i]() : // eslint-disable-line\n        aLength === 1 ? queue[i](arg1) : // eslint-disable-line\n        aLength === 2 ? queue[i](arg1, arg2) : // eslint-disable-line\n        queue[i](arg1, arg2, arg3); // eslint-disable-line\n        // Stop processing if the emitter is destroyed.\n\n        if (this._isDestroyed) return this;\n      } // Decrement queue process counter.\n\n\n      --this._counter; // Reset the queue if there are no more queue processes running.\n\n      if (!this._counter) queue.length = 0;\n      return this;\n    }\n    /**\r\n     * Destroy emitter instance. Basically just removes all bound listeners.\r\n     *\r\n     * @public\r\n     * @memberof Emitter.prototype\r\n     * @returns {Emitter}\r\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      if (this._isDestroyed) return this;\n      var events = this._events;\n      var event = void 0; // Flag as destroyed.\n\n      this._isDestroyed = true; // Reset queue (if queue is currently processing this will also stop that).\n\n      this._queue.length = this._counter = 0; // Remove all listeners.\n\n      for (event in events) {\n        if (events[event]) {\n          events[event].length = 0;\n          events[event] = undefined;\n        }\n      }\n\n      return this;\n    }\n  }]);\n  return Emitter;\n}(Component);\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n// Set up the default export values.\n\n\nvar isTransformSupported = false;\nvar transformStyle = 'transform';\nvar transformProp = 'transform'; // Find the supported transform prop and style names.\n\nvar style = 'transform';\nvar styleCap = 'Transform';\n['', 'Webkit', 'Moz', 'O', 'ms'].forEach(function (prefix) {\n  if (isTransformSupported) return;\n  var propName = prefix ? prefix + styleCap : style;\n\n  if (document.documentElement.style[propName] !== undefined) {\n    prefix = prefix.toLowerCase();\n    transformStyle = prefix ? '-' + prefix + '-' + style : style;\n    transformProp = propName;\n    isTransformSupported = true;\n  }\n});\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\nvar stylesCache = typeof WeakMap === 'function' ? new WeakMap() : null;\n/**\r\n * Returns the computed value of an element's style property as a string.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {String} style\r\n * @returns {String}\r\n */\n\nfunction getStyle(element, style) {\n  var styles = stylesCache && stylesCache.get(element);\n\n  if (!styles) {\n    styles = window.getComputedStyle(element, null);\n    stylesCache && stylesCache.set(element, styles);\n  }\n\n  return styles.getPropertyValue(style === 'transform' ? transformStyle : style);\n}\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\n\nvar styleNameRegEx = /([A-Z])/g;\n/**\r\n * Transforms a camel case style property to kebab case style property.\r\n *\r\n * @param {String} string\r\n * @returns {String}\r\n */\n\nfunction getStyleName(string) {\n  return string.replace(styleNameRegEx, '-$1').toLowerCase();\n}\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\n/**\r\n * Set inline styles to an element.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {Object} styles\r\n */\n\n\nfunction setStyles(element, styles) {\n  for (var prop in styles) {\n    element.style[prop === 'transform' ? transformProp : prop] = styles[prop];\n  }\n}\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\n/**\r\n * Item animation handler powered by Web Animations API.\r\n *\r\n * @class\r\n * @param {HTMLElement} element\r\n */\n\n\nvar ItemAnimate = function (_Component) {\n  inherits(ItemAnimate, _Component);\n\n  function ItemAnimate(element) {\n    classCallCheck(this, ItemAnimate);\n\n    var _this = possibleConstructorReturn(this, (ItemAnimate.__proto__ || Object.getPrototypeOf(ItemAnimate)).call(this, element));\n\n    _this._element = element;\n    _this._animation = null;\n    _this._callback = null;\n    _this._props = [];\n    _this._values = [];\n    _this._keyframes = [];\n    _this._options = {};\n    _this._isDestroyed = false;\n    _this._onFinish = _this._onFinish.bind(_this);\n    return _this;\n  }\n  /**\r\n   * Public prototype methods\r\n   * ************************\r\n   */\n\n  /**\r\n   * Start instance's animation. Automatically stops current animation if it is\r\n   * running.\r\n   *\r\n   * @public\r\n   * @memberof ItemAnimate.prototype\r\n   * @param {Object} propsFrom\r\n   * @param {Object} propsTo\r\n   * @param {Object} [options]\r\n   * @param {Number} [options.duration=300]\r\n   * @param {String} [options.easing='ease']\r\n   * @param {Function} [options.onFinish]\r\n   */\n\n\n  createClass(ItemAnimate, [{\n    key: 'start',\n    value: function start(propsFrom, propsTo, options) {\n      if (this._isDestroyed) return;\n      var animation = this._animation;\n      var currentProps = this._props;\n      var currentValues = this._values;\n      var opts = options || 0;\n      var cancelAnimation = false; // If we have an existing animation running, let's check if it needs to be\n      // cancelled or if it can continue running.\n\n      if (animation) {\n        var propCount = 0;\n        var propIndex = void 0; // Check if the requested animation target props and values match with the\n        // current props and values.\n\n        for (var propName in propsTo) {\n          ++propCount;\n          propIndex = currentProps.indexOf(propName);\n\n          if (propIndex === -1 || propsTo[propName] !== currentValues[propIndex]) {\n            cancelAnimation = true;\n            break;\n          }\n        } // Check if the target props count matches current props count. This is\n        // needed for the edge case scenario where target props contain the same\n        // styles as current props, but the current props have some additional\n        // props.\n\n\n        if (!cancelAnimation && propCount !== currentProps.length) {\n          cancelAnimation = true;\n        }\n      } // Cancel animation (if required).\n\n\n      if (cancelAnimation) animation.cancel(); // Store animation callback.\n\n      this._callback = typeof opts.onFinish === 'function' ? opts.onFinish : null; // If we have a running animation that does not need to be cancelled, let's\n      // call it a day here and let it run.\n\n      if (animation && !cancelAnimation) return; // Store target props and values to instance.\n\n      currentProps.length = currentValues.length = 0;\n\n      for (var _propName in propsTo) {\n        currentProps.push(_propName);\n        currentValues.push(propsTo[_propName]);\n      } // Set up keyframes.\n\n\n      var animKeyframes = this._keyframes;\n      animKeyframes[0] = propsFrom;\n      animKeyframes[1] = propsTo; // Set up options.\n\n      var animOptions = this._options;\n      animOptions.duration = opts.duration || 300;\n      animOptions.easing = opts.easing || 'ease'; // Start the animation\n\n      var element = this._element;\n      animation = element.animate(animKeyframes, animOptions);\n      animation.onfinish = this._onFinish;\n      this._animation = animation; // Set the end styles. This makes sure that the element stays at the end\n      // values after animation is finished.\n\n      setStyles(element, propsTo);\n    }\n    /**\r\n     * Stop instance's current animation if running.\r\n     *\r\n     * @public\r\n     * @memberof ItemAnimate.prototype\r\n     * @param {Object} [styles]\r\n     */\n\n  }, {\n    key: 'stop',\n    value: function stop(styles) {\n      if (this._isDestroyed || !this._animation) return;\n      var element = this._element;\n      var currentProps = this._props;\n      var currentValues = this._values;\n      var propName = void 0;\n      var propValue = void 0;\n      var i = void 0; // Calculate (if not provided) and set styles.\n\n      if (!styles) {\n        for (i = 0; i < currentProps.length; i++) {\n          propName = currentProps[i];\n          propValue = getStyle(element, getStyleName(propName));\n          element.style[propName === 'transform' ? transformProp : propName] = propValue;\n        }\n      } else {\n        setStyles(element, styles);\n      } //  Cancel animation.\n\n\n      this._animation.cancel();\n\n      this._animation = this._callback = null; // Reset current props and values.\n\n      currentProps.length = currentValues.length = 0;\n    }\n    /**\r\n     * Check if the item is being animated currently.\r\n     *\r\n     * @public\r\n     * @memberof ItemAnimate.prototype\r\n     * @return {Boolean}\r\n     */\n\n  }, {\n    key: 'isAnimating',\n    value: function isAnimating() {\n      return !!this._animation;\n    }\n    /**\r\n     * Destroy the instance and stop current animation if it is running.\r\n     *\r\n     * @public\r\n     * @memberof ItemAnimate.prototype\r\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      if (this._isDestroyed) return;\n      this.stop();\n      this._element = this._options = this._keyframes = null;\n      this._isDestroyed = true;\n    }\n    /**\r\n     * Private prototype methods\r\n     * *************************\r\n     */\n\n    /**\r\n     * Animation end handler.\r\n     *\r\n     * @private\r\n     * @memberof ItemAnimate.prototype\r\n     */\n\n  }, {\n    key: '_onFinish',\n    value: function _onFinish() {\n      var callback = this._callback;\n      this._animation = this._callback = null;\n      this._props.length = this._values.length = 0;\n      callback && callback();\n    }\n  }]);\n  return ItemAnimate;\n}(Component);\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar hammer = createCommonjsModule(function (module) {\n  /*! Hammer.JS - v2.0.7 - 2016-04-22\n   * http://hammerjs.github.io/\n   *\n   * Copyright (c) 2016 Jorik Tangelder;\n   * Licensed under the MIT license */\n  (function (window, document, exportName, undefined) {\n    var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\n    var TEST_ELEMENT = document.createElement('div');\n    var TYPE_FUNCTION = 'function';\n    var round = Math.round;\n    var abs = Math.abs;\n    var now = Date.now;\n    /**\n     * set a timeout with a given scope\n     * @param {Function} fn\n     * @param {Number} timeout\n     * @param {Object} context\n     * @returns {number}\n     */\n\n    function setTimeoutContext(fn, timeout, context) {\n      return setTimeout(bindFn(fn, context), timeout);\n    }\n    /**\n     * if the argument is an array, we want to execute the fn on each entry\n     * if it aint an array we don't want to do a thing.\n     * this is used by all the methods that accept a single and array argument.\n     * @param {*|Array} arg\n     * @param {String} fn\n     * @param {Object} [context]\n     * @returns {Boolean}\n     */\n\n\n    function invokeArrayArg(arg, fn, context) {\n      if (Array.isArray(arg)) {\n        each(arg, context[fn], context);\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * walk objects and arrays\n     * @param {Object} obj\n     * @param {Function} iterator\n     * @param {Object} context\n     */\n\n\n    function each(obj, iterator, context) {\n      var i;\n\n      if (!obj) {\n        return;\n      }\n\n      if (obj.forEach) {\n        obj.forEach(iterator, context);\n      } else if (obj.length !== undefined) {\n        i = 0;\n\n        while (i < obj.length) {\n          iterator.call(context, obj[i], i, obj);\n          i++;\n        }\n      } else {\n        for (i in obj) {\n          obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n        }\n      }\n    }\n    /**\n     * wrap a method with a deprecation warning and stack trace\n     * @param {Function} method\n     * @param {String} name\n     * @param {String} message\n     * @returns {Function} A new function wrapping the supplied method.\n     */\n\n\n    function deprecate(method, name, message) {\n      var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n      return function () {\n        var e = new Error('get-stack-trace');\n        var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n        var log = window.console && (window.console.warn || window.console.log);\n\n        if (log) {\n          log.call(window.console, deprecationMessage, stack);\n        }\n\n        return method.apply(this, arguments);\n      };\n    }\n    /**\n     * extend object.\n     * means that properties in dest will be overwritten by the ones in src.\n     * @param {Object} target\n     * @param {...Object} objects_to_assign\n     * @returns {Object} target\n     */\n\n\n    var assign;\n\n    if (typeof Object.assign !== 'function') {\n      assign = function assign(target) {\n        if (target === undefined || target === null) {\n          throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        var output = Object(target);\n\n        for (var index = 1; index < arguments.length; index++) {\n          var source = arguments[index];\n\n          if (source !== undefined && source !== null) {\n            for (var nextKey in source) {\n              if (source.hasOwnProperty(nextKey)) {\n                output[nextKey] = source[nextKey];\n              }\n            }\n          }\n        }\n\n        return output;\n      };\n    } else {\n      assign = Object.assign;\n    }\n    /**\n     * extend object.\n     * means that properties in dest will be overwritten by the ones in src.\n     * @param {Object} dest\n     * @param {Object} src\n     * @param {Boolean} [merge=false]\n     * @returns {Object} dest\n     */\n\n\n    var extend = deprecate(function extend(dest, src, merge) {\n      var keys = Object.keys(src);\n      var i = 0;\n\n      while (i < keys.length) {\n        if (!merge || merge && dest[keys[i]] === undefined) {\n          dest[keys[i]] = src[keys[i]];\n        }\n\n        i++;\n      }\n\n      return dest;\n    }, 'extend', 'Use `assign`.');\n    /**\n     * merge the values from src in the dest.\n     * means that properties that exist in dest will not be overwritten by src\n     * @param {Object} dest\n     * @param {Object} src\n     * @returns {Object} dest\n     */\n\n    var merge = deprecate(function merge(dest, src) {\n      return extend(dest, src, true);\n    }, 'merge', 'Use `assign`.');\n    /**\n     * simple class inheritance\n     * @param {Function} child\n     * @param {Function} base\n     * @param {Object} [properties]\n     */\n\n    function inherit(child, base, properties) {\n      var baseP = base.prototype,\n          childP;\n      childP = child.prototype = Object.create(baseP);\n      childP.constructor = child;\n      childP._super = baseP;\n\n      if (properties) {\n        assign(childP, properties);\n      }\n    }\n    /**\n     * simple function bind\n     * @param {Function} fn\n     * @param {Object} context\n     * @returns {Function}\n     */\n\n\n    function bindFn(fn, context) {\n      return function boundFn() {\n        return fn.apply(context, arguments);\n      };\n    }\n    /**\n     * let a boolean value also be a function that must return a boolean\n     * this first item in args will be used as the context\n     * @param {Boolean|Function} val\n     * @param {Array} [args]\n     * @returns {Boolean}\n     */\n\n\n    function boolOrFn(val, args) {\n      if (typeof val == TYPE_FUNCTION) {\n        return val.apply(args ? args[0] || undefined : undefined, args);\n      }\n\n      return val;\n    }\n    /**\n     * use the val2 when val1 is undefined\n     * @param {*} val1\n     * @param {*} val2\n     * @returns {*}\n     */\n\n\n    function ifUndefined(val1, val2) {\n      return val1 === undefined ? val2 : val1;\n    }\n    /**\n     * addEventListener with multiple events at once\n     * @param {EventTarget} target\n     * @param {String} types\n     * @param {Function} handler\n     */\n\n\n    function addEventListeners(target, types, handler) {\n      each(splitStr(types), function (type) {\n        target.addEventListener(type, handler, false);\n      });\n    }\n    /**\n     * removeEventListener with multiple events at once\n     * @param {EventTarget} target\n     * @param {String} types\n     * @param {Function} handler\n     */\n\n\n    function removeEventListeners(target, types, handler) {\n      each(splitStr(types), function (type) {\n        target.removeEventListener(type, handler, false);\n      });\n    }\n    /**\n     * find if a node is in the given parent\n     * @method hasParent\n     * @param {HTMLElement} node\n     * @param {HTMLElement} parent\n     * @return {Boolean} found\n     */\n\n\n    function hasParent(node, parent) {\n      while (node) {\n        if (node == parent) {\n          return true;\n        }\n\n        node = node.parentNode;\n      }\n\n      return false;\n    }\n    /**\n     * small indexOf wrapper\n     * @param {String} str\n     * @param {String} find\n     * @returns {Boolean} found\n     */\n\n\n    function inStr(str, find) {\n      return str.indexOf(find) > -1;\n    }\n    /**\n     * split string on whitespace\n     * @param {String} str\n     * @returns {Array} words\n     */\n\n\n    function splitStr(str) {\n      return str.trim().split(/\\s+/g);\n    }\n    /**\n     * find if a array contains the object using indexOf or a simple polyFill\n     * @param {Array} src\n     * @param {String} find\n     * @param {String} [findByKey]\n     * @return {Boolean|Number} false when not found, or the index\n     */\n\n\n    function inArray(src, find, findByKey) {\n      if (src.indexOf && !findByKey) {\n        return src.indexOf(find);\n      } else {\n        var i = 0;\n\n        while (i < src.length) {\n          if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n            return i;\n          }\n\n          i++;\n        }\n\n        return -1;\n      }\n    }\n    /**\n     * convert array-like objects to real arrays\n     * @param {Object} obj\n     * @returns {Array}\n     */\n\n\n    function toArray(obj) {\n      return Array.prototype.slice.call(obj, 0);\n    }\n    /**\n     * unique array with objects based on a key (like 'id') or just by the array's value\n     * @param {Array} src [{id:1},{id:2},{id:1}]\n     * @param {String} [key]\n     * @param {Boolean} [sort=False]\n     * @returns {Array} [{id:1},{id:2}]\n     */\n\n\n    function uniqueArray(src, key, sort) {\n      var results = [];\n      var values = [];\n      var i = 0;\n\n      while (i < src.length) {\n        var val = key ? src[i][key] : src[i];\n\n        if (inArray(values, val) < 0) {\n          results.push(src[i]);\n        }\n\n        values[i] = val;\n        i++;\n      }\n\n      if (sort) {\n        if (!key) {\n          results = results.sort();\n        } else {\n          results = results.sort(function sortUniqueArray(a, b) {\n            return a[key] > b[key];\n          });\n        }\n      }\n\n      return results;\n    }\n    /**\n     * get the prefixed property\n     * @param {Object} obj\n     * @param {String} property\n     * @returns {String|Undefined} prefixed\n     */\n\n\n    function prefixed(obj, property) {\n      var prefix, prop;\n      var camelProp = property[0].toUpperCase() + property.slice(1);\n      var i = 0;\n\n      while (i < VENDOR_PREFIXES.length) {\n        prefix = VENDOR_PREFIXES[i];\n        prop = prefix ? prefix + camelProp : property;\n\n        if (prop in obj) {\n          return prop;\n        }\n\n        i++;\n      }\n\n      return undefined;\n    }\n    /**\n     * get a unique id\n     * @returns {number} uniqueId\n     */\n\n\n    var _uniqueId = 1;\n\n    function uniqueId() {\n      return _uniqueId++;\n    }\n    /**\n     * get the window object of an element\n     * @param {HTMLElement} element\n     * @returns {DocumentView|Window}\n     */\n\n\n    function getWindowForElement(element) {\n      var doc = element.ownerDocument || element;\n      return doc.defaultView || doc.parentWindow || window;\n    }\n\n    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n    var SUPPORT_TOUCH = ('ontouchstart' in window);\n    var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\n    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n    var INPUT_TYPE_TOUCH = 'touch';\n    var INPUT_TYPE_PEN = 'pen';\n    var INPUT_TYPE_MOUSE = 'mouse';\n    var INPUT_TYPE_KINECT = 'kinect';\n    var COMPUTE_INTERVAL = 25;\n    var INPUT_START = 1;\n    var INPUT_MOVE = 2;\n    var INPUT_END = 4;\n    var INPUT_CANCEL = 8;\n    var DIRECTION_NONE = 1;\n    var DIRECTION_LEFT = 2;\n    var DIRECTION_RIGHT = 4;\n    var DIRECTION_UP = 8;\n    var DIRECTION_DOWN = 16;\n    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\n    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\n    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n    var PROPS_XY = ['x', 'y'];\n    var PROPS_CLIENT_XY = ['clientX', 'clientY'];\n    /**\n     * create new input type manager\n     * @param {Manager} manager\n     * @param {Function} callback\n     * @returns {Input}\n     * @constructor\n     */\n\n    function Input(manager, callback) {\n      var self = this;\n      this.manager = manager;\n      this.callback = callback;\n      this.element = manager.element;\n      this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n      // so when disabled the input events are completely bypassed.\n\n      this.domHandler = function (ev) {\n        if (boolOrFn(manager.options.enable, [manager])) {\n          self.handler(ev);\n        }\n      };\n\n      this.init();\n    }\n\n    Input.prototype = {\n      /**\n       * should handle the inputEvent data and trigger the callback\n       * @virtual\n       */\n      handler: function () {},\n\n      /**\n       * bind the events\n       */\n      init: function () {\n        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n      },\n\n      /**\n       * unbind the events\n       */\n      destroy: function () {\n        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n      }\n    };\n    /**\n     * create new input type manager\n     * called by the Manager constructor\n     * @param {Hammer} manager\n     * @returns {Input}\n     */\n\n    function createInputInstance(manager) {\n      var Type;\n      var inputClass = manager.options.inputClass;\n\n      if (inputClass) {\n        Type = inputClass;\n      } else if (SUPPORT_POINTER_EVENTS) {\n        Type = PointerEventInput;\n      } else if (SUPPORT_ONLY_TOUCH) {\n        Type = TouchInput;\n      } else if (!SUPPORT_TOUCH) {\n        Type = MouseInput;\n      } else {\n        Type = TouchMouseInput;\n      }\n\n      return new Type(manager, inputHandler);\n    }\n    /**\n     * handle input events\n     * @param {Manager} manager\n     * @param {String} eventType\n     * @param {Object} input\n     */\n\n\n    function inputHandler(manager, eventType, input) {\n      var pointersLen = input.pointers.length;\n      var changedPointersLen = input.changedPointers.length;\n      var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n      var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n      input.isFirst = !!isFirst;\n      input.isFinal = !!isFinal;\n\n      if (isFirst) {\n        manager.session = {};\n      } // source event is the normalized value of the domEvents\n      // like 'touchstart, mouseup, pointerdown'\n\n\n      input.eventType = eventType; // compute scale, rotation etc\n\n      computeInputData(manager, input); // emit secret event\n\n      manager.emit('hammer.input', input);\n      manager.recognize(input);\n      manager.session.prevInput = input;\n    }\n    /**\n     * extend the data with some usable properties like scale, rotate, velocity etc\n     * @param {Object} manager\n     * @param {Object} input\n     */\n\n\n    function computeInputData(manager, input) {\n      var session = manager.session;\n      var pointers = input.pointers;\n      var pointersLength = pointers.length; // store the first input to calculate the distance and direction\n\n      if (!session.firstInput) {\n        session.firstInput = simpleCloneInputData(input);\n      } // to compute scale and rotation we need to store the multiple touches\n\n\n      if (pointersLength > 1 && !session.firstMultiple) {\n        session.firstMultiple = simpleCloneInputData(input);\n      } else if (pointersLength === 1) {\n        session.firstMultiple = false;\n      }\n\n      var firstInput = session.firstInput;\n      var firstMultiple = session.firstMultiple;\n      var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n      var center = input.center = getCenter(pointers);\n      input.timeStamp = now();\n      input.deltaTime = input.timeStamp - firstInput.timeStamp;\n      input.angle = getAngle(offsetCenter, center);\n      input.distance = getDistance(offsetCenter, center);\n      computeDeltaXY(session, input);\n      input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n      var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n      input.overallVelocityX = overallVelocity.x;\n      input.overallVelocityY = overallVelocity.y;\n      input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n      input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n      input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n      input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n      computeIntervalInputData(session, input); // find the correct target\n\n      var target = manager.element;\n\n      if (hasParent(input.srcEvent.target, target)) {\n        target = input.srcEvent.target;\n      }\n\n      input.target = target;\n    }\n\n    function computeDeltaXY(session, input) {\n      var center = input.center;\n      var offset = session.offsetDelta || {};\n      var prevDelta = session.prevDelta || {};\n      var prevInput = session.prevInput || {};\n\n      if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n        prevDelta = session.prevDelta = {\n          x: prevInput.deltaX || 0,\n          y: prevInput.deltaY || 0\n        };\n        offset = session.offsetDelta = {\n          x: center.x,\n          y: center.y\n        };\n      }\n\n      input.deltaX = prevDelta.x + (center.x - offset.x);\n      input.deltaY = prevDelta.y + (center.y - offset.y);\n    }\n    /**\n     * velocity is calculated every x ms\n     * @param {Object} session\n     * @param {Object} input\n     */\n\n\n    function computeIntervalInputData(session, input) {\n      var last = session.lastInterval || input,\n          deltaTime = input.timeStamp - last.timeStamp,\n          velocity,\n          velocityX,\n          velocityY,\n          direction;\n\n      if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n        var deltaX = input.deltaX - last.deltaX;\n        var deltaY = input.deltaY - last.deltaY;\n        var v = getVelocity(deltaTime, deltaX, deltaY);\n        velocityX = v.x;\n        velocityY = v.y;\n        velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n        direction = getDirection(deltaX, deltaY);\n        session.lastInterval = input;\n      } else {\n        // use latest velocity info if it doesn't overtake a minimum period\n        velocity = last.velocity;\n        velocityX = last.velocityX;\n        velocityY = last.velocityY;\n        direction = last.direction;\n      }\n\n      input.velocity = velocity;\n      input.velocityX = velocityX;\n      input.velocityY = velocityY;\n      input.direction = direction;\n    }\n    /**\n     * create a simple clone from the input used for storage of firstInput and firstMultiple\n     * @param {Object} input\n     * @returns {Object} clonedInputData\n     */\n\n\n    function simpleCloneInputData(input) {\n      // make a simple copy of the pointers because we will get a reference if we don't\n      // we only need clientXY for the calculations\n      var pointers = [];\n      var i = 0;\n\n      while (i < input.pointers.length) {\n        pointers[i] = {\n          clientX: round(input.pointers[i].clientX),\n          clientY: round(input.pointers[i].clientY)\n        };\n        i++;\n      }\n\n      return {\n        timeStamp: now(),\n        pointers: pointers,\n        center: getCenter(pointers),\n        deltaX: input.deltaX,\n        deltaY: input.deltaY\n      };\n    }\n    /**\n     * get the center of all the pointers\n     * @param {Array} pointers\n     * @return {Object} center contains `x` and `y` properties\n     */\n\n\n    function getCenter(pointers) {\n      var pointersLength = pointers.length; // no need to loop when only one touch\n\n      if (pointersLength === 1) {\n        return {\n          x: round(pointers[0].clientX),\n          y: round(pointers[0].clientY)\n        };\n      }\n\n      var x = 0,\n          y = 0,\n          i = 0;\n\n      while (i < pointersLength) {\n        x += pointers[i].clientX;\n        y += pointers[i].clientY;\n        i++;\n      }\n\n      return {\n        x: round(x / pointersLength),\n        y: round(y / pointersLength)\n      };\n    }\n    /**\n     * calculate the velocity between two points. unit is in px per ms.\n     * @param {Number} deltaTime\n     * @param {Number} x\n     * @param {Number} y\n     * @return {Object} velocity `x` and `y`\n     */\n\n\n    function getVelocity(deltaTime, x, y) {\n      return {\n        x: x / deltaTime || 0,\n        y: y / deltaTime || 0\n      };\n    }\n    /**\n     * get the direction between two points\n     * @param {Number} x\n     * @param {Number} y\n     * @return {Number} direction\n     */\n\n\n    function getDirection(x, y) {\n      if (x === y) {\n        return DIRECTION_NONE;\n      }\n\n      if (abs(x) >= abs(y)) {\n        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n      }\n\n      return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n    }\n    /**\n     * calculate the absolute distance between two points\n     * @param {Object} p1 {x, y}\n     * @param {Object} p2 {x, y}\n     * @param {Array} [props] containing x and y keys\n     * @return {Number} distance\n     */\n\n\n    function getDistance(p1, p2, props) {\n      if (!props) {\n        props = PROPS_XY;\n      }\n\n      var x = p2[props[0]] - p1[props[0]],\n          y = p2[props[1]] - p1[props[1]];\n      return Math.sqrt(x * x + y * y);\n    }\n    /**\n     * calculate the angle between two coordinates\n     * @param {Object} p1\n     * @param {Object} p2\n     * @param {Array} [props] containing x and y keys\n     * @return {Number} angle\n     */\n\n\n    function getAngle(p1, p2, props) {\n      if (!props) {\n        props = PROPS_XY;\n      }\n\n      var x = p2[props[0]] - p1[props[0]],\n          y = p2[props[1]] - p1[props[1]];\n      return Math.atan2(y, x) * 180 / Math.PI;\n    }\n    /**\n     * calculate the rotation degrees between two pointersets\n     * @param {Array} start array of pointers\n     * @param {Array} end array of pointers\n     * @return {Number} rotation\n     */\n\n\n    function getRotation(start, end) {\n      return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n    }\n    /**\n     * calculate the scale factor between two pointersets\n     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n     * @param {Array} start array of pointers\n     * @param {Array} end array of pointers\n     * @return {Number} scale\n     */\n\n\n    function getScale(start, end) {\n      return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n    }\n\n    var MOUSE_INPUT_MAP = {\n      mousedown: INPUT_START,\n      mousemove: INPUT_MOVE,\n      mouseup: INPUT_END\n    };\n    var MOUSE_ELEMENT_EVENTS = 'mousedown';\n    var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n    /**\n     * Mouse events input\n     * @constructor\n     * @extends Input\n     */\n\n    function MouseInput() {\n      this.evEl = MOUSE_ELEMENT_EVENTS;\n      this.evWin = MOUSE_WINDOW_EVENTS;\n      this.pressed = false; // mousedown state\n\n      Input.apply(this, arguments);\n    }\n\n    inherit(MouseInput, Input, {\n      /**\n       * handle mouse events\n       * @param {Object} ev\n       */\n      handler: function MEhandler(ev) {\n        var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down\n\n        if (eventType & INPUT_START && ev.button === 0) {\n          this.pressed = true;\n        }\n\n        if (eventType & INPUT_MOVE && ev.which !== 1) {\n          eventType = INPUT_END;\n        } // mouse must be down\n\n\n        if (!this.pressed) {\n          return;\n        }\n\n        if (eventType & INPUT_END) {\n          this.pressed = false;\n        }\n\n        this.callback(this.manager, eventType, {\n          pointers: [ev],\n          changedPointers: [ev],\n          pointerType: INPUT_TYPE_MOUSE,\n          srcEvent: ev\n        });\n      }\n    });\n    var POINTER_INPUT_MAP = {\n      pointerdown: INPUT_START,\n      pointermove: INPUT_MOVE,\n      pointerup: INPUT_END,\n      pointercancel: INPUT_CANCEL,\n      pointerout: INPUT_CANCEL\n    }; // in IE10 the pointer types is defined as an enum\n\n    var IE10_POINTER_TYPE_ENUM = {\n      2: INPUT_TYPE_TOUCH,\n      3: INPUT_TYPE_PEN,\n      4: INPUT_TYPE_MOUSE,\n      5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n\n    };\n    var POINTER_ELEMENT_EVENTS = 'pointerdown';\n    var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive\n\n    if (window.MSPointerEvent && !window.PointerEvent) {\n      POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n      POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n    }\n    /**\n     * Pointer events input\n     * @constructor\n     * @extends Input\n     */\n\n\n    function PointerEventInput() {\n      this.evEl = POINTER_ELEMENT_EVENTS;\n      this.evWin = POINTER_WINDOW_EVENTS;\n      Input.apply(this, arguments);\n      this.store = this.manager.session.pointerEvents = [];\n    }\n\n    inherit(PointerEventInput, Input, {\n      /**\n       * handle mouse events\n       * @param {Object} ev\n       */\n      handler: function PEhandler(ev) {\n        var store = this.store;\n        var removePointer = false;\n        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n        var isTouch = pointerType == INPUT_TYPE_TOUCH; // get index of the event in the store\n\n        var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down\n\n        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n          if (storeIndex < 0) {\n            store.push(ev);\n            storeIndex = store.length - 1;\n          }\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n          removePointer = true;\n        } // it not found, so the pointer hasn't been down (so it's probably a hover)\n\n\n        if (storeIndex < 0) {\n          return;\n        } // update the event in the store\n\n\n        store[storeIndex] = ev;\n        this.callback(this.manager, eventType, {\n          pointers: store,\n          changedPointers: [ev],\n          pointerType: pointerType,\n          srcEvent: ev\n        });\n\n        if (removePointer) {\n          // remove from the store\n          store.splice(storeIndex, 1);\n        }\n      }\n    });\n    var SINGLE_TOUCH_INPUT_MAP = {\n      touchstart: INPUT_START,\n      touchmove: INPUT_MOVE,\n      touchend: INPUT_END,\n      touchcancel: INPUT_CANCEL\n    };\n    var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\n    var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n    /**\n     * Touch events input\n     * @constructor\n     * @extends Input\n     */\n\n    function SingleTouchInput() {\n      this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n      this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n      this.started = false;\n      Input.apply(this, arguments);\n    }\n\n    inherit(SingleTouchInput, Input, {\n      handler: function TEhandler(ev) {\n        var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?\n\n        if (type === INPUT_START) {\n          this.started = true;\n        }\n\n        if (!this.started) {\n          return;\n        }\n\n        var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state\n\n        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n          this.started = false;\n        }\n\n        this.callback(this.manager, type, {\n          pointers: touches[0],\n          changedPointers: touches[1],\n          pointerType: INPUT_TYPE_TOUCH,\n          srcEvent: ev\n        });\n      }\n    });\n    /**\n     * @this {TouchInput}\n     * @param {Object} ev\n     * @param {Number} type flag\n     * @returns {undefined|Array} [all, changed]\n     */\n\n    function normalizeSingleTouches(ev, type) {\n      var all = toArray(ev.touches);\n      var changed = toArray(ev.changedTouches);\n\n      if (type & (INPUT_END | INPUT_CANCEL)) {\n        all = uniqueArray(all.concat(changed), 'identifier', true);\n      }\n\n      return [all, changed];\n    }\n\n    var TOUCH_INPUT_MAP = {\n      touchstart: INPUT_START,\n      touchmove: INPUT_MOVE,\n      touchend: INPUT_END,\n      touchcancel: INPUT_CANCEL\n    };\n    var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n    /**\n     * Multi-user touch events input\n     * @constructor\n     * @extends Input\n     */\n\n    function TouchInput() {\n      this.evTarget = TOUCH_TARGET_EVENTS;\n      this.targetIds = {};\n      Input.apply(this, arguments);\n    }\n\n    inherit(TouchInput, Input, {\n      handler: function MTEhandler(ev) {\n        var type = TOUCH_INPUT_MAP[ev.type];\n        var touches = getTouches.call(this, ev, type);\n\n        if (!touches) {\n          return;\n        }\n\n        this.callback(this.manager, type, {\n          pointers: touches[0],\n          changedPointers: touches[1],\n          pointerType: INPUT_TYPE_TOUCH,\n          srcEvent: ev\n        });\n      }\n    });\n    /**\n     * @this {TouchInput}\n     * @param {Object} ev\n     * @param {Number} type flag\n     * @returns {undefined|Array} [all, changed]\n     */\n\n    function getTouches(ev, type) {\n      var allTouches = toArray(ev.touches);\n      var targetIds = this.targetIds; // when there is only one touch, the process can be simplified\n\n      if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n        targetIds[allTouches[0].identifier] = true;\n        return [allTouches, allTouches];\n      }\n\n      var i,\n          targetTouches,\n          changedTouches = toArray(ev.changedTouches),\n          changedTargetTouches = [],\n          target = this.target; // get target touches from touches\n\n      targetTouches = allTouches.filter(function (touch) {\n        return hasParent(touch.target, target);\n      }); // collect touches\n\n      if (type === INPUT_START) {\n        i = 0;\n\n        while (i < targetTouches.length) {\n          targetIds[targetTouches[i].identifier] = true;\n          i++;\n        }\n      } // filter changed touches to only contain touches that exist in the collected target ids\n\n\n      i = 0;\n\n      while (i < changedTouches.length) {\n        if (targetIds[changedTouches[i].identifier]) {\n          changedTargetTouches.push(changedTouches[i]);\n        } // cleanup removed touches\n\n\n        if (type & (INPUT_END | INPUT_CANCEL)) {\n          delete targetIds[changedTouches[i].identifier];\n        }\n\n        i++;\n      }\n\n      if (!changedTargetTouches.length) {\n        return;\n      }\n\n      return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n      uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n    }\n    /**\n     * Combined touch and mouse input\n     *\n     * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n     * This because touch devices also emit mouse events while doing a touch.\n     *\n     * @constructor\n     * @extends Input\n     */\n\n\n    var DEDUP_TIMEOUT = 2500;\n    var DEDUP_DISTANCE = 25;\n\n    function TouchMouseInput() {\n      Input.apply(this, arguments);\n      var handler = bindFn(this.handler, this);\n      this.touch = new TouchInput(this.manager, handler);\n      this.mouse = new MouseInput(this.manager, handler);\n      this.primaryTouch = null;\n      this.lastTouches = [];\n    }\n\n    inherit(TouchMouseInput, Input, {\n      /**\n       * handle mouse and touch events\n       * @param {Hammer} manager\n       * @param {String} inputEvent\n       * @param {Object} inputData\n       */\n      handler: function TMEhandler(manager, inputEvent, inputData) {\n        var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,\n            isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;\n\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n          return;\n        } // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n\n\n        if (isTouch) {\n          recordTouches.call(this, inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n          return;\n        }\n\n        this.callback(manager, inputEvent, inputData);\n      },\n\n      /**\n       * remove the event listeners\n       */\n      destroy: function destroy() {\n        this.touch.destroy();\n        this.mouse.destroy();\n      }\n    });\n\n    function recordTouches(eventType, eventData) {\n      if (eventType & INPUT_START) {\n        this.primaryTouch = eventData.changedPointers[0].identifier;\n        setLastTouch.call(this, eventData);\n      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        setLastTouch.call(this, eventData);\n      }\n    }\n\n    function setLastTouch(eventData) {\n      var touch = eventData.changedPointers[0];\n\n      if (touch.identifier === this.primaryTouch) {\n        var lastTouch = {\n          x: touch.clientX,\n          y: touch.clientY\n        };\n        this.lastTouches.push(lastTouch);\n        var lts = this.lastTouches;\n\n        var removeLastTouch = function () {\n          var i = lts.indexOf(lastTouch);\n\n          if (i > -1) {\n            lts.splice(i, 1);\n          }\n        };\n\n        setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n      }\n    }\n\n    function isSyntheticEvent(eventData) {\n      var x = eventData.srcEvent.clientX,\n          y = eventData.srcEvent.clientY;\n\n      for (var i = 0; i < this.lastTouches.length; i++) {\n        var t = this.lastTouches[i];\n        var dx = Math.abs(x - t.x),\n            dy = Math.abs(y - t.y);\n\n        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\n    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined; // magical touchAction value\n\n    var TOUCH_ACTION_COMPUTE = 'compute';\n    var TOUCH_ACTION_AUTO = 'auto';\n    var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n\n    var TOUCH_ACTION_NONE = 'none';\n    var TOUCH_ACTION_PAN_X = 'pan-x';\n    var TOUCH_ACTION_PAN_Y = 'pan-y';\n    var TOUCH_ACTION_MAP = getTouchActionProps();\n    /**\n     * Touch Action\n     * sets the touchAction property or uses the js alternative\n     * @param {Manager} manager\n     * @param {String} value\n     * @constructor\n     */\n\n    function TouchAction(manager, value) {\n      this.manager = manager;\n      this.set(value);\n    }\n\n    TouchAction.prototype = {\n      /**\n       * set the touchAction value on the element or enable the polyfill\n       * @param {String} value\n       */\n      set: function (value) {\n        // find out the touch-action by the event handlers\n        if (value == TOUCH_ACTION_COMPUTE) {\n          value = this.compute();\n        }\n\n        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n          this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n        }\n\n        this.actions = value.toLowerCase().trim();\n      },\n\n      /**\n       * just re-set the touchAction value\n       */\n      update: function () {\n        this.set(this.manager.options.touchAction);\n      },\n\n      /**\n       * compute the value for the touchAction property based on the recognizer's settings\n       * @returns {String} value\n       */\n      compute: function () {\n        var actions = [];\n        each(this.manager.recognizers, function (recognizer) {\n          if (boolOrFn(recognizer.options.enable, [recognizer])) {\n            actions = actions.concat(recognizer.getTouchAction());\n          }\n        });\n        return cleanTouchActions(actions.join(' '));\n      },\n\n      /**\n       * this method is called on each input cycle and provides the preventing of the browser behavior\n       * @param {Object} input\n       */\n      preventDefaults: function (input) {\n        var srcEvent = input.srcEvent;\n        var direction = input.offsetDirection; // if the touch action did prevented once this session\n\n        if (this.manager.session.prevented) {\n          srcEvent.preventDefault();\n          return;\n        }\n\n        var actions = this.actions;\n        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n        if (hasNone) {\n          //do not prevent defaults if this is a tap gesture\n          var isTapPointer = input.pointers.length === 1;\n          var isTapMovement = input.distance < 2;\n          var isTapTouchTime = input.deltaTime < 250;\n\n          if (isTapPointer && isTapMovement && isTapTouchTime) {\n            return;\n          }\n        }\n\n        if (hasPanX && hasPanY) {\n          // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n          return;\n        }\n\n        if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n          return this.preventSrc(srcEvent);\n        }\n      },\n\n      /**\n       * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n       * @param {Object} srcEvent\n       */\n      preventSrc: function (srcEvent) {\n        this.manager.session.prevented = true;\n        srcEvent.preventDefault();\n      }\n    };\n    /**\n     * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n     * @param {String} actions\n     * @returns {*}\n     */\n\n    function cleanTouchActions(actions) {\n      // none\n      if (inStr(actions, TOUCH_ACTION_NONE)) {\n        return TOUCH_ACTION_NONE;\n      }\n\n      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers\n      // for different directions, e.g. horizontal pan but vertical swipe?)\n      // we need none (as otherwise with pan-x pan-y combined none of these\n      // recognizers will work, since the browser would handle all panning\n\n      if (hasPanX && hasPanY) {\n        return TOUCH_ACTION_NONE;\n      } // pan-x OR pan-y\n\n\n      if (hasPanX || hasPanY) {\n        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n      } // manipulation\n\n\n      if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n        return TOUCH_ACTION_MANIPULATION;\n      }\n\n      return TOUCH_ACTION_AUTO;\n    }\n\n    function getTouchActionProps() {\n      if (!NATIVE_TOUCH_ACTION) {\n        return false;\n      }\n\n      var touchMap = {};\n      var cssSupports = window.CSS && window.CSS.supports;\n      ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\n        // If css.supports is not supported but there is native touch-action assume it supports\n        // all values. This is the case for IE 10 and 11.\n        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n      });\n      return touchMap;\n    }\n    /**\n     * Recognizer flow explained; *\n     * All recognizers have the initial state of POSSIBLE when a input session starts.\n     * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n     * Example session for mouse-input: mousedown -> mousemove -> mouseup\n     *\n     * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n     * which determines with state it should be.\n     *\n     * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n     * POSSIBLE to give it another change on the next cycle.\n     *\n     *               Possible\n     *                  |\n     *            +-----+---------------+\n     *            |                     |\n     *      +-----+-----+               |\n     *      |           |               |\n     *   Failed      Cancelled          |\n     *                          +-------+------+\n     *                          |              |\n     *                      Recognized       Began\n     *                                         |\n     *                                      Changed\n     *                                         |\n     *                                  Ended/Recognized\n     */\n\n\n    var STATE_POSSIBLE = 1;\n    var STATE_BEGAN = 2;\n    var STATE_CHANGED = 4;\n    var STATE_ENDED = 8;\n    var STATE_RECOGNIZED = STATE_ENDED;\n    var STATE_CANCELLED = 16;\n    var STATE_FAILED = 32;\n    /**\n     * Recognizer\n     * Every recognizer needs to extend from this class.\n     * @constructor\n     * @param {Object} options\n     */\n\n    function Recognizer(options) {\n      this.options = assign({}, this.defaults, options || {});\n      this.id = uniqueId();\n      this.manager = null; // default is enable true\n\n      this.options.enable = ifUndefined(this.options.enable, true);\n      this.state = STATE_POSSIBLE;\n      this.simultaneous = {};\n      this.requireFail = [];\n    }\n\n    Recognizer.prototype = {\n      /**\n       * @virtual\n       * @type {Object}\n       */\n      defaults: {},\n\n      /**\n       * set options\n       * @param {Object} options\n       * @return {Recognizer}\n       */\n      set: function (options) {\n        assign(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state\n\n        this.manager && this.manager.touchAction.update();\n        return this;\n      },\n\n      /**\n       * recognize simultaneous with an other recognizer.\n       * @param {Recognizer} otherRecognizer\n       * @returns {Recognizer} this\n       */\n      recognizeWith: function (otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n          return this;\n        }\n\n        var simultaneous = this.simultaneous;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n        if (!simultaneous[otherRecognizer.id]) {\n          simultaneous[otherRecognizer.id] = otherRecognizer;\n          otherRecognizer.recognizeWith(this);\n        }\n\n        return this;\n      },\n\n      /**\n       * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n       * @param {Recognizer} otherRecognizer\n       * @returns {Recognizer} this\n       */\n      dropRecognizeWith: function (otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n          return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        delete this.simultaneous[otherRecognizer.id];\n        return this;\n      },\n\n      /**\n       * recognizer can only run when an other is failing\n       * @param {Recognizer} otherRecognizer\n       * @returns {Recognizer} this\n       */\n      requireFailure: function (otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n          return this;\n        }\n\n        var requireFail = this.requireFail;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n        if (inArray(requireFail, otherRecognizer) === -1) {\n          requireFail.push(otherRecognizer);\n          otherRecognizer.requireFailure(this);\n        }\n\n        return this;\n      },\n\n      /**\n       * drop the requireFailure link. it does not remove the link on the other recognizer.\n       * @param {Recognizer} otherRecognizer\n       * @returns {Recognizer} this\n       */\n      dropRequireFailure: function (otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n          return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        var index = inArray(this.requireFail, otherRecognizer);\n\n        if (index > -1) {\n          this.requireFail.splice(index, 1);\n        }\n\n        return this;\n      },\n\n      /**\n       * has require failures boolean\n       * @returns {boolean}\n       */\n      hasRequireFailures: function () {\n        return this.requireFail.length > 0;\n      },\n\n      /**\n       * if the recognizer can recognize simultaneous with an other recognizer\n       * @param {Recognizer} otherRecognizer\n       * @returns {Boolean}\n       */\n      canRecognizeWith: function (otherRecognizer) {\n        return !!this.simultaneous[otherRecognizer.id];\n      },\n\n      /**\n       * You should use `tryEmit` instead of `emit` directly to check\n       * that all the needed recognizers has failed before emitting.\n       * @param {Object} input\n       */\n      emit: function (input) {\n        var self = this;\n        var state = this.state;\n\n        function emit(event) {\n          self.manager.emit(event, input);\n        } // 'panstart' and 'panmove'\n\n\n        if (state < STATE_ENDED) {\n          emit(self.options.event + stateStr(state));\n        }\n\n        emit(self.options.event); // simple 'eventName' events\n\n        if (input.additionalEvent) {\n          // additional event(panleft, panright, pinchin, pinchout...)\n          emit(input.additionalEvent);\n        } // panend and pancancel\n\n\n        if (state >= STATE_ENDED) {\n          emit(self.options.event + stateStr(state));\n        }\n      },\n\n      /**\n       * Check that all the require failure recognizers has failed,\n       * if true, it emits a gesture event,\n       * otherwise, setup the state to FAILED.\n       * @param {Object} input\n       */\n      tryEmit: function (input) {\n        if (this.canEmit()) {\n          return this.emit(input);\n        } // it's failing anyway\n\n\n        this.state = STATE_FAILED;\n      },\n\n      /**\n       * can we emit?\n       * @returns {boolean}\n       */\n      canEmit: function () {\n        var i = 0;\n\n        while (i < this.requireFail.length) {\n          if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n            return false;\n          }\n\n          i++;\n        }\n\n        return true;\n      },\n\n      /**\n       * update the recognizer\n       * @param {Object} inputData\n       */\n      recognize: function (inputData) {\n        // make a new copy of the inputData\n        // so we can change the inputData without messing up the other recognizers\n        var inputDataClone = assign({}, inputData); // is is enabled and allow recognizing?\n\n        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n          this.reset();\n          this.state = STATE_FAILED;\n          return;\n        } // reset when we've reached the end\n\n\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n          this.state = STATE_POSSIBLE;\n        }\n\n        this.state = this.process(inputDataClone); // the recognizer has recognized a gesture\n        // so trigger an event\n\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n          this.tryEmit(inputDataClone);\n        }\n      },\n\n      /**\n       * return the state of the recognizer\n       * the actual recognizing happens in this method\n       * @virtual\n       * @param {Object} inputData\n       * @returns {Const} STATE\n       */\n      process: function (inputData) {},\n      // jshint ignore:line\n\n      /**\n       * return the preferred touch-action\n       * @virtual\n       * @returns {Array}\n       */\n      getTouchAction: function () {},\n\n      /**\n       * called when the gesture isn't allowed to recognize\n       * like when another is being recognized or it is disabled\n       * @virtual\n       */\n      reset: function () {}\n    };\n    /**\n     * get a usable string, used as event postfix\n     * @param {Const} state\n     * @returns {String} state\n     */\n\n    function stateStr(state) {\n      if (state & STATE_CANCELLED) {\n        return 'cancel';\n      } else if (state & STATE_ENDED) {\n        return 'end';\n      } else if (state & STATE_CHANGED) {\n        return 'move';\n      } else if (state & STATE_BEGAN) {\n        return 'start';\n      }\n\n      return '';\n    }\n    /**\n     * direction cons to string\n     * @param {Const} direction\n     * @returns {String}\n     */\n\n\n    function directionStr(direction) {\n      if (direction == DIRECTION_DOWN) {\n        return 'down';\n      } else if (direction == DIRECTION_UP) {\n        return 'up';\n      } else if (direction == DIRECTION_LEFT) {\n        return 'left';\n      } else if (direction == DIRECTION_RIGHT) {\n        return 'right';\n      }\n\n      return '';\n    }\n    /**\n     * get a recognizer by name if it is bound to a manager\n     * @param {Recognizer|String} otherRecognizer\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer}\n     */\n\n\n    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n      var manager = recognizer.manager;\n\n      if (manager) {\n        return manager.get(otherRecognizer);\n      }\n\n      return otherRecognizer;\n    }\n    /**\n     * This recognizer is just used as a base for the simple attribute recognizers.\n     * @constructor\n     * @extends Recognizer\n     */\n\n\n    function AttrRecognizer() {\n      Recognizer.apply(this, arguments);\n    }\n\n    inherit(AttrRecognizer, Recognizer, {\n      /**\n       * @namespace\n       * @memberof AttrRecognizer\n       */\n      defaults: {\n        /**\n         * @type {Number}\n         * @default 1\n         */\n        pointers: 1\n      },\n\n      /**\n       * Used to check if it the recognizer receives valid input, like input.distance > 10.\n       * @memberof AttrRecognizer\n       * @param {Object} input\n       * @returns {Boolean} recognized\n       */\n      attrTest: function (input) {\n        var optionPointers = this.options.pointers;\n        return optionPointers === 0 || input.pointers.length === optionPointers;\n      },\n\n      /**\n       * Process the input and return the state for the recognizer\n       * @memberof AttrRecognizer\n       * @param {Object} input\n       * @returns {*} State\n       */\n      process: function (input) {\n        var state = this.state;\n        var eventType = input.eventType;\n        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n        var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED\n\n        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n          return state | STATE_CANCELLED;\n        } else if (isRecognized || isValid) {\n          if (eventType & INPUT_END) {\n            return state | STATE_ENDED;\n          } else if (!(state & STATE_BEGAN)) {\n            return STATE_BEGAN;\n          }\n\n          return state | STATE_CHANGED;\n        }\n\n        return STATE_FAILED;\n      }\n    });\n    /**\n     * Pan\n     * Recognized when the pointer is down and moved in the allowed direction.\n     * @constructor\n     * @extends AttrRecognizer\n     */\n\n    function PanRecognizer() {\n      AttrRecognizer.apply(this, arguments);\n      this.pX = null;\n      this.pY = null;\n    }\n\n    inherit(PanRecognizer, AttrRecognizer, {\n      /**\n       * @namespace\n       * @memberof PanRecognizer\n       */\n      defaults: {\n        event: 'pan',\n        threshold: 10,\n        pointers: 1,\n        direction: DIRECTION_ALL\n      },\n      getTouchAction: function () {\n        var direction = this.options.direction;\n        var actions = [];\n\n        if (direction & DIRECTION_HORIZONTAL) {\n          actions.push(TOUCH_ACTION_PAN_Y);\n        }\n\n        if (direction & DIRECTION_VERTICAL) {\n          actions.push(TOUCH_ACTION_PAN_X);\n        }\n\n        return actions;\n      },\n      directionTest: function (input) {\n        var options = this.options;\n        var hasMoved = true;\n        var distance = input.distance;\n        var direction = input.direction;\n        var x = input.deltaX;\n        var y = input.deltaY; // lock to axis?\n\n        if (!(direction & options.direction)) {\n          if (options.direction & DIRECTION_HORIZONTAL) {\n            direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n            hasMoved = x != this.pX;\n            distance = Math.abs(input.deltaX);\n          } else {\n            direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n            hasMoved = y != this.pY;\n            distance = Math.abs(input.deltaY);\n          }\n        }\n\n        input.direction = direction;\n        return hasMoved && distance > options.threshold && direction & options.direction;\n      },\n      attrTest: function (input) {\n        return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n      },\n      emit: function (input) {\n        this.pX = input.deltaX;\n        this.pY = input.deltaY;\n        var direction = directionStr(input.direction);\n\n        if (direction) {\n          input.additionalEvent = this.options.event + direction;\n        }\n\n        this._super.emit.call(this, input);\n      }\n    });\n    /**\n     * Pinch\n     * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n     * @constructor\n     * @extends AttrRecognizer\n     */\n\n    function PinchRecognizer() {\n      AttrRecognizer.apply(this, arguments);\n    }\n\n    inherit(PinchRecognizer, AttrRecognizer, {\n      /**\n       * @namespace\n       * @memberof PinchRecognizer\n       */\n      defaults: {\n        event: 'pinch',\n        threshold: 0,\n        pointers: 2\n      },\n      getTouchAction: function () {\n        return [TOUCH_ACTION_NONE];\n      },\n      attrTest: function (input) {\n        return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n      },\n      emit: function (input) {\n        if (input.scale !== 1) {\n          var inOut = input.scale < 1 ? 'in' : 'out';\n          input.additionalEvent = this.options.event + inOut;\n        }\n\n        this._super.emit.call(this, input);\n      }\n    });\n    /**\n     * Press\n     * Recognized when the pointer is down for x ms without any movement.\n     * @constructor\n     * @extends Recognizer\n     */\n\n    function PressRecognizer() {\n      Recognizer.apply(this, arguments);\n      this._timer = null;\n      this._input = null;\n    }\n\n    inherit(PressRecognizer, Recognizer, {\n      /**\n       * @namespace\n       * @memberof PressRecognizer\n       */\n      defaults: {\n        event: 'press',\n        pointers: 1,\n        time: 251,\n        // minimal time of the pointer to be pressed\n        threshold: 9 // a minimal movement is ok, but keep it low\n\n      },\n      getTouchAction: function () {\n        return [TOUCH_ACTION_AUTO];\n      },\n      process: function (input) {\n        var options = this.options;\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTime = input.deltaTime > options.time;\n        this._input = input; // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n\n        if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n          this.reset();\n        } else if (input.eventType & INPUT_START) {\n          this.reset();\n          this._timer = setTimeoutContext(function () {\n            this.state = STATE_RECOGNIZED;\n            this.tryEmit();\n          }, options.time, this);\n        } else if (input.eventType & INPUT_END) {\n          return STATE_RECOGNIZED;\n        }\n\n        return STATE_FAILED;\n      },\n      reset: function () {\n        clearTimeout(this._timer);\n      },\n      emit: function (input) {\n        if (this.state !== STATE_RECOGNIZED) {\n          return;\n        }\n\n        if (input && input.eventType & INPUT_END) {\n          this.manager.emit(this.options.event + 'up', input);\n        } else {\n          this._input.timeStamp = now();\n          this.manager.emit(this.options.event, this._input);\n        }\n      }\n    });\n    /**\n     * Rotate\n     * Recognized when two or more pointer are moving in a circular motion.\n     * @constructor\n     * @extends AttrRecognizer\n     */\n\n    function RotateRecognizer() {\n      AttrRecognizer.apply(this, arguments);\n    }\n\n    inherit(RotateRecognizer, AttrRecognizer, {\n      /**\n       * @namespace\n       * @memberof RotateRecognizer\n       */\n      defaults: {\n        event: 'rotate',\n        threshold: 0,\n        pointers: 2\n      },\n      getTouchAction: function () {\n        return [TOUCH_ACTION_NONE];\n      },\n      attrTest: function (input) {\n        return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n      }\n    });\n    /**\n     * Swipe\n     * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n     * @constructor\n     * @extends AttrRecognizer\n     */\n\n    function SwipeRecognizer() {\n      AttrRecognizer.apply(this, arguments);\n    }\n\n    inherit(SwipeRecognizer, AttrRecognizer, {\n      /**\n       * @namespace\n       * @memberof SwipeRecognizer\n       */\n      defaults: {\n        event: 'swipe',\n        threshold: 10,\n        velocity: 0.3,\n        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n        pointers: 1\n      },\n      getTouchAction: function () {\n        return PanRecognizer.prototype.getTouchAction.call(this);\n      },\n      attrTest: function (input) {\n        var direction = this.options.direction;\n        var velocity;\n\n        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n          velocity = input.overallVelocity;\n        } else if (direction & DIRECTION_HORIZONTAL) {\n          velocity = input.overallVelocityX;\n        } else if (direction & DIRECTION_VERTICAL) {\n          velocity = input.overallVelocityY;\n        }\n\n        return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n      },\n      emit: function (input) {\n        var direction = directionStr(input.offsetDirection);\n\n        if (direction) {\n          this.manager.emit(this.options.event + direction, input);\n        }\n\n        this.manager.emit(this.options.event, input);\n      }\n    });\n    /**\n     * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n     * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n     * a single tap.\n     *\n     * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n     * multi-taps being recognized.\n     * @constructor\n     * @extends Recognizer\n     */\n\n    function TapRecognizer() {\n      Recognizer.apply(this, arguments); // previous time and center,\n      // used for tap counting\n\n      this.pTime = false;\n      this.pCenter = false;\n      this._timer = null;\n      this._input = null;\n      this.count = 0;\n    }\n\n    inherit(TapRecognizer, Recognizer, {\n      /**\n       * @namespace\n       * @memberof PinchRecognizer\n       */\n      defaults: {\n        event: 'tap',\n        pointers: 1,\n        taps: 1,\n        interval: 300,\n        // max time between the multi-tap taps\n        time: 250,\n        // max time of the pointer to be down (like finger on the screen)\n        threshold: 9,\n        // a minimal movement is ok, but keep it low\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\n\n      },\n      getTouchAction: function () {\n        return [TOUCH_ACTION_MANIPULATION];\n      },\n      process: function (input) {\n        var options = this.options;\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTouchTime = input.deltaTime < options.time;\n        this.reset();\n\n        if (input.eventType & INPUT_START && this.count === 0) {\n          return this.failTimeout();\n        } // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n\n\n        if (validMovement && validTouchTime && validPointers) {\n          if (input.eventType != INPUT_END) {\n            return this.failTimeout();\n          }\n\n          var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n          var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n          this.pTime = input.timeStamp;\n          this.pCenter = input.center;\n\n          if (!validMultiTap || !validInterval) {\n            this.count = 1;\n          } else {\n            this.count += 1;\n          }\n\n          this._input = input; // if tap count matches we have recognized it,\n          // else it has began recognizing...\n\n          var tapCount = this.count % options.taps;\n\n          if (tapCount === 0) {\n            // no failing requirements, immediately trigger the tap event\n            // or wait as long as the multitap interval to trigger\n            if (!this.hasRequireFailures()) {\n              return STATE_RECOGNIZED;\n            } else {\n              this._timer = setTimeoutContext(function () {\n                this.state = STATE_RECOGNIZED;\n                this.tryEmit();\n              }, options.interval, this);\n              return STATE_BEGAN;\n            }\n          }\n        }\n\n        return STATE_FAILED;\n      },\n      failTimeout: function () {\n        this._timer = setTimeoutContext(function () {\n          this.state = STATE_FAILED;\n        }, this.options.interval, this);\n        return STATE_FAILED;\n      },\n      reset: function () {\n        clearTimeout(this._timer);\n      },\n      emit: function () {\n        if (this.state == STATE_RECOGNIZED) {\n          this._input.tapCount = this.count;\n          this.manager.emit(this.options.event, this._input);\n        }\n      }\n    });\n    /**\n     * Simple way to create a manager with a default set of recognizers.\n     * @param {HTMLElement} element\n     * @param {Object} [options]\n     * @constructor\n     */\n\n    function Hammer(element, options) {\n      options = options || {};\n      options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n      return new Manager(element, options);\n    }\n    /**\n     * @const {string}\n     */\n\n\n    Hammer.VERSION = '2.0.7';\n    /**\n     * default settings\n     * @namespace\n     */\n\n    Hammer.defaults = {\n      /**\n       * set if DOM events are being triggered.\n       * But this is slower and unused by simple implementations, so disabled by default.\n       * @type {Boolean}\n       * @default false\n       */\n      domEvents: false,\n\n      /**\n       * The value for the touchAction property/fallback.\n       * When set to `compute` it will magically set the correct value based on the added recognizers.\n       * @type {String}\n       * @default compute\n       */\n      touchAction: TOUCH_ACTION_COMPUTE,\n\n      /**\n       * @type {Boolean}\n       * @default true\n       */\n      enable: true,\n\n      /**\n       * EXPERIMENTAL FEATURE -- can be removed/changed\n       * Change the parent input target element.\n       * If Null, then it is being set the to main element.\n       * @type {Null|EventTarget}\n       * @default null\n       */\n      inputTarget: null,\n\n      /**\n       * force an input class\n       * @type {Null|Function}\n       * @default null\n       */\n      inputClass: null,\n\n      /**\n       * Default recognizer setup when calling `Hammer()`\n       * When creating a new Manager these will be skipped.\n       * @type {Array}\n       */\n      preset: [// RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n      [RotateRecognizer, {\n        enable: false\n      }], [PinchRecognizer, {\n        enable: false\n      }, ['rotate']], [SwipeRecognizer, {\n        direction: DIRECTION_HORIZONTAL\n      }], [PanRecognizer, {\n        direction: DIRECTION_HORIZONTAL\n      }, ['swipe']], [TapRecognizer], [TapRecognizer, {\n        event: 'doubletap',\n        taps: 2\n      }, ['tap']], [PressRecognizer]],\n\n      /**\n       * Some CSS properties can be used to improve the working of Hammer.\n       * Add them to this method and they will be set when creating a new Manager.\n       * @namespace\n       */\n      cssProps: {\n        /**\n         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userSelect: 'none',\n\n        /**\n         * Disable the Windows Phone grippers when pressing an element.\n         * @type {String}\n         * @default 'none'\n         */\n        touchSelect: 'none',\n\n        /**\n         * Disables the default callout shown when you touch and hold a touch target.\n         * On iOS, when you touch and hold a touch target such as a link, Safari displays\n         * a callout containing information about the link. This property allows you to disable that callout.\n         * @type {String}\n         * @default 'none'\n         */\n        touchCallout: 'none',\n\n        /**\n         * Specifies whether zooming is enabled. Used by IE10>\n         * @type {String}\n         * @default 'none'\n         */\n        contentZooming: 'none',\n\n        /**\n         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userDrag: 'none',\n\n        /**\n         * Overrides the highlight color shown when the user taps a link or a JavaScript\n         * clickable element in iOS. This property obeys the alpha value, if specified.\n         * @type {String}\n         * @default 'rgba(0,0,0,0)'\n         */\n        tapHighlightColor: 'rgba(0,0,0,0)'\n      }\n    };\n    var STOP = 1;\n    var FORCED_STOP = 2;\n    /**\n     * Manager\n     * @param {HTMLElement} element\n     * @param {Object} [options]\n     * @constructor\n     */\n\n    function Manager(element, options) {\n      this.options = assign({}, Hammer.defaults, options || {});\n      this.options.inputTarget = this.options.inputTarget || element;\n      this.handlers = {};\n      this.session = {};\n      this.recognizers = [];\n      this.oldCssProps = {};\n      this.element = element;\n      this.input = createInputInstance(this);\n      this.touchAction = new TouchAction(this, this.options.touchAction);\n      toggleCssProps(this, true);\n      each(this.options.recognizers, function (item) {\n        var recognizer = this.add(new item[0](item[1]));\n        item[2] && recognizer.recognizeWith(item[2]);\n        item[3] && recognizer.requireFailure(item[3]);\n      }, this);\n    }\n\n    Manager.prototype = {\n      /**\n       * set options\n       * @param {Object} options\n       * @returns {Manager}\n       */\n      set: function (options) {\n        assign(this.options, options); // Options that need a little more setup\n\n        if (options.touchAction) {\n          this.touchAction.update();\n        }\n\n        if (options.inputTarget) {\n          // Clean up existing event listeners and reinitialize\n          this.input.destroy();\n          this.input.target = options.inputTarget;\n          this.input.init();\n        }\n\n        return this;\n      },\n\n      /**\n       * stop recognizing for this session.\n       * This session will be discarded, when a new [input]start event is fired.\n       * When forced, the recognizer cycle is stopped immediately.\n       * @param {Boolean} [force]\n       */\n      stop: function (force) {\n        this.session.stopped = force ? FORCED_STOP : STOP;\n      },\n\n      /**\n       * run the recognizers!\n       * called by the inputHandler function on every movement of the pointers (touches)\n       * it walks through all the recognizers and tries to detect the gesture that is being made\n       * @param {Object} inputData\n       */\n      recognize: function (inputData) {\n        var session = this.session;\n\n        if (session.stopped) {\n          return;\n        } // run the touch-action polyfill\n\n\n        this.touchAction.preventDefaults(inputData);\n        var recognizer;\n        var recognizers = this.recognizers; // this holds the recognizer that is being recognized.\n        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n        // if no recognizer is detecting a thing, it is set to `null`\n\n        var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized\n        // or when we're in a new session\n\n        if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n          curRecognizer = session.curRecognizer = null;\n        }\n\n        var i = 0;\n\n        while (i < recognizers.length) {\n          recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.\n          // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n          // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n          //      that is being recognized.\n          // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n          //      this can be setup with the `recognizeWith()` method on the recognizer.\n\n          if (session.stopped !== FORCED_STOP && ( // 1\n          !curRecognizer || recognizer == curRecognizer || // 2\n          recognizer.canRecognizeWith(curRecognizer))) {\n            // 3\n            recognizer.recognize(inputData);\n          } else {\n            recognizer.reset();\n          } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n          // current active recognizer. but only if we don't already have an active recognizer\n\n\n          if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n            curRecognizer = session.curRecognizer = recognizer;\n          }\n\n          i++;\n        }\n      },\n\n      /**\n       * get a recognizer by its event name.\n       * @param {Recognizer|String} recognizer\n       * @returns {Recognizer|Null}\n       */\n      get: function (recognizer) {\n        if (recognizer instanceof Recognizer) {\n          return recognizer;\n        }\n\n        var recognizers = this.recognizers;\n\n        for (var i = 0; i < recognizers.length; i++) {\n          if (recognizers[i].options.event == recognizer) {\n            return recognizers[i];\n          }\n        }\n\n        return null;\n      },\n\n      /**\n       * add a recognizer to the manager\n       * existing recognizers with the same event name will be removed\n       * @param {Recognizer} recognizer\n       * @returns {Recognizer|Manager}\n       */\n      add: function (recognizer) {\n        if (invokeArrayArg(recognizer, 'add', this)) {\n          return this;\n        } // remove existing\n\n\n        var existing = this.get(recognizer.options.event);\n\n        if (existing) {\n          this.remove(existing);\n        }\n\n        this.recognizers.push(recognizer);\n        recognizer.manager = this;\n        this.touchAction.update();\n        return recognizer;\n      },\n\n      /**\n       * remove a recognizer by name or instance\n       * @param {Recognizer|String} recognizer\n       * @returns {Manager}\n       */\n      remove: function (recognizer) {\n        if (invokeArrayArg(recognizer, 'remove', this)) {\n          return this;\n        }\n\n        recognizer = this.get(recognizer); // let's make sure this recognizer exists\n\n        if (recognizer) {\n          var recognizers = this.recognizers;\n          var index = inArray(recognizers, recognizer);\n\n          if (index !== -1) {\n            recognizers.splice(index, 1);\n            this.touchAction.update();\n          }\n        }\n\n        return this;\n      },\n\n      /**\n       * bind event\n       * @param {String} events\n       * @param {Function} handler\n       * @returns {EventEmitter} this\n       */\n      on: function (events, handler) {\n        if (events === undefined) {\n          return;\n        }\n\n        if (handler === undefined) {\n          return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function (event) {\n          handlers[event] = handlers[event] || [];\n          handlers[event].push(handler);\n        });\n        return this;\n      },\n\n      /**\n       * unbind event, leave emit blank to remove all handlers\n       * @param {String} events\n       * @param {Function} [handler]\n       * @returns {EventEmitter} this\n       */\n      off: function (events, handler) {\n        if (events === undefined) {\n          return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function (event) {\n          if (!handler) {\n            delete handlers[event];\n          } else {\n            handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n          }\n        });\n        return this;\n      },\n\n      /**\n       * emit event to the listeners\n       * @param {String} event\n       * @param {Object} data\n       */\n      emit: function (event, data) {\n        // we also want to trigger dom events\n        if (this.options.domEvents) {\n          triggerDomEvent(event, data);\n        } // no handlers, so skip it all\n\n\n        var handlers = this.handlers[event] && this.handlers[event].slice();\n\n        if (!handlers || !handlers.length) {\n          return;\n        }\n\n        data.type = event;\n\n        data.preventDefault = function () {\n          data.srcEvent.preventDefault();\n        };\n\n        var i = 0;\n\n        while (i < handlers.length) {\n          handlers[i](data);\n          i++;\n        }\n      },\n\n      /**\n       * destroy the manager and unbinds all events\n       * it doesn't unbind dom events, that is the user own responsibility\n       */\n      destroy: function () {\n        this.element && toggleCssProps(this, false);\n        this.handlers = {};\n        this.session = {};\n        this.input.destroy();\n        this.element = null;\n      }\n    };\n    /**\n     * add/remove the css properties as defined in manager.options.cssProps\n     * @param {Manager} manager\n     * @param {Boolean} add\n     */\n\n    function toggleCssProps(manager, add) {\n      var element = manager.element;\n\n      if (!element.style) {\n        return;\n      }\n\n      var prop;\n      each(manager.options.cssProps, function (value, name) {\n        prop = prefixed(element.style, name);\n\n        if (add) {\n          manager.oldCssProps[prop] = element.style[prop];\n          element.style[prop] = value;\n        } else {\n          element.style[prop] = manager.oldCssProps[prop] || '';\n        }\n      });\n\n      if (!add) {\n        manager.oldCssProps = {};\n      }\n    }\n    /**\n     * trigger dom event\n     * @param {String} event\n     * @param {Object} data\n     */\n\n\n    function triggerDomEvent(event, data) {\n      var gestureEvent = document.createEvent('Event');\n      gestureEvent.initEvent(event, true, true);\n      gestureEvent.gesture = data;\n      data.target.dispatchEvent(gestureEvent);\n    }\n\n    assign(Hammer, {\n      INPUT_START: INPUT_START,\n      INPUT_MOVE: INPUT_MOVE,\n      INPUT_END: INPUT_END,\n      INPUT_CANCEL: INPUT_CANCEL,\n      STATE_POSSIBLE: STATE_POSSIBLE,\n      STATE_BEGAN: STATE_BEGAN,\n      STATE_CHANGED: STATE_CHANGED,\n      STATE_ENDED: STATE_ENDED,\n      STATE_RECOGNIZED: STATE_RECOGNIZED,\n      STATE_CANCELLED: STATE_CANCELLED,\n      STATE_FAILED: STATE_FAILED,\n      DIRECTION_NONE: DIRECTION_NONE,\n      DIRECTION_LEFT: DIRECTION_LEFT,\n      DIRECTION_RIGHT: DIRECTION_RIGHT,\n      DIRECTION_UP: DIRECTION_UP,\n      DIRECTION_DOWN: DIRECTION_DOWN,\n      DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n      DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n      DIRECTION_ALL: DIRECTION_ALL,\n      Manager: Manager,\n      Input: Input,\n      TouchAction: TouchAction,\n      TouchInput: TouchInput,\n      MouseInput: MouseInput,\n      PointerEventInput: PointerEventInput,\n      TouchMouseInput: TouchMouseInput,\n      SingleTouchInput: SingleTouchInput,\n      Recognizer: Recognizer,\n      AttrRecognizer: AttrRecognizer,\n      Tap: TapRecognizer,\n      Pan: PanRecognizer,\n      Swipe: SwipeRecognizer,\n      Pinch: PinchRecognizer,\n      Rotate: RotateRecognizer,\n      Press: PressRecognizer,\n      on: addEventListeners,\n      off: removeEventListeners,\n      each: each,\n      merge: merge,\n      extend: extend,\n      assign: assign,\n      inherit: inherit,\n      bindFn: bindFn,\n      prefixed: prefixed\n    }); // this prevents errors when Hammer is loaded in the presence of an AMD\n    //  style loader but by script tag, not by the loader.\n\n    var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}; // jshint ignore:line\n\n    freeGlobal.Hammer = Hammer;\n\n    if (typeof undefined === 'function' && undefined.amd) {\n      undefined(function () {\n        return Hammer;\n      });\n    } else if (module.exports) {\n      module.exports = Hammer;\n    } else {\n      window[exportName] = Hammer;\n    }\n  })(window, document, 'Hammer');\n});\n/**\r\n * Muuri Ticker\r\n * Copyright (c) 2018-present, Niklas Rämö <inramo@gmail.com>\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/src/Ticker/LICENSE.md\r\n */\n\nfunction rafFallback(cb) {\n  return window.setTimeout(cb, 16);\n}\n\nvar raf = (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || rafFallback).bind(window);\n/**\r\n * A ticker system for handling DOM reads and writes in an efficient way.\r\n * Contains a read queue and a write queue that are processed on the next\r\n * animation frame when needed.\r\n *\r\n * @class\r\n */\n\nvar Ticker = function (_Component) {\n  inherits(Ticker, _Component);\n\n  function Ticker() {\n    classCallCheck(this, Ticker);\n\n    var _this = possibleConstructorReturn(this, (Ticker.__proto__ || Object.getPrototypeOf(Ticker)).call(this));\n\n    _this._nextTick = null;\n    _this._queue = [];\n    _this._reads = {};\n    _this._writes = {};\n    _this._batch = [];\n    _this._batchReads = {};\n    _this._batchWrites = {};\n    _this._flush = _this._flush.bind(_this);\n    return _this;\n  }\n\n  createClass(Ticker, [{\n    key: 'add',\n    value: function add(id, readCallback, writeCallback, isImportant) {\n      // First, let's check if an item has been added to the queues with the same id\n      // and if so -> remove it.\n      var currentIndex = this._queue.indexOf(id);\n\n      if (currentIndex > -1) this._queue[currentIndex] = undefined; // Add all important callbacks to the beginning of the queue and other\n      // callbacks to the end of the queue.\n\n      isImportant ? this._queue.unshift(id) : this._queue.push(id); // Store callbacks.\n\n      this._reads[id] = readCallback;\n      this._writes[id] = writeCallback; // Finally, let's kick-start the next tick if it is not running yet.\n\n      if (!this._nextTick) this._nextTick = raf(this._flush);\n    }\n  }, {\n    key: 'cancel',\n    value: function cancel(id) {\n      var currentIndex = this._queue.indexOf(id);\n\n      if (currentIndex > -1) {\n        this._queue[currentIndex] = undefined;\n        this._reads[id] = undefined;\n        this._writes[id] = undefined;\n      }\n    }\n  }, {\n    key: '_flush',\n    value: function _flush() {\n      var queue = this._queue;\n      var reads = this._reads;\n      var writes = this._writes;\n      var batch = this._batch;\n      var batchReads = this._batchReads;\n      var batchWrites = this._batchWrites;\n      var length = queue.length;\n      var id = void 0;\n      var i = void 0; // Reset ticker.\n\n      this._nextTick = null; // Setup queues and callback placeholders.\n\n      for (i = 0; i < length; i++) {\n        id = queue[i];\n        if (!id) continue;\n        batch.push(id);\n        batchReads[id] = reads[id];\n        reads[id] = undefined;\n        batchWrites[id] = writes[id];\n        writes[id] = undefined;\n      } // Reset queue.\n\n\n      queue.length = 0; // Process read callbacks.\n\n      for (i = 0; i < length; i++) {\n        id = batch[i];\n\n        if (batchReads[id]) {\n          batchReads[id]();\n          batchReads[id] = undefined;\n        }\n      } // Process write callbacks.\n\n\n      for (i = 0; i < length; i++) {\n        id = batch[i];\n\n        if (batchWrites[id]) {\n          batchWrites[id]();\n          batchWrites[id] = undefined;\n        }\n      } // Reset batch.\n\n\n      batch.length = 0; // Restart the ticker if needed.\n\n      if (!this._nextTick && queue.length) {\n        this._nextTick = raf(this._flush);\n      }\n    }\n  }]);\n  return Ticker;\n}(Component);\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\n\nvar ticker = new Ticker();\nvar layoutTick = 'layout';\nvar visibilityTick = 'visibility';\nvar moveTick = 'move';\nvar scrollTick = 'scroll';\n\nfunction addLayoutTick(itemId, readCallback, writeCallback) {\n  return ticker.add(itemId + layoutTick, readCallback, writeCallback);\n}\n\nfunction cancelLayoutTick(itemId) {\n  return ticker.cancel(itemId + layoutTick);\n}\n\nfunction addVisibilityTick(itemId, readCallback, writeCallback) {\n  return ticker.add(itemId + visibilityTick, readCallback, writeCallback);\n}\n\nfunction cancelVisibilityTick(itemId) {\n  return ticker.cancel(itemId + visibilityTick);\n}\n\nfunction addMoveTick(itemId, readCallback, writeCallback) {\n  return ticker.add(itemId + moveTick, readCallback, writeCallback, true);\n}\n\nfunction cancelMoveTick(itemId) {\n  return ticker.cancel(itemId + moveTick);\n}\n\nfunction addScrollTick(itemId, readCallback, writeCallback) {\n  return ticker.add(itemId + scrollTick, readCallback, writeCallback, true);\n}\n\nfunction cancelScrollTick(itemId) {\n  return ticker.cancel(itemId + scrollTick);\n}\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\n\nvar proto = Element.prototype;\nvar matches = proto.matches || proto.matchesSelector || proto.webkitMatchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector;\n/**\r\n * Check if element matches a CSS selector.\r\n *\r\n * @param {*} val\r\n * @returns {Boolean}\r\n */\n\nfunction elementMatches(el, selector) {\n  return matches.call(el, selector);\n}\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\n/**\r\n * Add class to an element.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {String} className\r\n */\n\n\nfunction addClassModern(element, className) {\n  element.classList.add(className);\n}\n/**\r\n * Add class to an element (legacy version, for IE9 support).\r\n *\r\n * @param {HTMLElement} element\r\n * @param {String} className\r\n */\n\n\nfunction addClassLegacy(element, className) {\n  if (!elementMatches(element, '.' + className)) {\n    element.className += ' ' + className;\n  }\n}\n\nvar addClass = 'classList' in Element.prototype ? addClassModern : addClassLegacy;\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\n/**\r\n * Normalize array index. Basically this function makes sure that the provided\r\n * array index is within the bounds of the provided array and also transforms\r\n * negative index to the matching positive index.\r\n *\r\n * @param {Array} array\r\n * @param {Number} index\r\n * @param {Boolean} isMigration\r\n */\n\nfunction normalizeArrayIndex(array, index, isMigration) {\n  var length = array.length;\n  var maxIndex = Math.max(0, isMigration ? length : length - 1);\n  return index > maxIndex ? maxIndex : index < 0 ? Math.max(maxIndex + index + 1, 0) : index;\n}\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\n/**\r\n * Move array item to another index.\r\n *\r\n * @param {Array} array\r\n * @param {Number} fromIndex\r\n *   - Index (positive or negative) of the item that will be moved.\r\n * @param {Number} toIndex\r\n *   - Index (positive or negative) where the item should be moved to.\r\n */\n\n\nfunction arrayMove(array, fromIndex, toIndex) {\n  // Make sure the array has two or more items.\n  if (array.length < 2) return; // Normalize the indices.\n\n  var from = normalizeArrayIndex(array, fromIndex);\n  var to = normalizeArrayIndex(array, toIndex); // Add target item to the new position.\n\n  if (from !== to) {\n    array.splice(to, 0, array.splice(from, 1)[0]);\n  }\n}\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\n/**\r\n * Swap array items.\r\n *\r\n * @param {Array} array\r\n * @param {Number} index\r\n *   - Index (positive or negative) of the item that will be swapped.\r\n * @param {Number} withIndex\r\n *   - Index (positive or negative) of the other item that will be swapped.\r\n */\n\n\nfunction arraySwap(array, index, withIndex) {\n  // Make sure the array has two or more items.\n  if (array.length < 2) return; // Normalize the indices.\n\n  var indexA = normalizeArrayIndex(array, index);\n  var indexB = normalizeArrayIndex(array, withIndex);\n  var temp = void 0; // Swap the items.\n\n  if (indexA !== indexB) {\n    temp = array[indexA];\n    array[indexA] = array[indexB];\n    array[indexB] = temp;\n  }\n}\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\n\nvar actionCancel = 'cancel';\nvar actionFinish = 'finish';\n/**\r\n * Returns a function, that, as long as it continues to be invoked, will not\r\n * be triggered. The function will be called after it stops being called for\r\n * N milliseconds. The returned function accepts one argument which, when\r\n * being \"finish\", calls the debounce function immediately if it is currently\r\n * waiting to be called, and when being \"cancel\" cancels the currently queued\r\n * function call.\r\n *\r\n * @param {Function} fn\r\n * @param {Number} wait\r\n * @returns {Function}\r\n */\n\nfunction debounce(fn, wait) {\n  var timeout = void 0;\n\n  if (wait > 0) {\n    return function (action) {\n      if (timeout !== undefined) {\n        timeout = window.clearTimeout(timeout);\n        if (action === actionFinish) fn();\n      }\n\n      if (action !== actionCancel && action !== actionFinish) {\n        timeout = window.setTimeout(function () {\n          timeout = undefined;\n          fn();\n        }, wait);\n      }\n    };\n  }\n\n  return function (action) {\n    if (action !== actionCancel) fn();\n  };\n}\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\n/**\r\n * Returns true if element is transformed, false if not. In practice the\r\n * element's display value must be anything else than \"none\" or \"inline\" as\r\n * well as have a valid transform value applied in order to be counted as a\r\n * transformed element.\r\n *\r\n * Borrowed from Mezr (v0.6.1):\r\n * https://github.com/niklasramo/mezr/blob/0.6.1/mezr.js#L661\r\n *\r\n * @param {HTMLElement} element\r\n * @returns {Boolean}\r\n */\n\n\nfunction isTransformed(element) {\n  var transform = getStyle(element, 'transform');\n  if (!transform || transform === 'none') return false;\n  var display = getStyle(element, 'display');\n  if (display === 'inline' || display === 'none') return false;\n  return true;\n}\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\n/**\r\n * Returns an absolute positioned element's containing block, which is\r\n * considered to be the closest ancestor element that the target element's\r\n * positioning is relative to. Disclaimer: this only works as intended for\r\n * absolute positioned elements.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {Boolean} [includeSelf=false]\r\n *   - When this is set to true the containing block checking is started from\r\n *     the provided element. Otherwise the checking is started from the\r\n *     provided element's parent element.\r\n * @returns {(Document|Element)}\r\n */\n\n\nfunction getContainingBlock(element, includeSelf) {\n  // As long as the containing block is an element, static and not\n  // transformed, try to get the element's parent element and fallback to\n  // document. https://github.com/niklasramo/mezr/blob/0.6.1/mezr.js#L339\n  var ret = (includeSelf ? element : element.parentElement) || document;\n\n  while (ret && ret !== document && getStyle(ret, 'position') === 'static' && !isTransformed(ret)) {\n    ret = ret.parentElement || document;\n  }\n\n  return ret;\n}\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\n/**\r\n * Returns the computed value of an element's style property transformed into\r\n * a float value.\r\n *\r\n * @param {HTMLElement} el\r\n * @param {String} style\r\n * @returns {Number}\r\n */\n\n\nfunction getStyleAsFloat(el, style) {\n  return parseFloat(getStyle(el, style)) || 0;\n}\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\n\nvar offsetA = {};\nvar offsetB = {};\nvar offsetDiff = {};\n/**\r\n * Returns the element's document offset, which in practice means the vertical\r\n * and horizontal distance between the element's northwest corner and the\r\n * document's northwest corner. Note that this function always returns the same\r\n * object so be sure to read the data from it instead using it as a reference.\r\n *\r\n * @param {(Document|Element|Window)} element\r\n * @param {Object} [offsetData]\r\n *   - Optional data object where the offset data will be inserted to. If not\r\n *     provided a new object will be created for the return data.\r\n * @returns {Object}\r\n */\n\nfunction getOffset(element, offsetData) {\n  var ret = offsetData || {};\n  var rect = void 0; // Set up return data.\n\n  ret.left = 0;\n  ret.top = 0; // Document's offsets are always 0.\n\n  if (element === document) return ret; // Add viewport scroll left/top to the respective offsets.\n\n  ret.left = window.pageXOffset || 0;\n  ret.top = window.pageYOffset || 0; // Window's offsets are the viewport scroll left/top values.\n\n  if (element.self === window.self) return ret; // Add element's client rects to the offsets.\n\n  rect = element.getBoundingClientRect();\n  ret.left += rect.left;\n  ret.top += rect.top; // Exclude element's borders from the offset.\n\n  ret.left += getStyleAsFloat(element, 'border-left-width');\n  ret.top += getStyleAsFloat(element, 'border-top-width');\n  return ret;\n}\n/**\r\n * Calculate the offset difference two elements.\r\n *\r\n * @param {HTMLElement} elemA\r\n * @param {HTMLElement} elemB\r\n * @param {Boolean} [compareContainingBlocks=false]\r\n *   - When this is set to true the containing blocks of the provided elements\r\n *     will be used for calculating the difference. Otherwise the provided\r\n *     elements will be compared directly.\r\n * @returns {Object}\r\n */\n\n\nfunction getOffsetDiff(elemA, elemB, compareContainingBlocks) {\n  offsetDiff.left = 0;\n  offsetDiff.top = 0; // If elements are same let's return early.\n\n  if (elemA === elemB) return offsetDiff; // Compare containing blocks if necessary.\n\n  if (compareContainingBlocks) {\n    elemA = getContainingBlock(elemA, true);\n    elemB = getContainingBlock(elemB, true); // If containing blocks are identical, let's return early.\n\n    if (elemA === elemB) return offsetDiff;\n  } // Finally, let's calculate the offset diff.\n\n\n  getOffset(elemA, offsetA);\n  getOffset(elemB, offsetB);\n  offsetDiff.left = offsetB.left - offsetA.left;\n  offsetDiff.top = offsetB.top - offsetA.top;\n  return offsetDiff;\n}\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\n\nvar translateData = {};\n/**\r\n * Returns the element's computed translateX and translateY values as a floats.\r\n * The returned object is always the same object and updated every time this\r\n * function is called.\r\n *\r\n * @param {HTMLElement} element\r\n * @returns {Object}\r\n */\n\nfunction getTranslate(element) {\n  translateData.x = 0;\n  translateData.y = 0;\n  var transform = getStyle(element, 'transform');\n  if (!transform) return translateData;\n  var matrixData = transform.replace('matrix(', '').split(',');\n  translateData.x = parseFloat(matrixData[4]) || 0;\n  translateData.y = parseFloat(matrixData[5]) || 0;\n  return translateData;\n}\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\n/**\r\n * Transform translateX and translateY value into CSS transform style\r\n * property's value.\r\n *\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @returns {String}\r\n */\n\n\nfunction getTranslateString(x, y) {\n  return 'translateX(' + x + 'px) translateY(' + y + 'px)';\n}\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\n\nvar tempArray = [];\n/**\r\n * Insert an item or an array of items to array to a specified index. Mutates\r\n * the array. The index can be negative in which case the items will be added\r\n * to the end of the array.\r\n *\r\n * @param {Array} array\r\n * @param {*} items\r\n * @param {Number} [index=-1]\r\n */\n\nfunction arrayInsert(array, items, index) {\n  var startIndex = typeof index === 'number' ? index : -1;\n  if (startIndex < 0) startIndex = array.length - startIndex + 1;\n  array.splice.apply(array, toConsumableArray(tempArray.concat(startIndex, 0, items)));\n  tempArray.length = 0;\n}\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\n\nvar objectType = '[object Object]';\nvar toString = Object.prototype.toString;\n/**\r\n * Check if a value is a plain object.\r\n *\r\n * @param {*} val\r\n * @returns {Boolean}\r\n */\n\nfunction isPlainObject(val) {\n  return (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && toString.call(val) === objectType;\n}\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\n/**\r\n * Remove class from an element.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {String} className\r\n */\n\n\nfunction removeClassModern(element, className) {\n  element.classList.remove(className);\n}\n/**\r\n * Remove class from an element (legacy version, for IE9 support).\r\n *\r\n * @param {HTMLElement} element\r\n * @param {String} className\r\n */\n\n\nfunction removeClassLegacy(element, className) {\n  if (elementMatches(element, '.' + className)) {\n    element.className = (' ' + element.className + ' ').replace(' ' + className + ' ', ' ').trim();\n  }\n}\n\nvar removeClass = 'classList' in Element.prototype ? removeClassModern : removeClassLegacy;\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n// To provide consistently correct dragging experience we need to know if\n// transformed elements leak fixed elements or not.\n\nvar hasTransformLeak = checkTransformLeak(); // Drag start predicate states.\n\nvar startPredicateInactive = 0;\nvar startPredicatePending = 1;\nvar startPredicateResolved = 2;\nvar startPredicateRejected = 3;\n/**\r\n * Bind Hammer touch interaction to an item.\r\n *\r\n * @class\r\n * @param {Item} item\r\n */\n\nvar ItemDrag = function (_Component) {\n  inherits(ItemDrag, _Component);\n\n  function ItemDrag(item) {\n    classCallCheck(this, ItemDrag);\n\n    var _this = possibleConstructorReturn(this, (ItemDrag.__proto__ || Object.getPrototypeOf(ItemDrag)).call(this, item));\n\n    if (!hammer) {\n      throw new Error('[' + namespace + '] required dependency Hammer is not defined.');\n    } // If we don't have a valid transform leak test result yet, let's run the\n    // test on first ItemDrag init. The test needs body element to be ready and\n    // here we can be sure that it is ready.\n\n\n    if (hasTransformLeak === null) {\n      hasTransformLeak = checkTransformLeak();\n    }\n\n    var drag = _this;\n    var element = item._element;\n    var grid = item.getGrid();\n    var settings = grid._settings;\n    var hammer$$1 = void 0; // Start predicate private data.\n\n    var startPredicate = typeof settings.dragStartPredicate === 'function' ? settings.dragStartPredicate : ItemDrag.defaultStartPredicate;\n    var startPredicateState = startPredicateInactive;\n    var startPredicateResult = void 0; // Protected data.\n\n    _this._item = item;\n    _this._gridId = grid._id;\n    _this._hammer = hammer$$1 = new hammer.Manager(element);\n    _this._isDestroyed = false;\n    _this._isMigrating = false; // Setup item's initial drag data.\n\n    _this._reset(); // Bind some methods that needs binding.\n\n\n    _this._onScroll = _this._onScroll.bind(_this);\n    _this._prepareMove = _this._prepareMove.bind(_this);\n    _this._applyMove = _this._applyMove.bind(_this);\n    _this._prepareScroll = _this._prepareScroll.bind(_this);\n    _this._applyScroll = _this._applyScroll.bind(_this);\n    _this._checkOverlap = _this._checkOverlap.bind(_this); // Create a private drag start resolver that can be used to resolve the drag\n    // start predicate asynchronously.\n\n    _this._forceResolveStartPredicate = function (event) {\n      if (!this._isDestroyed && startPredicateState === startPredicatePending) {\n        startPredicateState = startPredicateResolved;\n\n        this._onStart(event);\n      }\n    }; // Create debounce overlap checker function.\n\n\n    _this._checkOverlapDebounce = debounce(_this._checkOverlap, settings.dragSortInterval); // Add drag recognizer to hammer.\n\n    hammer$$1.add(new hammer.Pan({\n      event: 'drag',\n      pointers: 1,\n      threshold: 0,\n      direction: hammer.DIRECTION_ALL\n    })); // Add drag init recognizer to hammer.\n\n    hammer$$1.add(new hammer.Press({\n      event: 'draginit',\n      pointers: 1,\n      threshold: 1000,\n      time: 0\n    })); // Configure the hammer instance.\n\n    if (isPlainObject(settings.dragHammerSettings)) {\n      hammer$$1.set(settings.dragHammerSettings);\n    } // Bind drag events.\n\n\n    hammer$$1.on('draginit dragstart dragmove', function (e) {\n      // Let's activate drag start predicate state.\n      if (startPredicateState === startPredicateInactive) {\n        startPredicateState = startPredicatePending;\n      } // If predicate is pending try to resolve it.\n\n\n      if (startPredicateState === startPredicatePending) {\n        startPredicateResult = startPredicate(drag._item, e);\n\n        if (startPredicateResult === true) {\n          startPredicateState = startPredicateResolved;\n\n          drag._onStart(e);\n        } else if (startPredicateResult === false) {\n          startPredicateState = startPredicateRejected;\n        }\n      } // Otherwise if predicate is resolved and drag is active, move the item.\n      else if (startPredicateState === startPredicateResolved && drag._isActive) {\n          drag._onMove(e);\n        }\n    }).on('dragend dragcancel draginitup', function (e) {\n      // Check if the start predicate was resolved during drag.\n      var isResolved = startPredicateState === startPredicateResolved; // Do final predicate check to allow user to unbind stuff for the current\n      // drag procedure within the predicate callback. The return value of this\n      // check will have no effect to the state of the predicate.\n\n      startPredicate(drag._item, e); // Reset start predicate state.\n\n      startPredicateState = startPredicateInactive; // If predicate is resolved and dragging is active, call the end handler.\n\n      if (isResolved && drag._isActive) drag._onEnd(e);\n    }); // Prevent native link/image dragging for the item and it's ancestors.\n\n    element.addEventListener('dragstart', preventDefault, false);\n    return _this;\n  }\n  /**\r\n   * Public prototype methods\r\n   * ************************\r\n   */\n\n  /**\r\n   * Abort dragging and reset drag data.\r\n   *\r\n   * @public\r\n   * @memberof ItemDrag.prototype\r\n   * @returns {ItemDrag}\r\n   */\n\n\n  createClass(ItemDrag, [{\n    key: 'stop',\n    value: function stop() {\n      var item = this._item;\n      var element = item._element;\n\n      var grid = this._getGrid();\n\n      if (!this._isActive) return this; // If the item is being dropped into another grid, finish it up and return\n      // immediately.\n\n      if (this._isMigrating) {\n        this._finishMigration();\n\n        return this;\n      } // Cancel queued move and scroll ticks.\n\n\n      cancelMoveTick(item._id);\n      cancelScrollTick(item._id); // Remove scroll listeners.\n\n      this._unbindScrollListeners(); // Cancel overlap check.\n\n\n      this._checkOverlapDebounce('cancel'); // Append item element to the container if it's not it's child. Also make\n      // sure the translate values are adjusted to account for the DOM shift.\n\n\n      if (element.parentNode !== grid._element) {\n        grid._element.appendChild(element);\n\n        element.style[transformProp] = getTranslateString(this._gridX, this._gridY);\n      } // Remove dragging class.\n\n\n      removeClass(element, grid._settings.itemDraggingClass); // Reset drag data.\n\n      this._reset();\n\n      return this;\n    }\n    /**\r\n     * Destroy instance.\r\n     *\r\n     * @public\r\n     * @memberof ItemDrag.prototype\r\n     * @returns {ItemDrag}\r\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      if (this._isDestroyed) return this;\n      this.stop();\n\n      this._hammer.destroy();\n\n      this._item._element.removeEventListener('dragstart', preventDefault, false);\n\n      this._isDestroyed = true;\n      return this;\n    }\n    /**\r\n     * Private prototype methods\r\n     * *************************\r\n     */\n\n    /**\r\n     * Get Grid instance.\r\n     *\r\n     * @private\r\n     * @memberof ItemDrag.prototype\r\n     * @returns {?Grid}\r\n     */\n\n  }, {\n    key: '_getGrid',\n    value: function _getGrid() {\n      return gridInstances[this._gridId] || null;\n    }\n    /**\r\n     * Setup/reset drag data.\r\n     *\r\n     * @private\r\n     * @memberof ItemDrag.prototype\r\n     */\n\n  }, {\n    key: '_reset',\n    value: function _reset() {\n      // Is item being dragged?\n      this._isActive = false; // The dragged item's container element.\n\n      this._container = null; // The dragged item's containing block.\n\n      this._containingBlock = null; // Hammer event data.\n\n      this._lastEvent = null;\n      this._lastScrollEvent = null; // All the elements which need to be listened for scroll events during\n      // dragging.\n\n      this._scrollers = []; // The current translateX/translateY position.\n\n      this._left = 0;\n      this._top = 0; // Dragged element's current position within the grid.\n\n      this._gridX = 0;\n      this._gridY = 0; // Dragged element's current offset from window's northwest corner. Does\n      // not account for element's margins.\n\n      this._elementClientX = 0;\n      this._elementClientY = 0; // Offset difference between the dragged element's temporary drag\n      // container and it's original container.\n\n      this._containerDiffX = 0;\n      this._containerDiffY = 0;\n    }\n    /**\r\n     * Bind drag scroll handlers to all scrollable ancestor elements of the\r\n     * dragged element and the drag container element.\r\n     *\r\n     * @private\r\n     * @memberof ItemDrag.prototype\r\n     */\n\n  }, {\n    key: '_bindScrollListeners',\n    value: function _bindScrollListeners() {\n      var gridContainer = this._getGrid()._element;\n\n      var dragContainer = this._container;\n      var scrollers = this._scrollers;\n      var containerScrollers = void 0;\n      var i = void 0; // Get dragged element's scrolling parents.\n\n      scrollers.length = 0;\n      getScrollParents(this._item._element, scrollers); // If drag container is defined and it's not the same element as grid\n      // container then we need to add the grid container and it's scroll parents\n      // to the elements which are going to be listener for scroll events.\n\n      if (dragContainer !== gridContainer) {\n        containerScrollers = [];\n        getScrollParents(gridContainer, containerScrollers);\n        containerScrollers.push(gridContainer);\n\n        for (i = 0; i < containerScrollers.length; i++) {\n          if (!scrollers.includes(containerScrollers[i])) {\n            scrollers.push(containerScrollers[i]);\n          }\n        }\n      } // Bind scroll listeners.\n\n\n      for (i = 0; i < scrollers.length; i++) {\n        scrollers[i].addEventListener('scroll', this._onScroll);\n      }\n    }\n    /**\r\n     * Unbind currently bound drag scroll handlers from all scrollable ancestor\r\n     * elements of the dragged element and the drag container element.\r\n     *\r\n     * @private\r\n     * @memberof ItemDrag.prototype\r\n     */\n\n  }, {\n    key: '_unbindScrollListeners',\n    value: function _unbindScrollListeners() {\n      var scrollers = this._scrollers;\n      var i = void 0;\n\n      for (i = 0; i < scrollers.length; i++) {\n        scrollers[i].removeEventListener('scroll', this._onScroll);\n      }\n\n      scrollers.length = 0;\n    }\n    /**\r\n     * Setup default start predicate.\r\n     *\r\n     * @private\r\n     * @memberof ItemDrag.prototype\r\n     * @param {Object} [options]\r\n     * @returns {Object}\r\n     */\n\n  }, {\n    key: '_setupStartPredicate',\n    value: function _setupStartPredicate(options) {\n      var config = options || this._getGrid()._settings.dragStartPredicate || 0;\n      return this._startPredicateData = {\n        distance: Math.abs(config.distance) || 0,\n        delay: Math.max(config.delay, 0) || 0,\n        handle: typeof config.handle === 'string' ? config.handle : false\n      };\n    }\n    /**\r\n     * Setup default start predicate handle.\r\n     *\r\n     * @private\r\n     * @memberof ItemDrag.prototype\r\n     * @param {Object} event\r\n     * @returns {?HTMLElement}\r\n     */\n\n  }, {\n    key: '_getStartPredicateHandle',\n    value: function _getStartPredicateHandle(event) {\n      var predicate = this._startPredicateData;\n      var element = this._item._element;\n      var handleElement = element; // No handle, no hassle -> let's use the item element as the handle.\n\n      if (!predicate.handle) return handleElement; // If there is a specific predicate handle defined, let's try to get it.\n\n      handleElement = (event.changedPointers[0] || 0).target;\n\n      while (handleElement && !elementMatches(handleElement, predicate.handle)) {\n        handleElement = handleElement !== element ? handleElement.parentElement : null;\n      }\n\n      return handleElement || null;\n    }\n    /**\r\n     * Unbind currently bound drag scroll handlers from all scrollable ancestor\r\n     * elements of the dragged element and the drag container element.\r\n     *\r\n     * @private\r\n     * @memberof ItemDrag.prototype\r\n     * @param {Object} event\r\n     * @returns {Boolean}\r\n     */\n\n  }, {\n    key: '_resolveStartPredicate',\n    value: function _resolveStartPredicate(event) {\n      var predicate = this._startPredicateData;\n      var pointer = event.changedPointers[0];\n      var pageX = pointer && pointer.pageX || 0;\n      var pageY = pointer && pointer.pageY || 0;\n      var handleRect = void 0;\n      var handleLeft = void 0;\n      var handleTop = void 0;\n      var handleWidth = void 0;\n      var handleHeight = void 0; // If the moved distance is smaller than the threshold distance or there is\n      // some delay left, ignore this predicate cycle.\n\n      if (event.distance < predicate.distance || predicate.delay) return; // Get handle rect data.\n\n      handleRect = predicate.handleElement.getBoundingClientRect();\n      handleLeft = handleRect.left + (window.pageXOffset || 0);\n      handleTop = handleRect.top + (window.pageYOffset || 0);\n      handleWidth = handleRect.width;\n      handleHeight = handleRect.height; // Reset predicate data.\n\n      this._resetStartPredicate(); // If the cursor is still within the handle let's start the drag.\n\n\n      return handleWidth && handleHeight && pageX >= handleLeft && pageX < handleLeft + handleWidth && pageY >= handleTop && pageY < handleTop + handleHeight;\n    }\n    /**\r\n     * Finalize start predicate.\r\n     *\r\n     * @private\r\n     * @memberof ItemDrag.prototype\r\n     * @param {Object} event\r\n     */\n\n  }, {\n    key: '_finishStartPredicate',\n    value: function _finishStartPredicate(event) {\n      var element = this._item._element; // Reset predicate.\n\n      this._resetStartPredicate(); // If the gesture can be interpreted as click let's try to open the element's\n      // href url (if it is an anchor element).\n\n\n      if (isClick(event)) openAnchorHref(element);\n    }\n    /**\r\n     * Reset for default drag start predicate function.\r\n     *\r\n     * @private\r\n     * @memberof ItemDrag.prototype\r\n     */\n\n  }, {\n    key: '_resetStartPredicate',\n    value: function _resetStartPredicate() {\n      var predicate = this._startPredicateData;\n\n      if (predicate) {\n        if (predicate.delayTimer) {\n          predicate.delayTimer = window.clearTimeout(predicate.delayTimer);\n        }\n\n        this._startPredicateData = null;\n      }\n    }\n    /**\r\n     * Check (during drag) if an item is overlapping other items and based on\r\n     * the configuration layout the items.\r\n     *\r\n     * @private\r\n     * @memberof ItemDrag.prototype\r\n     */\n\n  }, {\n    key: '_checkOverlap',\n    value: function _checkOverlap() {\n      if (!this._isActive) return;\n      var item = this._item;\n\n      var settings = this._getGrid()._settings;\n\n      var result = void 0;\n      var currentGrid = void 0;\n      var currentIndex = void 0;\n      var targetGrid = void 0;\n      var targetIndex = void 0;\n      var sortAction = void 0;\n      var isMigration = void 0; // Get overlap check result.\n\n      if (typeof settings.dragSortPredicate === 'function') {\n        result = settings.dragSortPredicate(item, this._lastEvent);\n      } else {\n        result = ItemDrag.defaultSortPredicate(item, settings.dragSortPredicate);\n      } // Let's make sure the result object has a valid index before going further.\n\n\n      if (!result || typeof result.index !== 'number') return;\n      currentGrid = item.getGrid();\n      targetGrid = result.grid || currentGrid;\n      isMigration = currentGrid !== targetGrid;\n      currentIndex = currentGrid._items.indexOf(item);\n      targetIndex = normalizeArrayIndex(targetGrid._items, result.index, isMigration);\n      sortAction = result.action === 'swap' ? 'swap' : 'move'; // If the item was moved within it's current grid.\n\n      if (!isMigration) {\n        // Make sure the target index is not the current index.\n        if (currentIndex !== targetIndex) {\n          // Do the sort.\n          (sortAction === 'swap' ? arraySwap : arrayMove)(currentGrid._items, currentIndex, targetIndex); // Emit move event.\n\n          if (currentGrid._hasListeners(eventMove)) {\n            currentGrid._emit(eventMove, {\n              item: item,\n              fromIndex: currentIndex,\n              toIndex: targetIndex,\n              action: sortAction\n            });\n          } // Layout the grid.\n\n\n          currentGrid.layout();\n        }\n      } // If the item was moved to another grid.\n      else {\n          // Emit beforeSend event.\n          if (currentGrid._hasListeners(eventBeforeSend)) {\n            currentGrid._emit(eventBeforeSend, {\n              item: item,\n              fromGrid: currentGrid,\n              fromIndex: currentIndex,\n              toGrid: targetGrid,\n              toIndex: targetIndex\n            });\n          } // Emit beforeReceive event.\n\n\n          if (targetGrid._hasListeners(eventBeforeReceive)) {\n            targetGrid._emit(eventBeforeReceive, {\n              item: item,\n              fromGrid: currentGrid,\n              fromIndex: currentIndex,\n              toGrid: targetGrid,\n              toIndex: targetIndex\n            });\n          } // Update item's grid id reference.\n\n\n          item._gridId = targetGrid._id; // Update drag instance's migrating indicator.\n\n          this._isMigrating = item._gridId !== this._gridId; // Move item instance from current grid to target grid.\n\n          currentGrid._items.splice(currentIndex, 1);\n\n          arrayInsert(targetGrid._items, item, targetIndex); // Set sort data as null, which is an indicator for the item comparison\n          // function that the sort data of this specific item should be fetched\n          // lazily.\n\n          item._sortData = null; // Emit send event.\n\n          if (currentGrid._hasListeners(eventSend)) {\n            currentGrid._emit(eventSend, {\n              item: item,\n              fromGrid: currentGrid,\n              fromIndex: currentIndex,\n              toGrid: targetGrid,\n              toIndex: targetIndex\n            });\n          } // Emit receive event.\n\n\n          if (targetGrid._hasListeners(eventReceive)) {\n            targetGrid._emit(eventReceive, {\n              item: item,\n              fromGrid: currentGrid,\n              fromIndex: currentIndex,\n              toGrid: targetGrid,\n              toIndex: targetIndex\n            });\n          } // Layout both grids.\n\n\n          currentGrid.layout();\n          targetGrid.layout();\n        }\n    }\n    /**\r\n     * If item is dragged into another grid, finish the migration process\r\n     * gracefully.\r\n     *\r\n     * @private\r\n     * @memberof ItemDrag.prototype\r\n     */\n\n  }, {\n    key: '_finishMigration',\n    value: function _finishMigration() {\n      var item = this._item;\n      var release = item._release;\n      var element = item._element;\n      var isActive = item._isActive;\n      var targetGrid = item.getGrid();\n      var targetGridElement = targetGrid._element;\n      var targetSettings = targetGrid._settings;\n      var targetContainer = targetSettings.dragContainer || targetGridElement;\n\n      var currentSettings = this._getGrid()._settings;\n\n      var currentContainer = element.parentNode;\n      var translate = void 0;\n      var offsetDiff = void 0; // Destroy current drag. Note that we need to set the migrating flag to\n      // false first, because otherwise we create an infinite loop between this\n      // and the drag.stop() method.\n\n      this._isMigrating = false;\n      this.destroy(); // Remove current classnames.\n\n      removeClass(element, currentSettings.itemClass);\n      removeClass(element, currentSettings.itemVisibleClass);\n      removeClass(element, currentSettings.itemHiddenClass); // Add new classnames.\n\n      addClass(element, targetSettings.itemClass);\n      addClass(element, isActive ? targetSettings.itemVisibleClass : targetSettings.itemHiddenClass); // Move the item inside the target container if it's different than the\n      // current container.\n\n      if (targetContainer !== currentContainer) {\n        targetContainer.appendChild(element);\n        offsetDiff = getOffsetDiff(currentContainer, targetContainer, true);\n        translate = getTranslate(element);\n        translate.x -= offsetDiff.left;\n        translate.y -= offsetDiff.top;\n      } // Update item's cached dimensions and sort data.\n\n\n      item._refreshDimensions();\n\n      item._refreshSortData(); // Calculate the offset difference between target's drag container (if any)\n      // and actual grid container element. We save it later for the release\n      // process.\n\n\n      offsetDiff = getOffsetDiff(targetContainer, targetGridElement, true);\n      release._containerDiffX = offsetDiff.left;\n      release._containerDiffY = offsetDiff.top; // Recreate item's drag handler.\n\n      item._drag = targetSettings.dragEnabled ? new ItemDrag(item) : null; // Adjust the position of the item element if it was moved from a container\n      // to another.\n\n      if (targetContainer !== currentContainer) {\n        element.style[transformProp] = getTranslateString(translate.x, translate.y);\n      } // Update child element's styles to reflect the current visibility state.\n\n\n      item._child.removeAttribute('style');\n\n      setStyles(item._child, isActive ? targetSettings.visibleStyles : targetSettings.hiddenStyles); // Start the release.\n\n      release.start();\n    }\n    /**\r\n     * Drag start handler.\r\n     *\r\n     * @private\r\n     * @memberof ItemDrag.prototype\r\n     * @param {Object} event\r\n     */\n\n  }, {\n    key: '_onStart',\n    value: function _onStart(event) {\n      var item = this._item; // If item is not active, don't start the drag.\n\n      if (!item._isActive) return;\n      var element = item._element;\n\n      var grid = this._getGrid();\n\n      var settings = grid._settings;\n      var release = item._release;\n      var migrate = item._migrate;\n      var gridContainer = grid._element;\n      var dragContainer = settings.dragContainer || gridContainer;\n      var containingBlock = getContainingBlock(dragContainer, true);\n      var translate = getTranslate(element);\n      var currentLeft = translate.x;\n      var currentTop = translate.y;\n      var elementRect = element.getBoundingClientRect();\n      var hasDragContainer = dragContainer !== gridContainer;\n      var offsetDiff = void 0; // If grid container is not the drag container, we need to calculate the\n      // offset difference between grid container and drag container's containing\n      // element.\n\n      if (hasDragContainer) {\n        offsetDiff = getOffsetDiff(containingBlock, gridContainer);\n      } // Stop current positioning animation.\n\n\n      if (item.isPositioning()) {\n        item._layout.stop(true, {\n          transform: getTranslateString(currentLeft, currentTop)\n        });\n      } // Stop current migration animation.\n\n\n      if (migrate._isActive) {\n        currentLeft -= migrate._containerDiffX;\n        currentTop -= migrate._containerDiffY;\n        migrate.stop(true, {\n          transform: getTranslateString(currentLeft, currentTop)\n        });\n      } // If item is being released reset release data.\n\n\n      if (item.isReleasing()) release._reset(); // Setup drag data.\n\n      this._isActive = true;\n      this._lastEvent = event;\n      this._container = dragContainer;\n      this._containingBlock = containingBlock;\n      this._elementClientX = elementRect.left;\n      this._elementClientY = elementRect.top;\n      this._left = this._gridX = currentLeft;\n      this._top = this._gridY = currentTop; // Emit dragInit event.\n\n      grid._emit(eventDragInit, item, event); // If a specific drag container is set and it is different from the\n      // grid's container element we need to cast some extra spells.\n\n\n      if (hasDragContainer) {\n        // Store the container offset diffs to drag data.\n        this._containerDiffX = offsetDiff.left;\n        this._containerDiffY = offsetDiff.top; // If the dragged element is a child of the drag container all we need to\n        // do is setup the relative drag position data.\n\n        if (element.parentNode === dragContainer) {\n          this._gridX = currentLeft - this._containerDiffX;\n          this._gridY = currentTop - this._containerDiffY;\n        } // Otherwise we need to append the element inside the correct container,\n        // setup the actual drag position data and adjust the element's translate\n        // values to account for the DOM position shift.\n        else {\n            this._left = currentLeft + this._containerDiffX;\n            this._top = currentTop + this._containerDiffY;\n            dragContainer.appendChild(element);\n            element.style[transformProp] = getTranslateString(this._left, this._top);\n          }\n      } // Set drag class and bind scrollers.\n\n\n      addClass(element, settings.itemDraggingClass);\n\n      this._bindScrollListeners(); // Emit dragStart event.\n\n\n      grid._emit(eventDragStart, item, event);\n    }\n    /**\r\n     * Drag move handler.\r\n     *\r\n     * @private\r\n     * @memberof ItemDrag.prototype\r\n     * @param {Object} event\r\n     */\n\n  }, {\n    key: '_onMove',\n    value: function _onMove(event) {\n      var item = this._item; // If item is not active, reset drag.\n\n      if (!item._isActive) {\n        this.stop();\n        return;\n      }\n\n      var settings = this._getGrid()._settings;\n\n      var axis = settings.dragAxis;\n      var xDiff = event.deltaX - this._lastEvent.deltaX;\n      var yDiff = event.deltaY - this._lastEvent.deltaY; // Update last event.\n\n      this._lastEvent = event; // Update horizontal position data.\n\n      if (axis !== 'y') {\n        this._left += xDiff;\n        this._gridX += xDiff;\n        this._elementClientX += xDiff;\n      } // Update vertical position data.\n\n\n      if (axis !== 'x') {\n        this._top += yDiff;\n        this._gridY += yDiff;\n        this._elementClientY += yDiff;\n      } // Do move prepare/apply handling in the next tick.\n\n\n      addMoveTick(item._id, this._prepareMove, this._applyMove);\n    }\n    /**\r\n     * Prepare dragged item for moving.\r\n     *\r\n     * @private\r\n     * @memberof ItemDrag.prototype\r\n     */\n\n  }, {\n    key: '_prepareMove',\n    value: function _prepareMove() {\n      // Do nothing if item is not active.\n      if (!this._item._isActive) return; // If drag sort is enabled -> check overlap.\n\n      if (this._getGrid()._settings.dragSort) this._checkOverlapDebounce();\n    }\n    /**\r\n     * Apply movement to dragged item.\r\n     *\r\n     * @private\r\n     * @memberof ItemDrag.prototype\r\n     */\n\n  }, {\n    key: '_applyMove',\n    value: function _applyMove() {\n      var item = this._item; // Do nothing if item is not active.\n\n      if (!item._isActive) return; // Update element's translateX/Y values.\n\n      item._element.style[transformProp] = getTranslateString(this._left, this._top); // Emit dragMove event.\n\n      this._getGrid()._emit(eventDragMove, item, this._lastEvent);\n    }\n    /**\r\n     * Drag scroll handler.\r\n     *\r\n     * @private\r\n     * @memberof ItemDrag.prototype\r\n     * @param {Object} event\r\n     */\n\n  }, {\n    key: '_onScroll',\n    value: function _onScroll(event) {\n      var item = this._item; // If item is not active, reset drag.\n\n      if (!item._isActive) {\n        this.stop();\n        return;\n      } // Update last scroll event.\n\n\n      this._lastScrollEvent = event; // Do scroll prepare/apply handling in the next tick.\n\n      addScrollTick(item._id, this._prepareScroll, this._applyScroll);\n    }\n    /**\r\n     * Prepare dragged item for scrolling.\r\n     *\r\n     * @private\r\n     * @memberof ItemDrag.prototype\r\n     */\n\n  }, {\n    key: '_prepareScroll',\n    value: function _prepareScroll() {\n      var item = this._item; // If item is not active do nothing.\n\n      if (!item._isActive) return;\n      var element = item._element;\n\n      var grid = this._getGrid();\n\n      var settings = grid._settings;\n      var axis = settings.dragAxis;\n      var gridContainer = grid._element;\n      var offsetDiff = void 0; // Calculate element's rect and x/y diff.\n\n      var rect = element.getBoundingClientRect();\n      var xDiff = this._elementClientX - rect.left;\n      var yDiff = this._elementClientY - rect.top; // Update container diff.\n\n      if (this._container !== gridContainer) {\n        offsetDiff = getOffsetDiff(this._containingBlock, gridContainer);\n        this._containerDiffX = offsetDiff.left;\n        this._containerDiffY = offsetDiff.top;\n      } // Update horizontal position data.\n\n\n      if (axis !== 'y') {\n        this._left += xDiff;\n        this._gridX = this._left - this._containerDiffX;\n      } // Update vertical position data.\n\n\n      if (axis !== 'x') {\n        this._top += yDiff;\n        this._gridY = this._top - this._containerDiffY;\n      } // Overlap handling.\n\n\n      if (settings.dragSort) this._checkOverlapDebounce();\n    }\n    /**\r\n     * Apply scroll to dragged item.\r\n     *\r\n     * @private\r\n     * @memberof ItemDrag.prototype\r\n     */\n\n  }, {\n    key: '_applyScroll',\n    value: function _applyScroll() {\n      var item = this._item; // If item is not active do nothing.\n\n      if (!item._isActive) return; // Update element's translateX/Y values.\n\n      item._element.style[transformProp] = getTranslateString(this._left, this._top); // Emit dragScroll event.\n\n      this._getGrid()._emit(eventDragScroll, item, this._lastScrollEvent);\n    }\n    /**\r\n     * Drag end handler.\r\n     *\r\n     * @private\r\n     * @memberof ItemDrag.prototype\r\n     * @param {Object} event\r\n     */\n\n  }, {\n    key: '_onEnd',\n    value: function _onEnd(event) {\n      var item = this._item;\n      var element = item._element;\n\n      var grid = this._getGrid();\n\n      var settings = grid._settings;\n      var release = item._release; // If item is not active, reset drag.\n\n      if (!item._isActive) {\n        this.stop();\n        return;\n      } // Cancel queued move and scroll ticks.\n\n\n      cancelMoveTick(item._id);\n      cancelScrollTick(item._id); // Finish currently queued overlap check.\n\n      settings.dragSort && this._checkOverlapDebounce('finish'); // Remove scroll listeners.\n\n      this._unbindScrollListeners(); // Setup release data.\n\n\n      release._containerDiffX = this._containerDiffX;\n      release._containerDiffY = this._containerDiffY; // Reset drag data.\n\n      this._reset(); // Remove drag class name from element.\n\n\n      removeClass(element, settings.itemDraggingClass); // Emit dragEnd event.\n\n      grid._emit(eventDragEnd, item, event); // Finish up the migration process or start the release process.\n\n\n      this._isMigrating ? this._finishMigration() : release.start();\n    }\n  }]);\n  return ItemDrag;\n}(Component);\n/**\r\n * Public static methods\r\n * *********************\r\n */\n\n/**\r\n * Default drag start predicate handler that handles anchor elements\r\n * gracefully. The return value of this function defines if the drag is\r\n * started, rejected or pending. When true is returned the dragging is started\r\n * and when false is returned the dragging is rejected. If nothing is returned\r\n * the predicate will be called again on the next drag movement.\r\n *\r\n * @public\r\n * @memberof ItemDrag\r\n * @param {Item} item\r\n * @param {Object} event\r\n * @param {Object} [options]\r\n *   - An optional options object which can be used to pass the predicate\r\n *     it's options manually. By default the predicate retrieves the options\r\n *     from the grid's settings.\r\n * @returns {Boolean}\r\n */\n\n\nItemDrag.defaultStartPredicate = function (item, event, options) {\n  var drag = item._drag;\n\n  var predicate = drag._startPredicateData || drag._setupStartPredicate(options); // Final event logic. At this stage return value does not matter anymore,\n  // the predicate is either resolved or it's not and there's nothing to do\n  // about it. Here we just reset data and if the item element is a link\n  // we follow it (if there has only been slight movement).\n\n\n  if (event.isFinal) {\n    drag._finishStartPredicate(event);\n\n    return;\n  } // Find and store the handle element so we can check later on if the\n  // cursor is within the handle. If we have a handle selector let's find\n  // the corresponding element. Otherwise let's use the item element as the\n  // handle.\n\n\n  if (!predicate.handleElement) {\n    predicate.handleElement = drag._getStartPredicateHandle(event);\n    if (!predicate.handleElement) return false;\n  } // If delay is defined let's keep track of the latest event and initiate\n  // delay if it has not been done yet.\n\n\n  if (predicate.delay) {\n    predicate.event = event;\n\n    if (!predicate.delayTimer) {\n      predicate.delayTimer = window.setTimeout(function () {\n        predicate.delay = 0;\n\n        if (drag._resolveStartPredicate(predicate.event)) {\n          drag._forceResolveStartPredicate(predicate.event);\n\n          drag._resetStartPredicate();\n        }\n      }, predicate.delay);\n    }\n  }\n\n  return drag._resolveStartPredicate(event);\n};\n/**\r\n * Default drag sort predicate.\r\n *\r\n * @public\r\n * @memberof ItemDrag\r\n * @param {Item} item\r\n * @param {Object} [options]\r\n * @param {Number} [options.threshold=50]\r\n * @param {String} [options.action='move']\r\n * @returns {(Boolean|DragSortCommand)}\r\n *   - Returns false if no valid index was found. Otherwise returns drag sort\r\n *     command.\r\n */\n\n\nItemDrag.defaultSortPredicate = function () {\n  var itemRect = {};\n  var targetRect = {};\n  var returnData = {};\n  var rootGridArray = [];\n\n  function getTargetGrid(item, rootGrid, threshold) {\n    var target = null;\n    var dragSort = rootGrid._settings.dragSort;\n    var bestScore = -1;\n    var gridScore = void 0;\n    var grids = void 0;\n    var grid = void 0;\n    var i = void 0; // Get potential target grids.\n\n    if (dragSort === true) {\n      rootGridArray[0] = rootGrid;\n      grids = rootGridArray;\n    } else {\n      grids = dragSort.call(rootGrid, item);\n    } // Return immediately if there are no grids.\n\n\n    if (!Array.isArray(grids)) return target; // Loop through the grids and get the best match.\n\n    for (i = 0; i < grids.length; i++) {\n      grid = grids[i]; // Filter out all destroyed grids.\n\n      if (grid._isDestroyed) continue; // We need to update the grid's offsets and dimensions since they might\n      // have changed (e.g during scrolling).\n\n      grid._updateBoundingRect(); // Check how much dragged element overlaps the container element.\n\n\n      targetRect.width = grid._width;\n      targetRect.height = grid._height;\n      targetRect.left = grid._left;\n      targetRect.top = grid._top;\n      gridScore = getRectOverlapScore(itemRect, targetRect); // Check if this grid is the best match so far.\n\n      if (gridScore > threshold && gridScore > bestScore) {\n        bestScore = gridScore;\n        target = grid;\n      }\n    } // Always reset root grid array.\n\n\n    rootGridArray.length = 0;\n    return target;\n  }\n\n  return function (item, options) {\n    var drag = item._drag;\n\n    var rootGrid = drag._getGrid(); // Get drag sort predicate settings.\n\n\n    var sortThreshold = options && typeof options.threshold === 'number' ? options.threshold : 50;\n    var sortAction = options && options.action === 'swap' ? 'swap' : 'move'; // Populate item rect data.\n\n    itemRect.width = item._width;\n    itemRect.height = item._height;\n    itemRect.left = drag._elementClientX;\n    itemRect.top = drag._elementClientY; // Calculate the target grid.\n\n    var grid = getTargetGrid(item, rootGrid, sortThreshold); // Return early if we found no grid container element that overlaps the\n    // dragged item enough.\n\n    if (!grid) return false;\n    var gridOffsetLeft = 0;\n    var gridOffsetTop = 0;\n    var matchScore = -1;\n    var matchIndex = void 0;\n    var hasValidTargets = void 0;\n    var target = void 0;\n    var score = void 0;\n    var i = void 0; // If item is moved within it's originating grid adjust item's left and\n    // top props. Otherwise if item is moved to/within another grid get the\n    // container element's offset (from the element's content edge).\n\n    if (grid === rootGrid) {\n      itemRect.left = drag._gridX + item._marginLeft;\n      itemRect.top = drag._gridY + item._marginTop;\n    } else {\n      grid._updateBorders(1, 0, 1, 0);\n\n      gridOffsetLeft = grid._left + grid._borderLeft;\n      gridOffsetTop = grid._top + grid._borderTop;\n    } // Loop through the target grid items and try to find the best match.\n\n\n    for (i = 0; i < grid._items.length; i++) {\n      target = grid._items[i]; // If the target item is not active or the target item is the dragged\n      // item let's skip to the next item.\n\n      if (!target._isActive || target === item) {\n        continue;\n      } // Mark the grid as having valid target items.\n\n\n      hasValidTargets = true; // Calculate the target's overlap score with the dragged item.\n\n      targetRect.width = target._width;\n      targetRect.height = target._height;\n      targetRect.left = target._left + target._marginLeft + gridOffsetLeft;\n      targetRect.top = target._top + target._marginTop + gridOffsetTop;\n      score = getRectOverlapScore(itemRect, targetRect); // Update best match index and score if the target's overlap score with\n      // the dragged item is higher than the current best match score.\n\n      if (score > matchScore) {\n        matchIndex = i;\n        matchScore = score;\n      }\n    } // If there is no valid match and the item is being moved into another\n    // grid.\n\n\n    if (matchScore < sortThreshold && item.getGrid() !== grid) {\n      matchIndex = hasValidTargets ? -1 : 0;\n      matchScore = Infinity;\n    } // Check if the best match overlaps enough to justify a placement switch.\n\n\n    if (matchScore >= sortThreshold) {\n      returnData.grid = grid;\n      returnData.index = matchIndex;\n      returnData.action = sortAction;\n      return returnData;\n    }\n\n    return false;\n  };\n}();\n/**\r\n * Private helpers\r\n * ***************\r\n */\n\n/**\r\n * Prevent default.\r\n *\r\n * @param {Object} e\r\n */\n\n\nfunction preventDefault(e) {\n  if (e.preventDefault) e.preventDefault();\n}\n/**\r\n * Calculate how many percent the intersection area of two rectangles is from\r\n * the maximum potential intersection area between the rectangles.\r\n *\r\n * @param {Rectangle} a\r\n * @param {Rectangle} b\r\n * @returns {Number}\r\n *   - A number between 0-100.\r\n */\n\n\nfunction getRectOverlapScore(a, b) {\n  // Return 0 immediately if the rectangles do not overlap.\n  if (a.left + a.width <= b.left || b.left + b.width <= a.left || a.top + a.height <= b.top || b.top + b.height <= a.top) {\n    return 0;\n  } // Calculate intersection area's width, height, max height and max width.\n\n\n  var width = Math.min(a.left + a.width, b.left + b.width) - Math.max(a.left, b.left);\n  var height = Math.min(a.top + a.height, b.top + b.height) - Math.max(a.top, b.top);\n  var maxWidth = Math.min(a.width, b.width);\n  var maxHeight = Math.min(a.height, b.height);\n  return width * height / (maxWidth * maxHeight) * 100;\n}\n/**\r\n * Get element's scroll parents.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {Array} [data]\r\n * @returns {HTMLElement[]}\r\n */\n\n\nfunction getScrollParents(element, data) {\n  var ret = data || [];\n  var parent = element.parentNode; //\n  // If transformed elements leak fixed elements.\n  //\n\n  if (hasTransformLeak) {\n    // If the element is fixed it can not have any scroll parents.\n    if (getStyle(element, 'position') === 'fixed') return ret; // Find scroll parents.\n\n    while (parent && parent !== document && parent !== document.documentElement) {\n      if (isScrollable(parent)) ret.push(parent);\n      parent = getStyle(parent, 'position') === 'fixed' ? null : parent.parentNode;\n    } // If parent is not fixed element, add window object as the last scroll\n    // parent.\n\n\n    parent !== null && ret.push(window);\n    return ret;\n  } //\n  // If fixed elements behave as defined in the W3C specification.\n  //\n  // Find scroll parents.\n\n\n  while (parent && parent !== document) {\n    // If the currently looped element is fixed ignore all parents that are\n    // not transformed.\n    if (getStyle(element, 'position') === 'fixed' && !isTransformed(parent)) {\n      parent = parent.parentNode;\n      continue;\n    } // Add the parent element to return items if it is scrollable.\n\n\n    if (isScrollable(parent)) ret.push(parent); // Update element and parent references.\n\n    element = parent;\n    parent = parent.parentNode;\n  } // If the last item is the root element, replace it with window. The root\n  // element scroll is propagated to the window.\n\n\n  if (ret[ret.length - 1] === document.documentElement) {\n    ret[ret.length - 1] = window;\n  } // Otherwise add window as the last scroll parent.\n  else {\n      ret.push(window);\n    }\n\n  return ret;\n}\n/**\r\n * Check if an element is scrollable.\r\n *\r\n * @param {HTMLElement} element\r\n * @returns {Boolean}\r\n */\n\n\nfunction isScrollable(element) {\n  var overflow = getStyle(element, 'overflow');\n  if (overflow === 'auto' || overflow === 'scroll') return true;\n  overflow = getStyle(element, 'overflow-x');\n  if (overflow === 'auto' || overflow === 'scroll') return true;\n  overflow = getStyle(element, 'overflow-y');\n  if (overflow === 'auto' || overflow === 'scroll') return true;\n  return false;\n}\n/**\r\n * Check if drag gesture can be interpreted as a click, based on final drag\r\n * event data.\r\n *\r\n * @param {Object} element\r\n * @returns {Boolean}\r\n */\n\n\nfunction isClick(event) {\n  return Math.abs(event.deltaX) < 2 && Math.abs(event.deltaY) < 2 && event.deltaTime < 200;\n}\n/**\r\n * Check if an element is an anchor element and open the href url if possible.\r\n *\r\n * @param {HTMLElement} element\r\n */\n\n\nfunction openAnchorHref(element) {\n  // Make sure the element is anchor element.\n  if (element.tagName.toLowerCase() !== 'a') return; // Get href and make sure it exists.\n\n  var href = element.getAttribute('href');\n  if (!href) return; // Finally let's navigate to the link href.\n\n  var target = element.getAttribute('target');\n\n  if (target && target !== '_self') {\n    window.open(href, target);\n  } else {\n    window.location.href = href;\n  }\n}\n/**\r\n * Detects if transformed elements leak fixed elements. According W3C\r\n * transform rendering spec a transformed element should contain even fixed\r\n * elements. Meaning that fixed elements are positioned relative to the\r\n * closest transformed ancestor element instead of window. However, not every\r\n * browser follows the spec (IE and older Firefox). So we need to test it.\r\n * https://www.w3.org/TR/css3-2d-transforms/#transform-rendering\r\n *\r\n * Borrowed from Mezr (v0.6.1):\r\n * https://github.com/niklasramo/mezr/blob/0.6.1/mezr.js#L607\r\n */\n\n\nfunction checkTransformLeak() {\n  // No transforms -> definitely leaks.\n  if (!isTransformSupported) return true; // No body available -> can't check it.\n\n  if (!document.body) return null; // Do the test.\n\n  var elems = [0, 1].map(function (elem, isInner) {\n    elem = document.createElement('div');\n    elem.style.position = isInner ? 'fixed' : 'absolute';\n    elem.style.display = 'block';\n    elem.style.visibility = 'hidden';\n    elem.style.left = isInner ? '0px' : '1px';\n    elem.style[transformProp] = 'none';\n    return elem;\n  });\n  var outer = document.body.appendChild(elems[0]);\n  var inner = outer.appendChild(elems[1]);\n  var left = inner.getBoundingClientRect().left;\n  outer.style[transformProp] = 'scale(1)';\n  var ret = left === inner.getBoundingClientRect().left;\n  document.body.removeChild(outer);\n  return ret;\n}\n/**\r\n * Muuri Queue\r\n * Copyright (c) 2018-present, Niklas Rämö <inramo@gmail.com>\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/src/Queue/LICENSE.md\r\n */\n\n/**\r\n * Queue constructor.\r\n *\r\n * @class\r\n */\n\n\nvar Queue = function (_Component) {\n  inherits(Queue, _Component);\n\n  function Queue() {\n    classCallCheck(this, Queue);\n\n    var _this = possibleConstructorReturn(this, (Queue.__proto__ || Object.getPrototypeOf(Queue)).call(this));\n\n    _this._queue = [];\n    _this._isDestroyed = false;\n    return _this;\n  }\n\n  createClass(Queue, [{\n    key: 'add',\n\n    /**\r\n    * Public prototype methods\r\n    * ************************\r\n    */\n\n    /**\r\n    * Add callback to the queue.\r\n    *\r\n    * @public\r\n    * @memberof Queue.prototype\r\n    * @param {Function} callback\r\n    * @returns {Queue}\r\n    */\n    value: function add(callback) {\n      if (this._isDestroyed) return this;\n\n      this._queue.push(callback);\n\n      return this;\n    }\n  }, {\n    key: 'flush',\n\n    /**\r\n    * Process queue callbacks and reset the queue.\r\n    *\r\n    * @public\r\n    * @memberof Queue.prototype\r\n    * @param {*} arg1\r\n    * @param {*} arg2\r\n    * @returns {Queue}\r\n    */\n    value: function flush(arg1, arg2) {\n      if (this._isDestroyed) return this;\n      var queue = this._queue;\n      var length = queue.length;\n      var i = void 0; // Quit early if the queue is empty.\n\n      if (!length) return this;\n      var singleCallback = length === 1;\n      var snapshot = singleCallback ? queue[0] : queue.slice(0); // Reset queue.\n\n      queue.length = 0; // If we only have a single callback let's just call it.\n\n      if (singleCallback) {\n        snapshot(arg1, arg2);\n        return this;\n      } // If we have multiple callbacks, let's process them.\n\n\n      for (i = 0; i < length; i++) {\n        snapshot[i](arg1, arg2);\n        if (this._isDestroyed) break;\n      }\n\n      return this;\n    }\n    /**\r\n    * Destroy Queue instance.\r\n    *\r\n    * @public\r\n    * @memberof Queue.prototype\r\n    * @returns {Queue}\r\n    */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      if (this._isDestroyed) return this;\n      this._isDestroyed = true;\n      this._queue.length = 0;\n      return this;\n    }\n  }]);\n  return Queue;\n}(Component);\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\n/**\r\n * Layout manager for Item instance.\r\n *\r\n * @class\r\n * @param {Item} item\r\n */\n\n\nvar ItemLayout = function (_Component) {\n  inherits(ItemLayout, _Component);\n\n  function ItemLayout(item) {\n    classCallCheck(this, ItemLayout);\n\n    var _this = possibleConstructorReturn(this, (ItemLayout.__proto__ || Object.getPrototypeOf(ItemLayout)).call(this, item));\n\n    _this._item = item;\n    _this._isActive = false;\n    _this._isDestroyed = false;\n    _this._isInterrupted = false;\n    _this._currentStyles = {};\n    _this._targetStyles = {};\n    _this._currentLeft = 0;\n    _this._currentTop = 0;\n    _this._offsetLeft = 0;\n    _this._offsetTop = 0;\n    _this._skipNextAnimation = false;\n    _this._animateOptions = {\n      onFinish: _this._finish.bind(_this)\n    };\n    _this._queue = new Queue(); // Bind animation handlers and finish method.\n\n    _this._setupAnimation = _this._setupAnimation.bind(_this);\n    _this._startAnimation = _this._startAnimation.bind(_this);\n    return _this;\n  }\n  /**\r\n   * Public prototype methods\r\n   * ************************\r\n   */\n\n  /**\r\n   * Start item layout based on it's current data.\r\n   *\r\n   * @public\r\n   * @memberof ItemLayout.prototype\r\n   * @param {Boolean} [instant=false]\r\n   * @param {Function} [onFinish]\r\n   * @returns {ItemLayout}\r\n   */\n\n\n  createClass(ItemLayout, [{\n    key: 'start',\n    value: function start(instant, onFinish) {\n      if (this._isDestroyed) return;\n      var item = this._item;\n      var element = item._element;\n      var release = item._release;\n\n      var gridSettings = item.getGrid()._settings;\n\n      var isPositioning = this._isActive;\n      var isJustReleased = release._isActive && release._isPositioningStarted === false;\n      var animDuration = isJustReleased ? gridSettings.dragReleaseDuration : gridSettings.layoutDuration;\n      var animEasing = isJustReleased ? gridSettings.dragReleaseEasing : gridSettings.layoutEasing;\n      var animEnabled = !instant && !this._skipNextAnimation && animDuration > 0;\n      var isAnimating = void 0; // If the item is currently positioning process current layout callback\n      // queue with interrupted flag on.\n\n      if (isPositioning) this._queue.flush(true, item); // Mark release positioning as started.\n\n      if (isJustReleased) release._isPositioningStarted = true; // Push the callback to the callback queue.\n\n      if (typeof onFinish === 'function') this._queue.add(onFinish); // If no animations are needed, easy peasy!\n\n      if (!animEnabled) {\n        this._updateOffsets();\n\n        this._updateTargetStyles();\n\n        isPositioning && cancelLayoutTick(item._id);\n        isAnimating = item._animate.isAnimating();\n        this.stop(false, this._targetStyles);\n        !isAnimating && setStyles(element, this._targetStyles);\n        this._skipNextAnimation = false;\n        return this._finish();\n      } // Set item active and store some data for the animation that is about to be\n      // triggered.\n\n\n      this._isActive = true;\n      this._animateOptions.easing = animEasing;\n      this._animateOptions.duration = animDuration;\n      this._isInterrupted = isPositioning; // Start the item's layout animation in the next tick.\n\n      addLayoutTick(item._id, this._setupAnimation, this._startAnimation);\n      return this;\n    }\n    /**\r\n     * Stop item's position animation if it is currently animating.\r\n     *\r\n     * @public\r\n     * @memberof ItemLayout.prototype\r\n     * @param {Boolean} [processCallbackQueue=false]\r\n     * @param {Object} [targetStyles]\r\n     * @returns {ItemLayout}\r\n     */\n\n  }, {\n    key: 'stop',\n    value: function stop(processCallbackQueue, targetStyles) {\n      if (this._isDestroyed || !this._isActive) return this;\n      var item = this._item; // Cancel animation init.\n\n      cancelLayoutTick(item._id); // Stop animation.\n\n      item._animate.stop(targetStyles); // Remove positioning class.\n\n\n      removeClass(item._element, item.getGrid()._settings.itemPositioningClass); // Reset active state.\n\n      this._isActive = false; // Process callback queue if needed.\n\n      if (processCallbackQueue) this._queue.flush(true, item);\n      return this;\n    }\n    /**\r\n     * Destroy the instance and stop current animation if it is running.\r\n     *\r\n     * @public\r\n     * @memberof ItemLayout.prototype\r\n     * @returns {ItemLayout}\r\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      if (this._isDestroyed) return this;\n      this.stop(true, {});\n\n      this._queue.destroy();\n\n      this._item = this._currentStyles = this._targetStyles = this._animateOptions = null;\n      this._isDestroyed = true;\n      return this;\n    }\n    /**\r\n     * Private prototype methods\r\n     * *************************\r\n     */\n\n    /**\r\n     * Calculate and update item's current layout offset data.\r\n     *\r\n     * @private\r\n     * @memberof ItemLayout.prototype\r\n     */\n\n  }, {\n    key: '_updateOffsets',\n    value: function _updateOffsets() {\n      if (this._isDestroyed) return;\n      var item = this._item;\n      var migrate = item._migrate;\n      var release = item._release;\n      this._offsetLeft = release._isActive ? release._containerDiffX : migrate._isActive ? migrate._containerDiffX : 0;\n      this._offsetTop = release._isActive ? release._containerDiffY : migrate._isActive ? migrate._containerDiffY : 0;\n    }\n    /**\r\n     * Calculate and update item's layout target styles.\r\n     *\r\n     * @private\r\n     * @memberof ItemLayout.prototype\r\n     */\n\n  }, {\n    key: '_updateTargetStyles',\n    value: function _updateTargetStyles() {\n      if (this._isDestroyed) return;\n      var item = this._item;\n      this._targetStyles.transform = getTranslateString(item._left + this._offsetLeft, item._top + this._offsetTop);\n    }\n    /**\r\n     * Finish item layout procedure.\r\n     *\r\n     * @private\r\n     * @memberof ItemLayout.prototype\r\n     */\n\n  }, {\n    key: '_finish',\n    value: function _finish() {\n      if (this._isDestroyed) return;\n      var item = this._item;\n      var migrate = item._migrate;\n      var release = item._release; // Mark the item as inactive and remove positioning classes.\n\n      if (this._isActive) {\n        this._isActive = false;\n        removeClass(item._element, item.getGrid()._settings.itemPositioningClass);\n      } // Finish up release and migration.\n\n\n      if (release._isActive) release.stop();\n      if (migrate._isActive) migrate.stop(); // Process the callback queue.\n\n      this._queue.flush(false, item);\n    }\n    /**\r\n     * Prepare item for layout animation.\r\n     *\r\n     * @private\r\n     * @memberof ItemLayout.prototype\r\n     */\n\n  }, {\n    key: '_setupAnimation',\n    value: function _setupAnimation() {\n      var element = this._item._element;\n      var translate = getTranslate(element);\n      this._currentLeft = translate.x;\n      this._currentTop = translate.y;\n    }\n    /**\r\n     * Start layout animation.\r\n     *\r\n     * @private\r\n     * @memberof ItemLayout.prototype\r\n     */\n\n  }, {\n    key: '_startAnimation',\n    value: function _startAnimation() {\n      var item = this._item;\n      var element = item._element;\n      var grid = item.getGrid();\n      var settings = grid._settings; // Let's update the offset data and target styles.\n\n      this._updateOffsets();\n\n      this._updateTargetStyles(); // If the item is already in correct position let's quit early.\n\n\n      if (item._left === this._currentLeft - this._offsetLeft && item._top === this._currentTop - this._offsetTop) {\n        if (this._isInterrupted) this.stop(false, this._targetStyles);\n        this._isActive = false;\n\n        this._finish();\n\n        return;\n      } // Set item's positioning class if needed.\n\n\n      !this._isInterrupted && addClass(element, settings.itemPositioningClass); // Get current styles for animation.\n\n      this._currentStyles.transform = getTranslateString(this._currentLeft, this._currentTop); // Animate.\n\n      item._animate.start(this._currentStyles, this._targetStyles, this._animateOptions);\n    }\n  }]);\n  return ItemLayout;\n}(Component);\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\n\nvar tempStyles = {};\n/**\r\n * The migrate process handler constructor.\r\n *\r\n * @class\r\n * @param {Item} item\r\n */\n\nvar ItemMigrate = function (_Component) {\n  inherits(ItemMigrate, _Component);\n\n  function ItemMigrate(item) {\n    classCallCheck(this, ItemMigrate); // Private props.\n\n    var _this = possibleConstructorReturn(this, (ItemMigrate.__proto__ || Object.getPrototypeOf(ItemMigrate)).call(this, item));\n\n    _this._item = item;\n    _this._isActive = false;\n    _this._isDestroyed = false;\n    _this._container = false;\n    _this._containerDiffX = 0;\n    _this._containerDiffY = 0;\n    return _this;\n  }\n  /**\r\n   * Public prototype methods\r\n   * ************************\r\n   */\n\n  /**\r\n   * Start the migrate process of an item.\r\n   *\r\n   * @public\r\n   * @memberof ItemMigrate.prototype\r\n   * @param {Grid} targetGrid\r\n   * @param {GridSingleItemQuery} position\r\n   * @param {HTMLElement} [container]\r\n   * @returns {ItemMigrate}\r\n   */\n\n\n  createClass(ItemMigrate, [{\n    key: 'start',\n    value: function start(targetGrid, position, container) {\n      if (this._isDestroyed) return this;\n      var item = this._item;\n      var element = item._element;\n      var isVisible = item.isVisible();\n      var grid = item.getGrid();\n      var settings = grid._settings;\n      var targetSettings = targetGrid._settings;\n      var targetElement = targetGrid._element;\n      var targetItems = targetGrid._items;\n\n      var currentIndex = grid._items.indexOf(item);\n\n      var targetContainer = container || document.body;\n      var targetIndex = void 0;\n      var targetItem = void 0;\n      var currentContainer = void 0;\n      var offsetDiff = void 0;\n      var containerDiff = void 0;\n      var translate = void 0;\n      var translateX = void 0;\n      var translateY = void 0; // Get target index.\n\n      if (typeof position === 'number') {\n        targetIndex = normalizeArrayIndex(targetItems, position, true);\n      } else {\n        targetItem = targetGrid._getItem(position);\n        /** @todo Consider throwing an error here instead of silently failing. */\n\n        if (!targetItem) return this;\n        targetIndex = targetItems.indexOf(targetItem);\n      } // Get current translateX and translateY values if needed.\n\n\n      if (item.isPositioning() || this._isActive || item.isReleasing()) {\n        translate = getTranslate(element);\n        translateX = translate.x;\n        translateY = translate.y;\n      } // Abort current positioning.\n\n\n      if (item.isPositioning()) {\n        item._layout.stop(true, {\n          transform: getTranslateString(translateX, translateY)\n        });\n      } // Abort current migration.\n\n\n      if (this._isActive) {\n        translateX -= this._containerDiffX;\n        translateY -= this._containerDiffY;\n        this.stop(true, {\n          transform: getTranslateString(translateX, translateY)\n        });\n      } // Abort current release.\n\n\n      if (item.isReleasing()) {\n        translateX -= item._release._containerDiffX;\n        translateY -= item._release._containerDiffY;\n\n        item._release.stop(true, {\n          transform: getTranslateString(translateX, translateY)\n        });\n      } // Stop current visibility animations.\n\n\n      item._visibility._stopAnimation(); // Destroy current drag.\n\n\n      if (item._drag) item._drag.destroy(); // Process current visibility animation queue.\n\n      item._visibility._queue.flush(true, item); // Emit beforeSend event.\n\n\n      if (grid._hasListeners(eventBeforeSend)) {\n        grid._emit(eventBeforeSend, {\n          item: item,\n          fromGrid: grid,\n          fromIndex: currentIndex,\n          toGrid: targetGrid,\n          toIndex: targetIndex\n        });\n      } // Emit beforeReceive event.\n\n\n      if (targetGrid._hasListeners(eventBeforeReceive)) {\n        targetGrid._emit(eventBeforeReceive, {\n          item: item,\n          fromGrid: grid,\n          fromIndex: currentIndex,\n          toGrid: targetGrid,\n          toIndex: targetIndex\n        });\n      } // Remove current classnames.\n\n\n      removeClass(element, settings.itemClass);\n      removeClass(element, settings.itemVisibleClass);\n      removeClass(element, settings.itemHiddenClass); // Add new classnames.\n\n      addClass(element, targetSettings.itemClass);\n      addClass(element, isVisible ? targetSettings.itemVisibleClass : targetSettings.itemHiddenClass); // Move item instance from current grid to target grid.\n\n      grid._items.splice(currentIndex, 1);\n\n      arrayInsert(targetItems, item, targetIndex); // Update item's grid id reference.\n\n      item._gridId = targetGrid._id; // Get current container.\n\n      currentContainer = element.parentNode; // Move the item inside the target container if it's different than the\n      // current container.\n\n      if (targetContainer !== currentContainer) {\n        targetContainer.appendChild(element);\n        offsetDiff = getOffsetDiff(targetContainer, currentContainer, true);\n\n        if (!translate) {\n          translate = getTranslate(element);\n          translateX = translate.x;\n          translateY = translate.y;\n        }\n\n        element.style[transformProp] = getTranslateString(translateX + offsetDiff.left, translateY + offsetDiff.top);\n      } // Update child element's styles to reflect the current visibility state.\n\n\n      item._child.removeAttribute('style');\n\n      setStyles(item._child, isVisible ? targetSettings.visibleStyles : targetSettings.hiddenStyles); // Update display style.\n\n      element.style.display = isVisible ? 'block' : 'hidden'; // Get offset diff for the migration data.\n\n      containerDiff = getOffsetDiff(targetContainer, targetElement, true); // Update item's cached dimensions and sort data.\n\n      item._refreshDimensions();\n\n      item._refreshSortData(); // Create new drag handler.\n\n\n      item._drag = targetSettings.dragEnabled ? new ItemDrag(item) : null; // Setup migration data.\n\n      this._isActive = true;\n      this._container = targetContainer;\n      this._containerDiffX = containerDiff.left;\n      this._containerDiffY = containerDiff.top; // Emit send event.\n\n      if (grid._hasListeners(eventSend)) {\n        grid._emit(eventSend, {\n          item: item,\n          fromGrid: grid,\n          fromIndex: currentIndex,\n          toGrid: targetGrid,\n          toIndex: targetIndex\n        });\n      } // Emit receive event.\n\n\n      if (targetGrid._hasListeners(eventReceive)) {\n        targetGrid._emit(eventReceive, {\n          item: item,\n          fromGrid: grid,\n          fromIndex: currentIndex,\n          toGrid: targetGrid,\n          toIndex: targetIndex\n        });\n      }\n\n      return this;\n    }\n    /**\r\n     * End the migrate process of an item. This method can be used to abort an\r\n     * ongoing migrate process (animation) or finish the migrate process.\r\n     *\r\n     * @public\r\n     * @memberof ItemMigrate.prototype\r\n     * @param {Boolean} [abort=false]\r\n     *  - Should the migration be aborted?\r\n     * @param {Object} [currentStyles]\r\n     *  - Optional current translateX and translateY styles.\r\n     * @returns {ItemMigrate}\r\n     */\n\n  }, {\n    key: 'stop',\n    value: function stop(abort, currentStyles) {\n      if (this._isDestroyed || !this._isActive) return this;\n      var item = this._item;\n      var element = item._element;\n      var grid = item.getGrid();\n      var gridElement = grid._element;\n      var translate = void 0;\n\n      if (this._container !== gridElement) {\n        if (!currentStyles) {\n          if (abort) {\n            translate = getTranslate(element);\n            tempStyles.transform = getTranslateString(translate.x - this._containerDiffX, translate.y - this._containerDiffY);\n          } else {\n            tempStyles.transform = getTranslateString(item._left, item._top);\n          }\n\n          currentStyles = tempStyles;\n        }\n\n        gridElement.appendChild(element);\n        setStyles(element, currentStyles);\n      }\n\n      this._isActive = false;\n      this._container = null;\n      this._containerDiffX = 0;\n      this._containerDiffY = 0;\n      return this;\n    }\n    /**\r\n     * Destroy instance.\r\n     *\r\n     * @public\r\n     * @memberof ItemMigrate.prototype\r\n     * @returns {ItemMigrate}\r\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      if (this._isDestroyed) return this;\n      this.stop(true);\n      this._item = null;\n      this._isDestroyed = true;\n      return this;\n    }\n  }]);\n  return ItemMigrate;\n}(Component);\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\n\nvar tempStyles$1 = {};\n/**\r\n * The release process handler constructor. Although this might seem as proper\r\n * fit for the drag process this needs to be separated into it's own logic\r\n * because there might be a scenario where drag is disabled, but the release\r\n * process still needs to be implemented (dragging from a grid to another).\r\n *\r\n * @class\r\n * @param {Item} item\r\n */\n\nvar ItemRelease = function (_Component) {\n  inherits(ItemRelease, _Component);\n\n  function ItemRelease(item) {\n    classCallCheck(this, ItemRelease);\n\n    var _this = possibleConstructorReturn(this, (ItemRelease.__proto__ || Object.getPrototypeOf(ItemRelease)).call(this, item));\n\n    _this._item = item;\n    _this._isActive = false;\n    _this._isDestroyed = false;\n    _this._isPositioningStarted = false;\n    _this._containerDiffX = 0;\n    _this._containerDiffY = 0;\n    return _this;\n  }\n  /**\r\n   * Public prototype methods\r\n   * ************************\r\n   */\n\n  /**\r\n   * Start the release process of an item.\r\n   *\r\n   * @public\r\n   * @memberof ItemRelease.prototype\r\n   * @returns {ItemRelease}\r\n   */\n\n\n  createClass(ItemRelease, [{\n    key: 'start',\n    value: function start() {\n      if (this._isDestroyed || this._isActive) return this;\n      var item = this._item;\n      var grid = item.getGrid(); // Flag release as active.\n\n      this._isActive = true; // Add release class name to the released element.\n\n      addClass(item._element, grid._settings.itemReleasingClass); // Emit dragReleaseStart event.\n\n      grid._emit(eventDragReleaseStart, item); // Position the released item.\n\n\n      item._layout.start(false);\n\n      return this;\n    }\n    /**\r\n     * End the release process of an item. This method can be used to abort an\r\n     * ongoing release process (animation) or finish the release process.\r\n     *\r\n     * @public\r\n     * @memberof ItemRelease.prototype\r\n     * @param {Boolean} [abort=false]\r\n     *  - Should the release be aborted? When true, the release end event won't be\r\n     *    emitted. Set to true only when you need to abort the release process\r\n     *    while the item is animating to it's position.\r\n     * @param {Object} [currentStyles]\r\n     *  - Optional current translateX and translateY styles.\r\n     * @returns {ItemRelease}\r\n     */\n\n  }, {\n    key: 'stop',\n    value: function stop(abort, currentStyles) {\n      if (this._isDestroyed || !this._isActive) return this;\n      var item = this._item;\n      var element = item._element;\n      var grid = item.getGrid();\n      var container = grid._element;\n      var translate = void 0; // Reset data and remove releasing class name from the element.\n\n      this._reset(); // If the released element is outside the grid's container element put it\n      // back there and adjust position accordingly.\n\n\n      if (element.parentNode !== container) {\n        if (!currentStyles) {\n          if (abort) {\n            translate = getTranslate(element);\n            tempStyles$1.transform = getTranslateString(translate.x - this._containerDiffX, translate.y - this._containerDiffY);\n          } else {\n            tempStyles$1.transform = getTranslateString(item._left, item._top);\n          }\n\n          currentStyles = tempStyles$1;\n        }\n\n        container.appendChild(element);\n        setStyles(element, currentStyles);\n      } // Emit dragReleaseEnd event.\n\n\n      if (!abort) grid._emit(eventDragReleaseEnd, item);\n      return this;\n    }\n    /**\r\n     * Destroy instance.\r\n     *\r\n     * @public\r\n     * @memberof ItemRelease.prototype\r\n     * @returns {ItemRelease}\r\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      if (this._isDestroyed) return this;\n      this.stop(true);\n      this._item = null;\n      this._isDestroyed = true;\n      return this;\n    }\n    /**\r\n     * Private prototype methods\r\n     * *************************\r\n     */\n\n    /**\r\n     * Reset public data and remove releasing class.\r\n     *\r\n     * @private\r\n     * @memberof ItemRelease.prototype\r\n     */\n\n  }, {\n    key: '_reset',\n    value: function _reset() {\n      if (this._isDestroyed) return;\n      var item = this._item;\n      this._isActive = false;\n      this._isPositioningStarted = false;\n      this._containerDiffX = 0;\n      this._containerDiffY = 0;\n      removeClass(item._element, item.getGrid()._settings.itemReleasingClass);\n    }\n  }]);\n  return ItemRelease;\n}(Component);\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\n/**\r\n * Get current values of the provided styles definition object.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {Object} styles\r\n * @return {Object}\r\n */\n\n\nfunction getCurrentStyles(element, styles) {\n  var current = {};\n\n  for (var prop in styles) {\n    current[prop] = getStyle(element, getStyleName(prop));\n  }\n\n  return current;\n}\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\n/**\r\n * Visibility manager for Item instance.\r\n *\r\n * @class\r\n * @param {Item} item\r\n */\n\n\nvar ItemVisibility = function (_Component) {\n  inherits(ItemVisibility, _Component);\n\n  function ItemVisibility(item) {\n    classCallCheck(this, ItemVisibility);\n\n    var _this = possibleConstructorReturn(this, (ItemVisibility.__proto__ || Object.getPrototypeOf(ItemVisibility)).call(this, item));\n\n    var isActive = item._isActive;\n    var element = item._element;\n\n    var settings = item.getGrid()._settings;\n\n    _this._item = item;\n    _this._isDestroyed = false; // Set up visibility states.\n\n    _this._isHidden = !isActive;\n    _this._isHiding = false;\n    _this._isShowing = false; // Callback queue.\n\n    _this._queue = new Queue(); // Bind show/hide finishers.\n\n    _this._finishShow = _this._finishShow.bind(_this);\n    _this._finishHide = _this._finishHide.bind(_this); // Force item to be either visible or hidden on init.\n\n    element.style.display = isActive ? 'block' : 'none'; // Set visible/hidden class.\n\n    addClass(element, isActive ? settings.itemVisibleClass : settings.itemHiddenClass); // Set initial styles for the child element.\n\n    setStyles(item._child, isActive ? settings.visibleStyles : settings.hiddenStyles);\n    return _this;\n  }\n  /**\r\n   * Public prototype methods\r\n   * ************************\r\n   */\n\n  /**\r\n   * Show item.\r\n   *\r\n   * @public\r\n   * @memberof ItemVisibility.prototype\r\n   * @param {Boolean} instant\r\n   * @param {Function} [onFinish]\r\n   * @returns {ItemVisibility}\r\n   */\n\n\n  createClass(ItemVisibility, [{\n    key: 'show',\n    value: function show(instant, onFinish) {\n      if (this._isDestroyed) return this;\n      var item = this._item;\n      var element = item._element;\n      var queue = this._queue;\n      var callback = typeof onFinish === 'function' ? onFinish : null;\n      var grid = item.getGrid();\n      var settings = grid._settings; // If item is visible call the callback and be done with it.\n\n      if (!this._isShowing && !this._isHidden) {\n        callback && callback(false, item);\n        return this;\n      } // If item is showing and does not need to be shown instantly, let's just\n      // push callback to the callback queue and be done with it.\n\n\n      if (this._isShowing && !instant) {\n        callback && queue.add(callback);\n        return this;\n      } // If the item is hiding or hidden process the current visibility callback\n      // queue with the interrupted flag active, update classes and set display\n      // to block if necessary.\n\n\n      if (!this._isShowing) {\n        queue.flush(true, item);\n        removeClass(element, settings.itemHiddenClass);\n        addClass(element, settings.itemVisibleClass);\n        if (!this._isHiding) element.style.display = 'block';\n      } // Push callback to the callback queue.\n\n\n      callback && queue.add(callback); // Update visibility states.\n\n      item._isActive = this._isShowing = true;\n      this._isHiding = this._isHidden = false; // Finally let's start show animation.\n\n      this._startAnimation(true, instant, this._finishShow);\n\n      return this;\n    }\n    /**\r\n     * Hide item.\r\n     *\r\n     * @public\r\n     * @memberof ItemVisibility.prototype\r\n     * @param {Boolean} instant\r\n     * @param {Function} [onFinish]\r\n     * @returns {ItemVisibility}\r\n     */\n\n  }, {\n    key: 'hide',\n    value: function hide(instant, onFinish) {\n      if (this._isDestroyed) return this;\n      var item = this._item;\n      var element = item._element;\n      var queue = this._queue;\n      var callback = typeof onFinish === 'function' ? onFinish : null;\n      var grid = item.getGrid();\n      var settings = grid._settings; // If item is already hidden call the callback and be done with it.\n\n      if (!this._isHiding && this._isHidden) {\n        callback && callback(false, item);\n        return this;\n      } // If item is hiding and does not need to be hidden instantly, let's just\n      // push callback to the callback queue and be done with it.\n\n\n      if (this._isHiding && !instant) {\n        callback && queue.add(callback);\n        return this;\n      } // If the item is showing or visible process the current visibility callback\n      // queue with the interrupted flag active, update classes and set display\n      // to block if necessary.\n\n\n      if (!this._isHiding) {\n        queue.flush(true, item);\n        addClass(element, settings.itemHiddenClass);\n        removeClass(element, settings.itemVisibleClass);\n      } // Push callback to the callback queue.\n\n\n      callback && queue.add(callback); // Update visibility states.\n\n      this._isHidden = this._isHiding = true;\n      item._isActive = this._isShowing = false; // Finally let's start hide animation.\n\n      this._startAnimation(false, instant, this._finishHide);\n\n      return this;\n    }\n    /**\r\n     * Destroy the instance and stop current animation if it is running.\r\n     *\r\n     * @public\r\n     * @memberof ItemVisibility.prototype\r\n     * @returns {ItemVisibility}\r\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      if (this._isDestroyed) return this;\n      var item = this._item;\n      var element = item._element;\n      var grid = item.getGrid();\n      var queue = this._queue;\n      var settings = grid._settings; // Stop visibility animation.\n\n      this._stopAnimation({}); // Fire all uncompleted callbacks with interrupted flag and destroy the queue.\n\n\n      queue.flush(true, item).destroy(); // Remove visible/hidden classes.\n\n      removeClass(element, settings.itemVisibleClass);\n      removeClass(element, settings.itemHiddenClass); // Reset state.\n\n      this._item = null;\n      this._isHiding = this._isShowing = false;\n      this._isDestroyed = this._isHidden = true;\n      return this;\n    }\n    /**\r\n     * Private prototype methods\r\n     * *************************\r\n     */\n\n    /**\r\n     * Start visibility animation.\r\n     *\r\n     * @private\r\n     * @memberof ItemVisibility.prototype\r\n     * @param {Boolean} toVisible\r\n     * @param {Boolean} [instant]\r\n     * @param {Function} [onFinish]\r\n     */\n\n  }, {\n    key: '_startAnimation',\n    value: function _startAnimation(toVisible, instant, onFinish) {\n      if (this._isDestroyed) return;\n      var item = this._item;\n\n      var settings = item.getGrid()._settings;\n\n      var targetStyles = toVisible ? settings.visibleStyles : settings.hiddenStyles;\n      var duration = parseInt(toVisible ? settings.showDuration : settings.hideDuration) || 0;\n      var easing = (toVisible ? settings.showEasing : settings.hideEasing) || 'ease';\n      var isInstant = instant || duration <= 0;\n      var currentStyles = void 0; // No target styles? Let's quit early.\n\n      if (!targetStyles) {\n        onFinish && onFinish();\n        return;\n      } // Cancel queued visibility tick.\n\n\n      cancelVisibilityTick(item._id); // If we need to apply the styles instantly without animation.\n\n      if (isInstant) {\n        if (item._animateChild.isAnimating()) {\n          item._animateChild.stop(targetStyles);\n        } else {\n          setStyles(item._child, targetStyles);\n        }\n\n        onFinish && onFinish();\n        return;\n      } // Start the animation in the next tick (to avoid layout thrashing).\n\n\n      addVisibilityTick(item._id, function () {\n        currentStyles = getCurrentStyles(item._child, targetStyles);\n      }, function () {\n        item._animateChild.start(currentStyles, targetStyles, {\n          duration: duration,\n          easing: easing,\n          onFinish: onFinish\n        });\n      });\n    }\n    /**\r\n     * Stop visibility animation.\r\n     *\r\n     * @private\r\n     * @memberof ItemVisibility.prototype\r\n     * @param {Object} [targetStyles]\r\n     */\n\n  }, {\n    key: '_stopAnimation',\n    value: function _stopAnimation(targetStyles) {\n      if (this._isDestroyed) return;\n      var item = this._item;\n      cancelVisibilityTick(item._id);\n\n      item._animateChild.stop(targetStyles);\n    }\n    /**\r\n     * Finish show procedure.\r\n     *\r\n     * @private\r\n     * @memberof ItemVisibility.prototype\r\n     */\n\n  }, {\n    key: '_finishShow',\n    value: function _finishShow() {\n      if (this._isHidden) return;\n      this._isShowing = false;\n\n      this._queue.flush(false, this._item);\n    }\n  }, {\n    key: '_finishHide',\n    value: function _finishHide() {\n      if (!this._isHidden) return;\n      var item = this._item;\n      this._isHiding = false;\n      finishStyles.transform = getTranslateString(0, 0);\n\n      item._layout.stop(true, finishStyles);\n\n      item._element.style.display = 'none';\n\n      this._queue.flush(false, item);\n    }\n  }]);\n  return ItemVisibility;\n}(Component);\n/**\r\n * Finish hide procedure.\r\n *\r\n * @private\r\n * @memberof ItemVisibility.prototype\r\n */\n\n\nvar finishStyles = {};\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\nvar id = 0;\n/**\r\n * Returns a unique numeric id (increments a base value on every call).\r\n * @returns {Number}\r\n */\n\nfunction createUid() {\n  return ++id;\n}\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\n/**\r\n * Creates a new Item instance for a Grid instance.\r\n *\r\n * @class\r\n * @param {Grid} grid\r\n * @param {HTMLElement} element\r\n * @param {Boolean} [isActive]\r\n */\n\n\nvar Item = function () {\n  function Item(grid, element, isActive) {\n    classCallCheck(this, Item);\n    var settings = grid._settings; // Create instance id.\n\n    this._id = createUid(); // Reference to connected Grid instance's id.\n\n    this._gridId = grid._id; // Destroyed flag.\n\n    this._isDestroyed = false; // Set up initial positions.\n\n    this._left = 0;\n    this._top = 0; // The elements.\n\n    this._element = element;\n    this._child = element.children[0]; // If the provided item element is not a direct child of the grid container\n    // element, append it to the grid container.\n\n    if (element.parentNode !== grid._element) {\n      grid._element.appendChild(element);\n    } // Set item class.\n\n\n    addClass(element, settings.itemClass); // If isActive is not defined, let's try to auto-detect it.\n\n    if (typeof isActive !== 'boolean') {\n      isActive = getStyle(element, 'display') !== 'none';\n    } // Set up active state (defines if the item is considered part of the layout\n    // or not).\n\n\n    this._isActive = isActive; // Set element's initial position styles.\n\n    element.style.left = '0';\n    element.style.top = '0';\n    element.style[transformProp] = getTranslateString(0, 0); // Initiate item's animation controllers.\n\n    this._animate = new ItemAnimate(element);\n    this._animateChild = new ItemAnimate(this._child); // Setup visibility handler.\n\n    this._visibility = new ItemVisibility(this); // Set up layout handler.\n\n    this._layout = new ItemLayout(this); // Set up migration handler data.\n\n    this._migrate = new ItemMigrate(this); // Set up release handler\n\n    this._release = new ItemRelease(this); // Set up drag handler.\n\n    this._drag = settings.dragEnabled ? new ItemDrag(this) : null; // Set up the initial dimensions and sort data.\n\n    this._refreshDimensions();\n\n    this._refreshSortData();\n  }\n  /**\r\n   * Public prototype methods\r\n   * ************************\r\n   */\n\n  /**\r\n   * Get the instance grid reference.\r\n   *\r\n   * @public\r\n   * @memberof Item.prototype\r\n   * @returns {Grid}\r\n   */\n\n\n  createClass(Item, [{\n    key: 'getGrid',\n    value: function getGrid() {\n      return gridInstances[this._gridId];\n    }\n    /**\r\n     * Get the instance element.\r\n     *\r\n     * @public\r\n     * @memberof Item.prototype\r\n     * @returns {HTMLElement}\r\n     */\n\n  }, {\n    key: 'getElement',\n    value: function getElement() {\n      return this._element;\n    }\n    /**\r\n     * Get instance element's cached width.\r\n     *\r\n     * @public\r\n     * @memberof Item.prototype\r\n     * @returns {Number}\r\n     */\n\n  }, {\n    key: 'getWidth',\n    value: function getWidth() {\n      return this._width;\n    }\n    /**\r\n     * Get instance element's cached height.\r\n     *\r\n     * @public\r\n     * @memberof Item.prototype\r\n     * @returns {Number}\r\n     */\n\n  }, {\n    key: 'getHeight',\n    value: function getHeight() {\n      return this._height;\n    }\n    /**\r\n     * Get instance element's cached margins.\r\n     *\r\n     * @public\r\n     * @memberof Item.prototype\r\n     * @returns {Object}\r\n     *   - The returned object contains left, right, top and bottom properties\r\n     *     which indicate the item element's cached margins.\r\n     */\n\n  }, {\n    key: 'getMargin',\n    value: function getMargin() {\n      return {\n        left: this._marginLeft,\n        right: this._marginRight,\n        top: this._marginTop,\n        bottom: this._marginBottom\n      };\n    }\n    /**\r\n     * Get instance element's cached position.\r\n     *\r\n     * @public\r\n     * @memberof Item.prototype\r\n     * @returns {Object}\r\n     *   - The returned object contains left and top properties which indicate the\r\n     *     item element's cached position in the grid.\r\n     */\n\n  }, {\n    key: 'getPosition',\n    value: function getPosition() {\n      return {\n        left: this._left,\n        top: this._top\n      };\n    }\n    /**\r\n     * Is the item active?\r\n     *\r\n     * @public\r\n     * @memberof Item.prototype\r\n     * @returns {Boolean}\r\n     */\n\n  }, {\n    key: 'isActive',\n    value: function isActive() {\n      return this._isActive;\n    }\n    /**\r\n     * Is the item visible?\r\n     *\r\n     * @public\r\n     * @memberof Item.prototype\r\n     * @returns {Boolean}\r\n     */\n\n  }, {\n    key: 'isVisible',\n    value: function isVisible() {\n      return !!this._visibility && !this._visibility._isHidden;\n    }\n    /**\r\n     * Is the item being animated to visible?\r\n     *\r\n     * @public\r\n     * @memberof Item.prototype\r\n     * @returns {Boolean}\r\n     */\n\n  }, {\n    key: 'isShowing',\n    value: function isShowing() {\n      return !!(this._visibility && this._visibility._isShowing);\n    }\n    /**\r\n     * Is the item being animated to hidden?\r\n     *\r\n     * @public\r\n     * @memberof Item.prototype\r\n     * @returns {Boolean}\r\n     */\n\n  }, {\n    key: 'isHiding',\n    value: function isHiding() {\n      return !!(this._visibility && this._visibility._isHiding);\n    }\n    /**\r\n     * Is the item positioning?\r\n     *\r\n     * @public\r\n     * @memberof Item.prototype\r\n     * @returns {Boolean}\r\n     */\n\n  }, {\n    key: 'isPositioning',\n    value: function isPositioning() {\n      return !!(this._layout && this._layout._isActive);\n    }\n    /**\r\n     * Is the item being dragged?\r\n     *\r\n     * @public\r\n     * @memberof Item.prototype\r\n     * @returns {Boolean}\r\n     */\n\n  }, {\n    key: 'isDragging',\n    value: function isDragging() {\n      return !!(this._drag && this._drag._isActive);\n    }\n    /**\r\n     * Is the item being released?\r\n     *\r\n     * @public\r\n     * @memberof Item.prototype\r\n     * @returns {Boolean}\r\n     */\n\n  }, {\n    key: 'isReleasing',\n    value: function isReleasing() {\n      return !!(this._release && this._release._isActive);\n    }\n    /**\r\n     * Is the item destroyed?\r\n     *\r\n     * @public\r\n     * @memberof Item.prototype\r\n     * @returns {Boolean}\r\n     */\n\n  }, {\n    key: 'isDestroyed',\n    value: function isDestroyed() {\n      return this._isDestroyed;\n    }\n    /**\r\n     * Private prototype methods\r\n     * *************************\r\n     */\n\n    /**\r\n     * Recalculate item's dimensions.\r\n     *\r\n     * @private\r\n     * @memberof Item.prototype\r\n     */\n\n  }, {\n    key: '_refreshDimensions',\n    value: function _refreshDimensions() {\n      if (this._isDestroyed || this._visibility._isHidden) return;\n      var element = this._element;\n      var rect = element.getBoundingClientRect(); // Calculate width and height.\n\n      this._width = rect.width;\n      this._height = rect.height; // Calculate margins (ignore negative margins).\n\n      this._marginLeft = Math.max(0, getStyleAsFloat(element, 'margin-left'));\n      this._marginRight = Math.max(0, getStyleAsFloat(element, 'margin-right'));\n      this._marginTop = Math.max(0, getStyleAsFloat(element, 'margin-top'));\n      this._marginBottom = Math.max(0, getStyleAsFloat(element, 'margin-bottom'));\n    }\n    /**\r\n     * Fetch and store item's sort data.\r\n     *\r\n     * @private\r\n     * @memberof Item.prototype\r\n     */\n\n  }, {\n    key: '_refreshSortData',\n    value: function _refreshSortData() {\n      if (this._isDestroyed) return;\n      var data = this._sortData = {};\n\n      var getters = this.getGrid()._settings.sortData;\n\n      var prop = void 0;\n\n      for (prop in getters) {\n        data[prop] = getters[prop](this, this._element);\n      }\n    }\n    /**\r\n     * Destroy item instance.\r\n     *\r\n     * @private\r\n     * @memberof Item.prototype\r\n     * @param {Boolean} [removeElement=false]\r\n     */\n\n  }, {\n    key: '_destroy',\n    value: function _destroy(removeElement) {\n      if (this._isDestroyed) return;\n      var element = this._element;\n      var grid = this.getGrid();\n      var settings = grid._settings;\n\n      var index = grid._items.indexOf(this); // Destroy handlers.\n\n\n      this._release.destroy();\n\n      this._migrate.destroy();\n\n      this._layout.destroy();\n\n      this._visibility.destroy();\n\n      this._animate.destroy();\n\n      this._animateChild.destroy();\n\n      this._drag && this._drag.destroy(); // Remove all inline styles.\n\n      element.removeAttribute('style');\n\n      this._child.removeAttribute('style'); // Remove item class.\n\n\n      removeClass(element, settings.itemClass); // Remove item from Grid instance if it still exists there.\n\n      index > -1 && grid._items.splice(index, 1); // Remove element from DOM.\n\n      removeElement && element.parentNode.removeChild(element); // Reset state.\n\n      this._isActive = false;\n      this._isDestroyed = true;\n    }\n  }]);\n  return Item;\n}();\n/**\r\n * Muuri Packer\r\n * Copyright (c) 2016-present, Niklas Rämö <inramo@gmail.com>\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/src/Packer/LICENSE.md\r\n */\n\n/**\r\n * This is the default layout algorithm for Muuri. Based on MAXRECTS approach\r\n * as described by Jukka Jylänki in his survey: \"A Thousand Ways to Pack the\r\n * Bin - A Practical Approach to Two-Dimensional Rectangle Bin Packing.\".\r\n *\r\n * @class\r\n */\n\n\nvar Packer = function (_Component) {\n  inherits(Packer, _Component);\n\n  function Packer() {\n    classCallCheck(this, Packer);\n\n    var _this = possibleConstructorReturn(this, (Packer.__proto__ || Object.getPrototypeOf(Packer)).call(this));\n\n    _this._slots = [];\n    _this._slotSizes = [];\n    _this._freeSlots = [];\n    _this._newSlots = [];\n    _this._rectItem = {};\n    _this._rectStore = [];\n    _this._rectId = 0; // The layout return data, which will be populated in getLayout.\n\n    _this._layout = {\n      slots: null,\n      setWidth: false,\n      setHeight: false,\n      width: false,\n      height: false\n    }; // Bind sort handlers.\n\n    _this._sortRectsLeftTop = _this._sortRectsLeftTop.bind(_this);\n    _this._sortRectsTopLeft = _this._sortRectsTopLeft.bind(_this);\n    return _this;\n  }\n  /**\r\n   * @public\r\n   * @memberof Packer.prototype\r\n   * @param {Item[]} items\r\n   * @param {Number} width\r\n   * @param {Number} height\r\n   * @param {Number[]} [slots]\r\n   * @param {Object} [options]\r\n   * @param {Boolean} [options.fillGaps=false]\r\n   * @param {Boolean} [options.horizontal=false]\r\n   * @param {Boolean} [options.alignRight=false]\r\n   * @param {Boolean} [options.alignBottom=false]\r\n   * @returns {LayoutData}\r\n   */\n\n\n  createClass(Packer, [{\n    key: 'getLayout',\n    value: function getLayout(items, width, height, slots, options) {\n      var layout = this._layout;\n      var fillGaps = !!(options && options.fillGaps);\n      var isHorizontal = !!(options && options.horizontal);\n      var alignRight = !!(options && options.alignRight);\n      var alignBottom = !!(options && options.alignBottom);\n      var rounding = !!(options && options.rounding);\n      var slotSizes = this._slotSizes;\n      var i = void 0; // Reset layout data.\n\n      layout.slots = slots || this._slots;\n      layout.width = isHorizontal ? 0 : rounding ? Math.round(width) : width;\n      layout.height = !isHorizontal ? 0 : rounding ? Math.round(height) : height;\n      layout.setWidth = isHorizontal;\n      layout.setHeight = !isHorizontal; // Make sure slots and slot size arrays are reset.\n\n      layout.slots.length = 0;\n      slotSizes.length = 0; // No need to go further if items do not exist.\n\n      if (!items.length) return layout; // Find slots for items.\n\n      for (i = 0; i < items.length; i++) {\n        this._addSlot(items[i], isHorizontal, fillGaps, rounding, alignRight || alignBottom);\n      } // If the alignment is set to right we need to adjust the results.\n\n\n      if (alignRight) {\n        for (i = 0; i < layout.slots.length; i = i + 2) {\n          layout.slots[i] = layout.width - (layout.slots[i] + slotSizes[i]);\n        }\n      } // If the alignment is set to bottom we need to adjust the results.\n\n\n      if (alignBottom) {\n        for (i = 1; i < layout.slots.length; i = i + 2) {\n          layout.slots[i] = layout.height - (layout.slots[i] + slotSizes[i]);\n        }\n      } // Reset slots arrays and rect id.\n\n\n      slotSizes.length = 0;\n      this._freeSlots.length = 0;\n      this._newSlots.length = 0;\n      this._rectId = 0;\n      return layout;\n    }\n    /**\r\n     * Add a new rectangle to the rectangle store. Returns the id of the new\r\n     * rectangle.\r\n     *\r\n     * @private\r\n     * @memberof Packer.prototype\r\n     * @param {Number} left\r\n     * @param {Number} top\r\n     * @param {Number} width\r\n     * @param {Number} height\r\n     * @returns {RectId}\r\n     */\n\n  }, {\n    key: '_addRect',\n    value: function _addRect(left, top, width, height) {\n      var rectId = ++this._rectId;\n      var rectStore = this._rectStore;\n      rectStore[rectId] = left || 0;\n      rectStore[++this._rectId] = top || 0;\n      rectStore[++this._rectId] = width || 0;\n      rectStore[++this._rectId] = height || 0;\n      return rectId;\n    }\n    /**\r\n     * Get rectangle data from the rectangle store by id. Optionally you can\r\n     * provide a target object where the rectangle data will be written in. By\r\n     * default an internal object is reused as a target object.\r\n     *\r\n     * @private\r\n     * @memberof Packer.prototype\r\n     * @param {RectId} id\r\n     * @param {Object} [target]\r\n     * @returns {Object}\r\n     */\n\n  }, {\n    key: '_getRect',\n    value: function _getRect(id, target) {\n      var rectItem = target || this._rectItem;\n      var rectStore = this._rectStore;\n      rectItem.left = rectStore[id] || 0;\n      rectItem.top = rectStore[++id] || 0;\n      rectItem.width = rectStore[++id] || 0;\n      rectItem.height = rectStore[++id] || 0;\n      return rectItem;\n    }\n    /**\r\n     * Check if two rectangles overlap.\r\n     *\r\n     * @private\r\n     * @memberof Packer.prototype\r\n     * @param {Rectangle} a\r\n     * @param {Rectangle} b\r\n     * @returns {Boolean}\r\n     */\n\n  }, {\n    key: '_doRectsOverlap',\n    value: function _doRectsOverlap(a, b) {\n      return !(a.left + a.width <= b.left || b.left + b.width <= a.left || a.top + a.height <= b.top || b.top + b.height <= a.top);\n    }\n    /**\r\n     * Check if a rectangle is fully within another rectangle.\r\n     *\r\n     * @private\r\n     * @memberof Packer.prototype\r\n     * @param {Rectangle} a\r\n     * @param {Rectangle} b\r\n     * @returns {Boolean}\r\n     */\n\n  }, {\n    key: '_isRectWithinRect',\n    value: function _isRectWithinRect(a, b) {\n      return a.left >= b.left && a.top >= b.top && a.left + a.width <= b.left + b.width && a.top + a.height <= b.top + b.height;\n    }\n  }]);\n  return Packer;\n}(Component);\n/**\r\n * Calculate position for the layout item. Returns the left and top position\r\n * of the item in pixels.\r\n *\r\n * @private\r\n * @memberof Packer.prototype\r\n * @param {Item} item\r\n * @param {Boolean} isHorizontal\r\n * @param {Boolean} fillGaps\r\n * @param {Boolean} rounding\r\n * @returns {Array}\r\n */\n\n\nPacker.prototype._addSlot = function () {\n  var leeway = 0.001;\n  var itemSlot = {};\n  return function (item, isHorizontal, fillGaps, rounding, trackSize) {\n    var layout = this._layout;\n    var freeSlots = this._freeSlots;\n    var newSlots = this._newSlots;\n    var rect = void 0;\n    var rectId = void 0;\n    var potentialSlots = void 0;\n    var ignoreCurrentSlots = void 0;\n    var i = void 0;\n    var ii = void 0; // Reset new slots.\n\n    newSlots.length = 0; // Set item slot initial data.\n\n    itemSlot.left = null;\n    itemSlot.top = null;\n    itemSlot.width = item._width + item._marginLeft + item._marginRight;\n    itemSlot.height = item._height + item._marginTop + item._marginBottom; // Round item slot width and height if needed.\n\n    if (rounding) {\n      itemSlot.width = Math.round(itemSlot.width);\n      itemSlot.height = Math.round(itemSlot.height);\n    } // Try to find a slot for the item.\n\n\n    for (i = 0; i < freeSlots.length; i++) {\n      rectId = freeSlots[i];\n      if (!rectId) continue;\n      rect = this._getRect(rectId);\n\n      if (itemSlot.width <= rect.width + leeway && itemSlot.height <= rect.height + leeway) {\n        itemSlot.left = rect.left;\n        itemSlot.top = rect.top;\n        break;\n      }\n    } // If no slot was found for the item.\n\n\n    if (itemSlot.left === null) {\n      // Position the item in to the bottom left (vertical mode) or top right\n      // (horizontal mode) of the grid.\n      itemSlot.left = !isHorizontal ? 0 : layout.width;\n      itemSlot.top = !isHorizontal ? layout.height : 0; // If gaps don't needs filling do not add any current slots to the new\n      // slots array.\n\n      if (!fillGaps) {\n        ignoreCurrentSlots = true;\n      }\n    } // In vertical mode, if the item's bottom overlaps the grid's bottom.\n\n\n    if (!isHorizontal && itemSlot.top + itemSlot.height > layout.height) {\n      // If item is not aligned to the left edge, create a new slot.\n      if (itemSlot.left > 0) {\n        newSlots.push(this._addRect(0, layout.height, itemSlot.left, Infinity));\n      } // If item is not aligned to the right edge, create a new slot.\n\n\n      if (itemSlot.left + itemSlot.width < layout.width) {\n        newSlots.push(this._addRect(itemSlot.left + itemSlot.width, layout.height, layout.width - itemSlot.left - itemSlot.width, Infinity));\n      } // Update grid height.\n\n\n      layout.height = itemSlot.top + itemSlot.height;\n    } // In horizontal mode, if the item's right overlaps the grid's right edge.\n\n\n    if (isHorizontal && itemSlot.left + itemSlot.width > layout.width) {\n      // If item is not aligned to the top, create a new slot.\n      if (itemSlot.top > 0) {\n        newSlots.push(this._addRect(layout.width, 0, Infinity, itemSlot.top));\n      } // If item is not aligned to the bottom, create a new slot.\n\n\n      if (itemSlot.top + itemSlot.height < layout.height) {\n        newSlots.push(this._addRect(layout.width, itemSlot.top + itemSlot.height, Infinity, layout.height - itemSlot.top - itemSlot.height));\n      } // Update grid width.\n\n\n      layout.width = itemSlot.left + itemSlot.width;\n    } // Clean up the current slots making sure there are no old slots that\n    // overlap with the item. If an old slot overlaps with the item, split it\n    // into smaller slots if necessary.\n\n\n    for (i = fillGaps ? 0 : ignoreCurrentSlots ? freeSlots.length : i; i < freeSlots.length; i++) {\n      rectId = freeSlots[i];\n      if (!rectId) continue;\n      rect = this._getRect(rectId);\n      potentialSlots = this._splitRect(rect, itemSlot);\n\n      for (ii = 0; ii < potentialSlots.length; ii++) {\n        rectId = potentialSlots[ii];\n        rect = this._getRect(rectId); // Let's make sure here that we have a big enough slot\n        // (width/height > 0.49px) and also let's make sure that the slot is\n        // within the boundaries of the grid.\n\n        if (rect.width > 0.49 && rect.height > 0.49 && (!isHorizontal && rect.top < layout.height || isHorizontal && rect.left < layout.width)) {\n          newSlots.push(rectId);\n        }\n      }\n    } // Sanitize new slots.\n\n\n    if (newSlots.length) {\n      this._purgeRects(newSlots).sort(isHorizontal ? this._sortRectsLeftTop : this._sortRectsTopLeft);\n    } // Update layout width/height.\n\n\n    if (isHorizontal) {\n      layout.width = Math.max(layout.width, itemSlot.left + itemSlot.width);\n    } else {\n      layout.height = Math.max(layout.height, itemSlot.top + itemSlot.height);\n    } // Add item slot data to layout slots (and store the slot size for later\n    // usage too if necessary).\n\n\n    layout.slots.push(itemSlot.left, itemSlot.top);\n    if (trackSize) this._slotSizes.push(itemSlot.width, itemSlot.height); // Free/new slots switcheroo!\n\n    this._freeSlots = newSlots;\n    this._newSlots = freeSlots;\n  };\n}();\n/**\r\n * Punch a hole into a rectangle and split the remaining area into smaller\r\n * rectangles (4 at max).\r\n *\r\n * @private\r\n * @memberof Packer.prototype\r\n * @param {Rectangle} rect\r\n * @param {Rectangle} hole\r\n * @returns {RectId[]}\r\n */\n\n\nPacker.prototype._splitRect = function () {\n  var results = [];\n  return function (rect, hole) {\n    // Reset old results.\n    results.length = 0; // If the rect does not overlap with the hole add rect to the return data\n    // as is.\n\n    if (!this._doRectsOverlap(rect, hole)) {\n      results.push(this._addRect(rect.left, rect.top, rect.width, rect.height));\n      return results;\n    } // Left split.\n\n\n    if (rect.left < hole.left) {\n      results.push(this._addRect(rect.left, rect.top, hole.left - rect.left, rect.height));\n    } // Right split.\n\n\n    if (rect.left + rect.width > hole.left + hole.width) {\n      results.push(this._addRect(hole.left + hole.width, rect.top, rect.left + rect.width - (hole.left + hole.width), rect.height));\n    } // Top split.\n\n\n    if (rect.top < hole.top) {\n      results.push(this._addRect(rect.left, rect.top, rect.width, hole.top - rect.top));\n    } // Bottom split.\n\n\n    if (rect.top + rect.height > hole.top + hole.height) {\n      results.push(this._addRect(rect.left, hole.top + hole.height, rect.width, rect.top + rect.height - (hole.top + hole.height)));\n    }\n\n    return results;\n  };\n}();\n/**\r\n * Loops through an array of rectangle ids and resets all that are fully\r\n * within another rectangle in the array. Resetting in this case means that\r\n * the rectangle id value is replaced with zero.\r\n *\r\n * @private\r\n * @memberof Packer.prototype\r\n * @param {RectId[]} rectIds\r\n * @returns {RectId[]}\r\n */\n\n\nPacker.prototype._purgeRects = function () {\n  var rectA = {};\n  var rectB = {};\n  return function (rectIds) {\n    var i = rectIds.length;\n    var ii = void 0;\n\n    while (i--) {\n      ii = rectIds.length;\n      if (!rectIds[i]) continue;\n\n      this._getRect(rectIds[i], rectA);\n\n      while (ii--) {\n        if (!rectIds[ii] || i === ii) continue;\n\n        if (this._isRectWithinRect(rectA, this._getRect(rectIds[ii], rectB))) {\n          rectIds[i] = 0;\n          break;\n        }\n      }\n    }\n\n    return rectIds;\n  };\n}();\n/**\r\n * Sort rectangles with top-left gravity.\r\n *\r\n * @private\r\n * @memberof Packer.prototype\r\n * @param {RectId} aId\r\n * @param {RectId} bId\r\n * @returns {Number}\r\n */\n\n\nPacker.prototype._sortRectsTopLeft = function () {\n  var rectA = {};\n  var rectB = {};\n  return function (aId, bId) {\n    this._getRect(aId, rectA);\n\n    this._getRect(bId, rectB); // prettier-ignore\n\n\n    return rectA.top < rectB.top ? -1 : // eslint-disable-line\n    rectA.top > rectB.top ? 1 : // eslint-disable-line\n    rectA.left < rectB.left ? -1 : // eslint-disable-line\n    rectA.left > rectB.left ? 1 : 0; // eslint-disable-line\n  };\n}();\n/**\r\n * Sort rectangles with left-top gravity.\r\n *\r\n * @private\r\n * @memberof Packer.prototype\r\n * @param {RectId} aId\r\n * @param {RectId} bId\r\n * @returns {Number}\r\n */\n\n\nPacker.prototype._sortRectsLeftTop = function () {\n  var rectA = {};\n  var rectB = {};\n  return function (aId, bId) {\n    this._getRect(aId, rectA);\n\n    this._getRect(bId, rectB); // standard-ignore\n\n\n    return rectA.left < rectB.left ? -1 : // eslint-disable-line\n    rectA.left > rectB.left ? 1 : // eslint-disable-line\n    rectA.top < rectB.top ? -1 : // eslint-disable-line\n    rectA.top > rectB.top ? 1 : 0; // eslint-disable-line\n  };\n}();\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\n\nvar htmlCollectionType = '[object HTMLCollection]';\nvar nodeListType = '[object NodeList]';\n/**\r\n * Check if a value is a node list\r\n *\r\n * @param {*} val\r\n * @returns {Boolean}\r\n */\n\nfunction isNodeList(val) {\n  var type = Object.prototype.toString.call(val);\n  return type === htmlCollectionType || type === nodeListType;\n}\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\n/**\r\n * Converts a value to an array or clones an array.\r\n *\r\n * @param {*} target\r\n * @returns {Array}\r\n */\n\n\nfunction toArray$1(target) {\n  return isNodeList(target) ? Array.prototype.slice.call(target) : Array.prototype.concat(target);\n}\n/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\n\n\nvar packer = new Packer();\n\nfunction noop() {}\n/**\r\n * Creates a new Grid instance.\r\n *\r\n * @class\r\n * @param {(HTMLElement|String)} element\r\n * @param {Object} [options]\r\n * @param {(?HTMLElement[]|NodeList|String)} [options.items]\r\n * @param {Number} [options.showDuration=300]\r\n * @param {String} [options.showEasing=\"ease\"]\r\n * @param {Object} [options.visibleStyles]\r\n * @param {Number} [options.hideDuration=300]\r\n * @param {String} [options.hideEasing=\"ease\"]\r\n * @param {Object} [options.hiddenStyles]\r\n * @param {(Function|Object)} [options.layout]\r\n * @param {Boolean} [options.layout.fillGaps=false]\r\n * @param {Boolean} [options.layout.horizontal=false]\r\n * @param {Boolean} [options.layout.alignRight=false]\r\n * @param {Boolean} [options.layout.alignBottom=false]\r\n * @param {Boolean} [options.layout.rounding=true]\r\n * @param {(Boolean|Number)} [options.layoutOnResize=100]\r\n * @param {Boolean} [options.layoutOnInit=true]\r\n * @param {Number} [options.layoutDuration=300]\r\n * @param {String} [options.layoutEasing=\"ease\"]\r\n * @param {?Object} [options.sortData=null]\r\n * @param {Boolean} [options.dragEnabled=false]\r\n * @param {?HtmlElement} [options.dragContainer=null]\r\n * @param {?Function} [options.dragStartPredicate]\r\n * @param {Number} [options.dragStartPredicate.distance=0]\r\n * @param {Number} [options.dragStartPredicate.delay=0]\r\n * @param {(Boolean|String)} [options.dragStartPredicate.handle=false]\r\n * @param {?String} [options.dragAxis]\r\n * @param {(Boolean|Function)} [options.dragSort=true]\r\n * @param {Number} [options.dragSortInterval=100]\r\n * @param {(Function|Object)} [options.dragSortPredicate]\r\n * @param {Number} [options.dragSortPredicate.threshold=50]\r\n * @param {String} [options.dragSortPredicate.action=\"move\"]\r\n * @param {Number} [options.dragReleaseDuration=300]\r\n * @param {String} [options.dragReleaseEasing=\"ease\"]\r\n * @param {Object} [options.dragHammerSettings={touchAction: \"none\"}]\r\n * @param {String} [options.containerClass=\"muuri\"]\r\n * @param {String} [options.itemClass=\"muuri-item\"]\r\n * @param {String} [options.itemVisibleClass=\"muuri-item-visible\"]\r\n * @param {String} [options.itemHiddenClass=\"muuri-item-hidden\"]\r\n * @param {String} [options.itemPositioningClass=\"muuri-item-positioning\"]\r\n * @param {String} [options.itemDraggingClass=\"muuri-item-dragging\"]\r\n * @param {String} [options.itemReleasingClass=\"muuri-item-releasing\"]\r\n */\n\n\nvar Grid = function (_Component) {\n  inherits(Grid, _Component);\n\n  function Grid(element, options) {\n    classCallCheck(this, Grid);\n\n    var _this = possibleConstructorReturn(this, (Grid.__proto__ || Object.getPrototypeOf(Grid)).call(this, element, options));\n\n    var inst = _this;\n    var settings = void 0;\n    var items = void 0;\n    var layoutOnResize = void 0; // Allow passing element as selector string. Store element for instance.\n\n    element = _this._element = typeof element === 'string' ? document.querySelector(element) : element; // Throw an error if the container element is not body element or does not\n    // exist within the body element.\n\n    if (!document.body.contains(element)) {\n      throw new Error('Container element must be an existing DOM element');\n    } // Create instance settings by merging the options with default options.\n\n\n    settings = _this._settings = mergeSettings(Grid.defaultOptions, options); // Sanitize dragSort setting.\n\n    if (typeof settings.dragSort !== 'function') {\n      settings.dragSort = !!settings.dragSort;\n    } // Create instance id and store it to the grid instances collection.\n\n\n    _this._id = createUid();\n    gridInstances[_this._id] = inst; // Destroyed flag.\n\n    _this._isDestroyed = false; // The layout object (mutated on every layout).\n\n    _this._layout = {\n      id: 0,\n      items: [],\n      slots: [],\n      setWidth: false,\n      setHeight: false,\n      width: 0,\n      height: 0\n    }; // Create private Emitter instance.\n\n    _this._emitter = new Emitter(); // Add container element's class name.\n\n    addClass(element, settings.containerClass); // Create initial items.\n\n    _this._items = [];\n    items = settings.items;\n\n    if (typeof items === 'string') {\n      toArray$1(element.children).forEach(function (itemElement) {\n        if (items === '*' || elementMatches(itemElement, items)) {\n          inst._items.push(new Item(inst, itemElement));\n        }\n      });\n    } else if (Array.isArray(items) || isNodeList(items)) {\n      _this._items = toArray$1(items).map(function (itemElement) {\n        return new Item(inst, itemElement);\n      });\n    } // If layoutOnResize option is a valid number sanitize it and bind the resize\n    // handler.\n\n\n    layoutOnResize = settings.layoutOnResize;\n\n    if (typeof layoutOnResize !== 'number') {\n      layoutOnResize = layoutOnResize === true ? 0 : -1;\n    }\n\n    if (layoutOnResize >= 0) {\n      window.addEventListener('resize', inst._resizeHandler = debounce(function () {\n        inst.refreshItems().layout();\n      }, layoutOnResize));\n    } // Layout on init if necessary.\n\n\n    if (settings.layoutOnInit) {\n      _this.layout(true);\n    }\n\n    return _this;\n  }\n  /**\r\n   * Public prototype methods\r\n   * ************************\r\n   */\n\n  /**\r\n   * Bind an event listener.\r\n   *\r\n   * @public\r\n   * @memberof Grid.prototype\r\n   * @param {String} event\r\n   * @param {Function} listener\r\n   * @returns {Grid}\r\n   */\n\n\n  createClass(Grid, [{\n    key: 'on',\n    value: function on(event, listener) {\n      this._emitter.on(event, listener);\n\n      return this;\n    }\n    /**\r\n     * Bind an event listener that is triggered only once.\r\n     *\r\n     * @public\r\n     * @memberof Grid.prototype\r\n     * @param {String} event\r\n     * @param {Function} listener\r\n     * @returns {Grid}\r\n     */\n\n  }, {\n    key: 'once',\n    value: function once(event, listener) {\n      this._emitter.once(event, listener);\n\n      return this;\n    }\n    /**\r\n     * Unbind an event listener.\r\n     *\r\n     * @public\r\n     * @memberof Grid.prototype\r\n     * @param {String} event\r\n     * @param {Function} listener\r\n     * @returns {Grid}\r\n     */\n\n  }, {\n    key: 'off',\n    value: function off(event, listener) {\n      this._emitter.off(event, listener);\n\n      return this;\n    }\n    /**\r\n     * Get the container element.\r\n     *\r\n     * @public\r\n     * @memberof Grid.prototype\r\n     * @returns {HTMLElement}\r\n     */\n\n  }, {\n    key: 'getElement',\n    value: function getElement() {\n      return this._element;\n    }\n    /**\r\n     * Get all items. Optionally you can provide specific targets (elements and\r\n     * indices). Note that the returned array is not the same object used by the\r\n     * instance so modifying it will not affect instance's items. All items that\r\n     * are not found are omitted from the returned array.\r\n     *\r\n     * @public\r\n     * @memberof Grid.prototype\r\n     * @param {GridMultiItemQuery} [targets]\r\n     * @returns {Item[]}\r\n     */\n\n  }, {\n    key: 'getItems',\n    value: function getItems(targets) {\n      // Return all items immediately if no targets were provided or if the\n      // instance is destroyed.\n      if (this._isDestroyed || !targets && targets !== 0) {\n        return this._items.slice(0);\n      }\n\n      var ret = [];\n      var targetItems = toArray$1(targets);\n      var item = void 0;\n      var i = void 0; // If target items are defined return filtered results.\n\n      for (i = 0; i < targetItems.length; i++) {\n        item = this._getItem(targetItems[i]);\n        item && ret.push(item);\n      }\n\n      return ret;\n    }\n    /**\r\n     * Update the cached dimensions of the instance's items.\r\n     *\r\n     * @public\r\n     * @memberof Grid.prototype\r\n     * @param {GridMultiItemQuery} [items]\r\n     * @returns {Grid}\r\n     */\n\n  }, {\n    key: 'refreshItems',\n    value: function refreshItems(items) {\n      if (this._isDestroyed) return this;\n      var targets = this.getItems(items);\n      var i = void 0;\n\n      for (i = 0; i < targets.length; i++) {\n        targets[i]._refreshDimensions();\n      }\n\n      return this;\n    }\n    /**\r\n     * Update the sort data of the instance's items.\r\n     *\r\n     * @public\r\n     * @memberof Grid.prototype\r\n     * @param {GridMultiItemQuery} [items]\r\n     * @returns {Grid}\r\n     */\n\n  }, {\n    key: 'refreshSortData',\n    value: function refreshSortData(items) {\n      if (this._isDestroyed) return this;\n      var targetItems = this.getItems(items);\n      var i = void 0;\n\n      for (i = 0; i < targetItems.length; i++) {\n        targetItems[i]._refreshSortData();\n      }\n\n      return this;\n    }\n    /**\r\n     * Synchronize the item elements to match the order of the items in the DOM.\r\n     * This comes handy if you need to keep the DOM structure matched with the\r\n     * order of the items. Note that if an item's element is not currently a child\r\n     * of the container element (if it is dragged for example) it is ignored and\r\n     * left untouched.\r\n     *\r\n     * @public\r\n     * @memberof Grid.prototype\r\n     * @returns {Grid}\r\n     */\n\n  }, {\n    key: 'synchronize',\n    value: function synchronize() {\n      if (this._isDestroyed) return this;\n      var container = this._element;\n      var items = this._items;\n      var fragment = void 0;\n      var element = void 0;\n      var i = void 0; // Append all elements in order to the container element.\n\n      if (items.length) {\n        for (i = 0; i < items.length; i++) {\n          element = items[i]._element;\n\n          if (element.parentNode === container) {\n            fragment = fragment || document.createDocumentFragment();\n            fragment.appendChild(element);\n          }\n        }\n\n        if (fragment) container.appendChild(fragment);\n      } // Emit synchronize event.\n\n\n      this._emit(eventSynchronize);\n\n      return this;\n    }\n    /**\r\n     * Calculate and apply item positions.\r\n     *\r\n     * @public\r\n     * @memberof Grid.prototype\r\n     * @param {Boolean} [instant=false]\r\n     * @param {LayoutCallback} [onFinish]\r\n     * @returns {Grid}\r\n     */\n\n  }, {\n    key: 'layout',\n    value: function layout(instant, onFinish) {\n      if (this._isDestroyed) return this;\n      var inst = this;\n      var element = this._element;\n\n      var layout = this._updateLayout();\n\n      var layoutId = layout.id;\n      var itemsLength = layout.items.length;\n      var counter = itemsLength;\n      var callback = typeof instant === 'function' ? instant : onFinish;\n      var isCallbackFunction = typeof callback === 'function';\n      var callbackItems = isCallbackFunction ? layout.items.slice(0) : null;\n      var isBorderBox = void 0;\n      var item = void 0;\n      var i = void 0; // The finish function, which will be used for checking if all the items\n      // have laid out yet. After all items have finished their animations call\n      // callback and emit layoutEnd event. Only emit layoutEnd event if there\n      // hasn't been a new layout call during this layout.\n\n      function tryFinish() {\n        if (--counter > 0) return;\n        var hasLayoutChanged = inst._layout.id !== layoutId;\n        isCallbackFunction && callback(hasLayoutChanged, callbackItems);\n\n        if (!hasLayoutChanged && inst._hasListeners(eventLayoutEnd)) {\n          inst._emit(eventLayoutEnd, layout.items.slice(0));\n        }\n      } // If grid's width or height was modified, we need to update it's cached\n      // dimensions. Also keep in mind that grid's cached width/height should\n      // always equal to what elem.getBoundingClientRect() would return, so\n      // therefore we need to add the grid element's borders to the dimensions if\n      // it's box-sizing is border-box.\n\n\n      if (layout.setHeight && typeof layout.height === 'number' || layout.setWidth && typeof layout.width === 'number') {\n        isBorderBox = getStyle(element, 'box-sizing') === 'border-box';\n      }\n\n      if (layout.setHeight) {\n        if (typeof layout.height === 'number') {\n          element.style.height = (isBorderBox ? layout.height + this._borderTop + this._borderBottom : layout.height) + 'px';\n        } else {\n          element.style.height = layout.height;\n        }\n      }\n\n      if (layout.setWidth) {\n        if (typeof layout.width === 'number') {\n          element.style.width = (isBorderBox ? layout.width + this._borderLeft + this._borderRight : layout.width) + 'px';\n        } else {\n          element.style.width = layout.width;\n        }\n      } // Emit layoutStart event. Note that this is intentionally emitted after the\n      // container element's dimensions are set, because otherwise there would be\n      // no hook for reacting to container dimension changes.\n\n\n      if (this._hasListeners(eventLayoutStart)) {\n        this._emit(eventLayoutStart, layout.items.slice(0));\n      } // If there are no items let's finish quickly.\n\n\n      if (!itemsLength) {\n        tryFinish();\n        return this;\n      } // If there are items let's position them.\n\n\n      for (i = 0; i < itemsLength; i++) {\n        item = layout.items[i];\n        if (!item) continue; // Update item's position.\n\n        item._left = layout.slots[i * 2];\n        item._top = layout.slots[i * 2 + 1]; // Layout item if it is not dragged.\n\n        item.isDragging() ? tryFinish() : item._layout.start(instant === true, tryFinish);\n      }\n\n      return this;\n    }\n    /**\r\n     * Add new items by providing the elements you wish to add to the instance and\r\n     * optionally provide the index where you want the items to be inserted into.\r\n     * All elements that are not already children of the container element will be\r\n     * automatically appended to the container element. If an element has it's CSS\r\n     * display property set to \"none\" it will be marked as inactive during the\r\n     * initiation process. As long as the item is inactive it will not be part of\r\n     * the layout, but it will retain it's index. You can activate items at any\r\n     * point with grid.show() method. This method will automatically call\r\n     * grid.layout() if one or more of the added elements are visible. If only\r\n     * hidden items are added no layout will be called. All the new visible items\r\n     * are positioned without animation during their first layout.\r\n     *\r\n     * @public\r\n     * @memberof Grid.prototype\r\n     * @param {(HTMLElement|HTMLElement[])} elements\r\n     * @param {Object} [options]\r\n     * @param {Number} [options.index=-1]\r\n     * @param {Boolean} [options.isActive]\r\n     * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\r\n     * @returns {Item[]}\r\n     */\n\n  }, {\n    key: 'add',\n    value: function add(elements, options) {\n      if (this._isDestroyed || !elements) return [];\n      var newItems = toArray$1(elements);\n      if (!newItems.length) return newItems;\n      var opts = options || 0;\n      var layout = opts.layout ? opts.layout : opts.layout === undefined;\n      var items = this._items;\n      var needsLayout = false;\n      var item = void 0;\n      var i = void 0; // Map provided elements into new grid items.\n\n      for (i = 0; i < newItems.length; i++) {\n        item = new Item(this, newItems[i], opts.isActive);\n        newItems[i] = item; // If the item to be added is active, we need to do a layout. Also, we\n        // need to mark the item with the skipNextAnimation flag to make it\n        // position instantly (without animation) during the next layout. Without\n        // the hack the item would animate to it's new position from the northwest\n        // corner of the grid, which feels a bit buggy (imho).\n\n        if (item._isActive) {\n          needsLayout = true;\n          item._layout._skipNextAnimation = true;\n        }\n      } // Add the new items to the items collection to correct index.\n\n\n      arrayInsert(items, newItems, opts.index); // Emit add event.\n\n      if (this._hasListeners(eventAdd)) {\n        this._emit(eventAdd, newItems.slice(0));\n      } // If layout is needed.\n\n\n      if (needsLayout && layout) {\n        this.layout(layout === 'instant', typeof layout === 'function' ? layout : undefined);\n      }\n\n      return newItems;\n    }\n    /**\r\n     * Remove items from the instance.\r\n     *\r\n     * @public\r\n     * @memberof Grid.prototype\r\n     * @param {GridMultiItemQuery} items\r\n     * @param {Object} [options]\r\n     * @param {Boolean} [options.removeElements=false]\r\n     * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\r\n     * @returns {Item[]}\r\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(items, options) {\n      if (this._isDestroyed) return this;\n      var opts = options || 0;\n      var layout = opts.layout ? opts.layout : opts.layout === undefined;\n      var needsLayout = false;\n      var allItems = this.getItems();\n      var targetItems = this.getItems(items);\n      var indices = [];\n      var item = void 0;\n      var i = void 0; // Remove the individual items.\n\n      for (i = 0; i < targetItems.length; i++) {\n        item = targetItems[i];\n        indices.push(allItems.indexOf(item));\n        if (item._isActive) needsLayout = true;\n\n        item._destroy(opts.removeElements);\n      } // Emit remove event.\n\n\n      if (this._hasListeners(eventRemove)) {\n        this._emit(eventRemove, targetItems.slice(0), indices);\n      } // If layout is needed.\n\n\n      if (needsLayout && layout) {\n        this.layout(layout === 'instant', typeof layout === 'function' ? layout : undefined);\n      }\n\n      return targetItems;\n    }\n    /**\r\n     * Show instance items.\r\n     *\r\n     * @public\r\n     * @memberof Grid.prototype\r\n     * @param {GridMultiItemQuery} items\r\n     * @param {Object} [options]\r\n     * @param {Boolean} [options.instant=false]\r\n     * @param {ShowCallback} [options.onFinish]\r\n     * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\r\n     * @returns {Grid}\r\n     */\n\n  }, {\n    key: 'show',\n    value: function show(items, options) {\n      if (this._isDestroyed) return this;\n\n      this._setItemsVisibility(items, true, options);\n\n      return this;\n    }\n    /**\r\n     * Hide instance items.\r\n     *\r\n     * @public\r\n     * @memberof Grid.prototype\r\n     * @param {GridMultiItemQuery} items\r\n     * @param {Object} [options]\r\n     * @param {Boolean} [options.instant=false]\r\n     * @param {HideCallback} [options.onFinish]\r\n     * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\r\n     * @returns {Grid}\r\n     */\n\n  }, {\n    key: 'hide',\n    value: function hide(items, options) {\n      if (this._isDestroyed) return this;\n\n      this._setItemsVisibility(items, false, options);\n\n      return this;\n    }\n    /**\r\n     * Filter items. Expects at least one argument, a predicate, which should be\r\n     * either a function or a string. The predicate callback is executed for every\r\n     * item in the instance. If the return value of the predicate is truthy the\r\n     * item in question will be shown and otherwise hidden. The predicate callback\r\n     * receives the item instance as it's argument. If the predicate is a string\r\n     * it is considered to be a selector and it is checked against every item\r\n     * element in the instance with the native element.matches() method. All the\r\n     * matching items will be shown and others hidden.\r\n     *\r\n     * @public\r\n     * @memberof Grid.prototype\r\n     * @param {(Function|String)} predicate\r\n     * @param {Object} [options]\r\n     * @param {Boolean} [options.instant=false]\r\n     * @param {FilterCallback} [options.onFinish]\r\n     * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\r\n     * @returns {Grid}\r\n     */\n\n  }, {\n    key: 'filter',\n    value: function filter(predicate, options) {\n      if (this._isDestroyed || !this._items.length) return this;\n      var itemsToShow = [];\n      var itemsToHide = [];\n      var isPredicateString = typeof predicate === 'string';\n      var isPredicateFn = typeof predicate === 'function';\n      var opts = options || 0;\n      var isInstant = opts.instant === true;\n      var layout = opts.layout ? opts.layout : opts.layout === undefined;\n      var onFinish = typeof opts.onFinish === 'function' ? opts.onFinish : null;\n      var tryFinishCounter = -1;\n      var tryFinish = noop;\n      var item = void 0;\n      var i = void 0; // If we have onFinish callback, let's create proper tryFinish callback.\n\n      if (onFinish) {\n        tryFinish = function tryFinish() {\n          ++tryFinishCounter && onFinish(itemsToShow.slice(0), itemsToHide.slice(0));\n        };\n      } // Check which items need to be shown and which hidden.\n\n\n      if (isPredicateFn || isPredicateString) {\n        for (i = 0; i < this._items.length; i++) {\n          item = this._items[i];\n\n          if (isPredicateFn ? predicate(item) : elementMatches(item._element, predicate)) {\n            itemsToShow.push(item);\n          } else {\n            itemsToHide.push(item);\n          }\n        }\n      } // Show items that need to be shown.\n\n\n      if (itemsToShow.length) {\n        this.show(itemsToShow, {\n          instant: isInstant,\n          onFinish: tryFinish,\n          layout: false\n        });\n      } else {\n        tryFinish();\n      } // Hide items that need to be hidden.\n\n\n      if (itemsToHide.length) {\n        this.hide(itemsToHide, {\n          instant: isInstant,\n          onFinish: tryFinish,\n          layout: false\n        });\n      } else {\n        tryFinish();\n      } // If there are any items to filter.\n\n\n      if (itemsToShow.length || itemsToHide.length) {\n        // Emit filter event.\n        if (this._hasListeners(eventFilter)) {\n          this._emit(eventFilter, itemsToShow.slice(0), itemsToHide.slice(0));\n        } // If layout is needed.\n\n\n        if (layout) {\n          this.layout(layout === 'instant', typeof layout === 'function' ? layout : undefined);\n        }\n      }\n\n      return this;\n    }\n    /**\r\n     * Move item to another index or in place of another item.\r\n     *\r\n     * @public\r\n     * @memberof Grid.prototype\r\n     * @param {GridSingleItemQuery} item\r\n     * @param {GridSingleItemQuery} position\r\n     * @param {Object} [options]\r\n     * @param {String} [options.action=\"move\"]\r\n     *   - Accepts either \"move\" or \"swap\".\r\n     *   - \"move\" moves the item in place of the other item.\r\n     *   - \"swap\" swaps the position of the items.\r\n     * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\r\n     * @returns {Grid}\r\n     */\n\n  }, {\n    key: 'move',\n    value: function move(item, position, options) {\n      if (this._isDestroyed || this._items.length < 2) return this;\n      var items = this._items;\n      var opts = options || 0;\n      var layout = opts.layout ? opts.layout : opts.layout === undefined;\n      var isSwap = opts.action === 'swap';\n      var action = isSwap ? 'swap' : 'move';\n\n      var fromItem = this._getItem(item);\n\n      var toItem = this._getItem(position);\n\n      var fromIndex = void 0;\n      var toIndex = void 0; // Make sure the items exist and are not the same.\n\n      if (fromItem && toItem && fromItem !== toItem) {\n        // Get the indices of the items.\n        fromIndex = items.indexOf(fromItem);\n        toIndex = items.indexOf(toItem); // Do the move/swap.\n\n        if (isSwap) {\n          arraySwap(items, fromIndex, toIndex);\n        } else {\n          arrayMove(items, fromIndex, toIndex);\n        } // Emit move event.\n\n\n        if (this._hasListeners(eventMove)) {\n          this._emit(eventMove, {\n            item: fromItem,\n            fromIndex: fromIndex,\n            toIndex: toIndex,\n            action: action\n          });\n        } // If layout is needed.\n\n\n        if (layout) {\n          this.layout(layout === 'instant', typeof layout === 'function' ? layout : undefined);\n        }\n      }\n\n      return this;\n    }\n    /**\r\n     * Send item to another Grid instance.\r\n     *\r\n     * @public\r\n     * @memberof Grid.prototype\r\n     * @param {GridSingleItemQuery} item\r\n     * @param {Grid} grid\r\n     * @param {GridSingleItemQuery} position\r\n     * @param {Object} [options]\r\n     * @param {HTMLElement} [options.appendTo=document.body]\r\n     * @param {(Boolean|LayoutCallback|String)} [options.layoutSender=true]\r\n     * @param {(Boolean|LayoutCallback|String)} [options.layoutReceiver=true]\r\n     * @returns {Grid}\r\n     */\n\n  }, {\n    key: 'send',\n    value: function send(item, grid, position, options) {\n      if (this._isDestroyed || grid._isDestroyed || this === grid) return this; // Make sure we have a valid target item.\n\n      item = this._getItem(item);\n      if (!item) return this;\n      var opts = options || 0;\n      var container = opts.appendTo || document.body;\n      var layoutSender = opts.layoutSender ? opts.layoutSender : opts.layoutSender === undefined;\n      var layoutReceiver = opts.layoutReceiver ? opts.layoutReceiver : opts.layoutReceiver === undefined; // Start the migration process.\n\n      item._migrate.start(grid, position, container); // If migration was started successfully and the item is active, let's layout\n      // the grids.\n\n\n      if (item._migrate._isActive && item._isActive) {\n        if (layoutSender) {\n          this.layout(layoutSender === 'instant', typeof layoutSender === 'function' ? layoutSender : undefined);\n        }\n\n        if (layoutReceiver) {\n          grid.layout(layoutReceiver === 'instant', typeof layoutReceiver === 'function' ? layoutReceiver : undefined);\n        }\n      }\n\n      return this;\n    }\n    /**\r\n     * Destroy the instance.\r\n     *\r\n     * @public\r\n     * @memberof Grid.prototype\r\n     * @param {Boolean} [removeElements=false]\r\n     * @returns {Grid}\r\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy(removeElements) {\n      if (this._isDestroyed) return this;\n      var container = this._element;\n\n      var items = this._items.slice(0);\n\n      var i = void 0; // Unbind window resize event listener.\n\n      if (this._resizeHandler) {\n        window.removeEventListener('resize', this._resizeHandler);\n      } // Destroy items.\n\n\n      for (i = 0; i < items.length; i++) {\n        items[i]._destroy(removeElements);\n      } // Restore container.\n\n\n      removeClass(container, this._settings.containerClass);\n      container.style.height = '';\n      container.style.width = ''; // Emit destroy event and unbind all events.\n\n      this._emit(eventDestroy);\n\n      this._emitter.destroy(); // Remove reference from the grid instances collection.\n\n\n      gridInstances[this._id] = undefined; // Flag instance as destroyed.\n\n      this._isDestroyed = true;\n      return this;\n    }\n    /**\r\n     * Private prototype methods\r\n     * *************************\r\n     */\n\n    /**\r\n     * Get instance's item by element or by index. Target can also be an Item\r\n     * instance in which case the function returns the item if it exists within\r\n     * related Grid instance. If nothing is found with the provided target, null\r\n     * is returned.\r\n     *\r\n     * @private\r\n     * @memberof Grid.prototype\r\n     * @param {GridSingleItemQuery} [target]\r\n     * @returns {?Item}\r\n     */\n\n  }, {\n    key: '_getItem',\n    value: function _getItem(target) {\n      // If no target is specified or the instance is destroyed, return null.\n      if (this._isDestroyed || !target && target !== 0) {\n        return null;\n      } // If target is number return the item in that index. If the number is lower\n      // than zero look for the item starting from the end of the items array. For\n      // example -1 for the last item, -2 for the second last item, etc.\n\n\n      if (typeof target === 'number') {\n        return this._items[target > -1 ? target : this._items.length + target] || null;\n      } // If the target is an instance of Item return it if it is attached to this\n      // Grid instance, otherwise return null.\n\n\n      if (target instanceof Item) {\n        return target._gridId === this._id ? target : null;\n      } // In other cases let's assume that the target is an element, so let's try\n      // to find an item that matches the element and return it. If item is not\n      // found return null.\n\n      /** @todo This could be made a lot faster by using Map/WeakMap of elements. */\n\n\n      for (var i = 0; i < this._items.length; i++) {\n        if (this._items[i]._element === target) {\n          return this._items[i];\n        }\n      }\n\n      return null;\n    }\n    /**\r\n     * Recalculates and updates instance's layout data.\r\n     *\r\n     * @private\r\n     * @memberof Grid.prototype\r\n     * @returns {LayoutData}\r\n     */\n\n  }, {\n    key: '_updateLayout',\n    value: function _updateLayout() {\n      var layout = this._layout;\n      var settings = this._settings.layout;\n      var width = void 0;\n      var height = void 0;\n      var newLayout = void 0;\n      var i = void 0; // Let's increment layout id.\n\n      ++layout.id; // Let's update layout items\n\n      layout.items.length = 0;\n\n      for (i = 0; i < this._items.length; i++) {\n        if (this._items[i]._isActive) layout.items.push(this._items[i]);\n      } // Let's make sure we have the correct container dimensions.\n\n\n      this._refreshDimensions(); // Calculate container width and height (without borders).\n\n\n      width = this._width - this._borderLeft - this._borderRight;\n      height = this._height - this._borderTop - this._borderBottom; // Calculate new layout.\n\n      if (typeof settings === 'function') {\n        newLayout = settings(layout.items, width, height);\n      } else {\n        newLayout = packer.getLayout(layout.items, width, height, layout.slots, settings);\n      } // Let's update the grid's layout.\n\n\n      layout.slots = newLayout.slots;\n      layout.setWidth = Boolean(newLayout.setWidth);\n      layout.setHeight = Boolean(newLayout.setHeight);\n      layout.width = newLayout.width;\n      layout.height = newLayout.height;\n      return layout;\n    }\n    /**\r\n     * Emit a grid event.\r\n     *\r\n     * @private\r\n     * @memberof Grid.prototype\r\n     * @param {String} event\r\n     * @param {...*} [arg]\r\n     */\n\n  }, {\n    key: '_emit',\n    value: function _emit() {\n      var _emitter;\n\n      if (this._isDestroyed) return;\n\n      (_emitter = this._emitter).emit.apply(_emitter, arguments);\n    }\n    /**\r\n     * Check if there are any events listeners for an event.\r\n     *\r\n     * @private\r\n     * @memberof Grid.prototype\r\n     * @param {String} event\r\n     * @returns {Boolean}\r\n     */\n\n  }, {\n    key: '_hasListeners',\n    value: function _hasListeners(event) {\n      var listeners = this._emitter._events[event];\n      return !!(listeners && listeners.length);\n    }\n    /**\r\n     * Update container's width, height and offsets.\r\n     *\r\n     * @private\r\n     * @memberof Grid.prototype\r\n     */\n\n  }, {\n    key: '_updateBoundingRect',\n    value: function _updateBoundingRect() {\n      var element = this._element;\n      var rect = element.getBoundingClientRect();\n      this._width = rect.width;\n      this._height = rect.height;\n      this._left = rect.left;\n      this._top = rect.top;\n    }\n    /**\r\n     * Update container's border sizes.\r\n     *\r\n     * @private\r\n     * @memberof Grid.prototype\r\n     * @param {Boolean} left\r\n     * @param {Boolean} right\r\n     * @param {Boolean} top\r\n     * @param {Boolean} bottom\r\n     */\n\n  }, {\n    key: '_updateBorders',\n    value: function _updateBorders(left, right, top, bottom) {\n      var element = this._element;\n      if (left) this._borderLeft = getStyleAsFloat(element, 'border-left-width');\n      if (right) this._borderRight = getStyleAsFloat(element, 'border-right-width');\n      if (top) this._borderTop = getStyleAsFloat(element, 'border-top-width');\n      if (bottom) this._borderBottom = getStyleAsFloat(element, 'border-bottom-width');\n    }\n    /**\r\n     * Refresh all of container's internal dimensions and offsets.\r\n     *\r\n     * @private\r\n     * @memberof Grid.prototype\r\n     */\n\n  }, {\n    key: '_refreshDimensions',\n    value: function _refreshDimensions() {\n      this._updateBoundingRect();\n\n      this._updateBorders(1, 1, 1, 1);\n    }\n    /**\r\n     * Show or hide Grid instance's items.\r\n     *\r\n     * @private\r\n     * @memberof Grid.prototype\r\n     * @param {GridMultiItemQuery} items\r\n     * @param {Boolean} toVisible\r\n     * @param {Object} [options]\r\n     * @param {Boolean} [options.instant=false]\r\n     * @param {(ShowCallback|HideCallback)} [options.onFinish]\r\n     * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\r\n     */\n\n  }, {\n    key: '_setItemsVisibility',\n    value: function _setItemsVisibility(items, toVisible, options) {\n      var grid = this;\n      var targetItems = this.getItems(items);\n      var opts = options || 0;\n      var isInstant = opts.instant === true;\n      var callback = opts.onFinish;\n      var layout = opts.layout ? opts.layout : opts.layout === undefined;\n      var counter = targetItems.length;\n      var startEvent = toVisible ? eventShowStart : eventHideStart;\n      var endEvent = toVisible ? eventShowEnd : eventHideEnd;\n      var method = toVisible ? 'show' : 'hide';\n      var needsLayout = false;\n      var completedItems = [];\n      var hiddenItems = [];\n      var item = void 0;\n      var i = void 0; // If there are no items call the callback, but don't emit any events.\n\n      if (!counter) {\n        if (typeof callback === 'function') callback(targetItems);\n        return;\n      } // Emit showStart/hideStart event.\n\n\n      if (this._hasListeners(startEvent)) {\n        this._emit(startEvent, targetItems.slice(0));\n      } // Show/hide items.\n\n\n      for (i = 0; i < targetItems.length; i++) {\n        item = targetItems[i]; // If inactive item is shown or active item is hidden we need to do\n        // layout.\n\n        if (toVisible && !item._isActive || !toVisible && item._isActive) {\n          needsLayout = true;\n        } // If inactive item is shown we also need to do a little hack to make the\n        // item not animate it's next positioning (layout).\n\n\n        if (toVisible && !item._isActive) {\n          item._layout._skipNextAnimation = true;\n        } // If a hidden item is being shown we need to refresh the item's\n        // dimensions.\n\n\n        if (toVisible && item._visibility._isHidden) {\n          hiddenItems.push(item);\n        } // Show/hide the item.\n\n\n        item._visibility[method](isInstant, function (interrupted, item) {\n          // If the current item's animation was not interrupted add it to the\n          // completedItems array.\n          if (!interrupted) completedItems.push(item); // If all items have finished their animations call the callback\n          // and emit showEnd/hideEnd event.\n\n          if (--counter < 1) {\n            if (typeof callback === 'function') callback(completedItems.slice(0));\n            if (grid._hasListeners(endEvent)) grid._emit(endEvent, completedItems.slice(0));\n          }\n        });\n      } // Refresh hidden items.\n\n\n      if (hiddenItems.length) this.refreshItems(hiddenItems); // Layout if needed.\n\n      if (needsLayout && layout) {\n        this.layout(layout === 'instant', typeof layout === 'function' ? layout : undefined);\n      }\n    }\n  }]);\n  return Grid;\n}(Component);\n/**\r\n * Public properties\r\n * *****************\r\n */\n\n/**\r\n * @see Item\r\n */\n\n\nGrid.Item = Item;\n/**\r\n * @see ItemLayout\r\n */\n\nGrid.ItemLayout = ItemLayout;\n/**\r\n * @see ItemVisibility\r\n */\n\nGrid.ItemVisibility = ItemVisibility;\n/**\r\n * @see ItemRelease\r\n */\n\nGrid.ItemRelease = ItemRelease;\n/**\r\n * @see ItemMigrate\r\n */\n\nGrid.ItemMigrate = ItemMigrate;\n/**\r\n * @see ItemAnimate\r\n */\n\nGrid.ItemAnimate = ItemAnimate;\n/**\r\n * @see ItemDrag\r\n */\n\nGrid.ItemDrag = ItemDrag;\n/**\r\n * @see Emitter\r\n */\n\nGrid.Emitter = Emitter;\n/**\r\n * Default options for Grid instance.\r\n *\r\n * @public\r\n * @memberof Grid\r\n */\n\nGrid.defaultOptions = {\n  // Item elements\n  items: '*',\n  // Default show animation\n  showDuration: 300,\n  showEasing: 'ease',\n  // Default hide animation\n  hideDuration: 300,\n  hideEasing: 'ease',\n  // Item's visible/hidden state styles\n  visibleStyles: {\n    opacity: '1',\n    transform: 'scale(1)'\n  },\n  hiddenStyles: {\n    opacity: '0',\n    transform: 'scale(0.5)'\n  },\n  // Layout\n  layout: {\n    fillGaps: false,\n    horizontal: false,\n    alignRight: false,\n    alignBottom: false,\n    rounding: true\n  },\n  layoutOnResize: 100,\n  layoutOnInit: true,\n  layoutDuration: 300,\n  layoutEasing: 'ease',\n  // Sorting\n  sortData: null,\n  // Drag & Drop\n  dragEnabled: false,\n  dragContainer: null,\n  dragStartPredicate: {\n    distance: 0,\n    delay: 0,\n    handle: false\n  },\n  dragAxis: null,\n  dragSort: true,\n  dragSortInterval: 100,\n  dragSortPredicate: {\n    threshold: 50,\n    action: 'move'\n  },\n  dragReleaseDuration: 300,\n  dragReleaseEasing: 'ease',\n  dragHammerSettings: {\n    touchAction: 'none'\n  },\n  // Classnames\n  containerClass: 'muuri',\n  itemClass: 'muuri-item',\n  itemVisibleClass: 'muuri-item-shown',\n  itemHiddenClass: 'muuri-item-hidden',\n  itemPositioningClass: 'muuri-item-positioning',\n  itemDraggingClass: 'muuri-item-dragging',\n  itemReleasingClass: 'muuri-item-releasing'\n};\n/**\r\n * Sort items. There are three ways to sort the items. The first is simply by\r\n * providing a function as the comparer which works identically to native\r\n * array sort. Alternatively you can sort by the sort data you have provided\r\n * in the instance's options. Just provide the sort data key(s) as a string\r\n * (separated by space) and the items will be sorted based on the provided\r\n * sort data keys. Lastly you have the opportunity to provide a presorted\r\n * array of items which will be used to sync the internal items array in the\r\n * same order.\r\n *\r\n * @public\r\n * @memberof Grid.prototype\r\n * @param {(Function|Item[]|String|String[])} comparer\r\n * @param {Object} [options]\r\n * @param {Boolean} [options.descending=false]\r\n * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\r\n * @returns {Grid}\r\n */\n\nGrid.prototype.sort = function () {\n  var sortComparer = void 0;\n  var isDescending = void 0;\n  var origItems = void 0;\n  var indexMap = void 0;\n\n  function parseCriteria(data) {\n    return data.trim().split(' ').map(function (val) {\n      return val.split(':');\n    });\n  }\n\n  function getIndexMap(items) {\n    var ret = {};\n\n    for (var i = 0; i < items.length; i++) {\n      ret[items[i]._id] = i;\n    }\n\n    return ret;\n  }\n\n  function compareIndices(itemA, itemB) {\n    var indexA = indexMap[itemA._id];\n    var indexB = indexMap[itemB._id];\n    return isDescending ? indexB - indexA : indexA - indexB;\n  }\n\n  function defaultComparer(a, b) {\n    var result = 0;\n    var criteriaName = void 0;\n    var criteriaOrder = void 0;\n    var valA = void 0;\n    var valB = void 0; // Loop through the list of sort criteria.\n\n    for (var i = 0; i < sortComparer.length; i++) {\n      // Get the criteria name, which should match an item's sort data key.\n      criteriaName = sortComparer[i][0];\n      criteriaOrder = sortComparer[i][1]; // Get items' cached sort values for the criteria. If the item has no sort\n      // data let's update the items sort data (this is a lazy load mechanism).\n\n      valA = (a._sortData ? a : a._refreshSortData())._sortData[criteriaName];\n      valB = (b._sortData ? b : b._refreshSortData())._sortData[criteriaName]; // Sort the items in descending order if defined so explicitly. Otherwise\n      // sort items in ascending order.\n\n      if (criteriaOrder === 'desc' || !criteriaOrder && isDescending) {\n        result = valB < valA ? -1 : valB > valA ? 1 : 0;\n      } else {\n        result = valA < valB ? -1 : valA > valB ? 1 : 0;\n      } // If we have -1 or 1 as the return value, let's return it immediately.\n\n\n      if (result) return result;\n    } // If values are equal let's compare the item indices to make sure we\n    // have a stable sort.\n\n\n    if (!result) {\n      if (!indexMap) indexMap = getIndexMap(origItems);\n      result = compareIndices(a, b);\n    }\n\n    return result;\n  }\n\n  function customComparer(a, b) {\n    var result = sortComparer(a, b); // If descending let's invert the result value.\n\n    if (isDescending && result) result = -result; // If we have a valid result (not zero) let's return it right away.\n\n    if (result) return result; // If result is zero let's compare the item indices to make sure we have a\n    // stable sort.\n\n    if (!indexMap) indexMap = getIndexMap(origItems);\n    return compareIndices(a, b);\n  }\n\n  return function (comparer, options) {\n    if (this._isDestroyed || this._items.length < 2) return this;\n    var items = this._items;\n    var opts = options || 0;\n    var layout = opts.layout ? opts.layout : opts.layout === undefined;\n    var i = void 0; // Setup parent scope data.\n\n    sortComparer = comparer;\n    isDescending = !!opts.descending;\n    origItems = items.slice(0);\n    indexMap = null; // If function is provided do a native array sort.\n\n    if (typeof sortComparer === 'function') {\n      items.sort(customComparer);\n    } // Otherwise if we got a string, let's sort by the sort data as provided in\n    // the instance's options.\n    else if (typeof sortComparer === 'string') {\n        sortComparer = parseCriteria(comparer);\n        items.sort(defaultComparer);\n      } // Otherwise if we got an array, let's assume it's a presorted array of the\n      // items and order the items based on it.\n      else if (Array.isArray(sortComparer)) {\n          if (sortComparer.length !== items.length) {\n            throw new Error('[' + namespace + '] sort reference items do not match with grid items.');\n          }\n\n          for (i = 0; i < items.length; i++) {\n            if (!sortComparer.includes(items[i])) {\n              throw new Error('[' + namespace + '] sort reference items do not match with grid items.');\n            }\n\n            items[i] = sortComparer[i];\n          }\n\n          if (isDescending) items.reverse();\n        } // Otherwise let's just skip it, nothing we can do here.\n        else {\n            /** @todo Maybe throw an error here? */\n            return this;\n          } // Emit sort event.\n\n\n    if (this._hasListeners(eventSort)) {\n      this._emit(eventSort, items.slice(0), origItems);\n    } // If layout is needed.\n\n\n    if (layout) {\n      this.layout(layout === 'instant', typeof layout === 'function' ? layout : undefined);\n    }\n\n    return this;\n  };\n}();\n/**\r\n * Private helpers\r\n * ***************\r\n */\n\n/**\r\n * Merge default settings with user settings. The returned object is a new\r\n * object with merged values. The merging is a deep merge meaning that all\r\n * objects and arrays within the provided settings objects will be also merged\r\n * so that modifying the values of the settings object will have no effect on\r\n * the returned object.\r\n *\r\n * @param {Object} defaultSettings\r\n * @param {Object} [userSettings]\r\n * @returns {Object} Returns a new object.\r\n */\n\n\nfunction mergeSettings(defaultSettings, userSettings) {\n  // Create a fresh copy of default settings.\n  var ret = mergeObjects({}, defaultSettings); // Merge user settings to default settings.\n\n  if (userSettings) {\n    ret = mergeObjects(ret, userSettings);\n  } // Handle visible/hidden styles manually so that the whole object is\n  // overridden instead of the props.\n\n\n  ret.visibleStyles = (userSettings || 0).visibleStyles || (defaultSettings || 0).visibleStyles;\n  ret.hiddenStyles = (userSettings || 0).hiddenStyles || (defaultSettings || 0).hiddenStyles;\n  return ret;\n}\n/**\r\n * Merge two objects recursively (deep merge). The source object's properties\r\n * are merged to the target object.\r\n *\r\n * @param {Object} target\r\n *   - The target object.\r\n * @param {Object} source\r\n *   - The source object.\r\n * @returns {Object} Returns the target object.\r\n */\n\n\nfunction mergeObjects(target, source) {\n  var sourceKeys = Object.keys(source);\n  var length = sourceKeys.length;\n  var isSourceObject = void 0;\n  var propName = void 0;\n  var i = void 0;\n\n  for (i = 0; i < length; i++) {\n    propName = sourceKeys[i];\n    isSourceObject = isPlainObject(source[propName]); // If target and source values are both objects, merge the objects and\n    // assign the merged value to the target property.\n\n    if (isPlainObject(target[propName]) && isSourceObject) {\n      target[propName] = mergeObjects(mergeObjects({}, target[propName]), source[propName]);\n      continue;\n    } // If source's value is object and target's is not let's clone the object as\n    // the target's value.\n\n\n    if (isSourceObject) {\n      target[propName] = mergeObjects({}, source[propName]);\n      continue;\n    } // If source's value is an array let's clone the array as the target's\n    // value.\n\n\n    if (Array.isArray(source[propName])) {\n      target[propName] = source[propName].slice(0);\n      continue;\n    } // In all other cases let's just directly assign the source's value as the\n    // target's value.\n\n\n    target[propName] = source[propName];\n  }\n\n  return target;\n}\n\nvar MuuriGrid = function (_Component) {\n  inherits(MuuriGrid, _Component);\n\n  function MuuriGrid(props) {\n    classCallCheck(this, MuuriGrid);\n\n    var _this = possibleConstructorReturn(this, (MuuriGrid.__proto__ || Object.getPrototypeOf(MuuriGrid)).call(this, props));\n\n    _this.grid = new Grid(props.node, props.defaultOptions);\n    _this.getMethod = _this.getMethod.bind(_this);\n    _this.getEvent = _this.getEvent.bind(_this);\n    _this.getItemMethod = _this.getItemMethod.bind(_this);\n    return _this;\n  }\n\n  createClass(MuuriGrid, [{\n    key: 'getMethod',\n    value: function getMethod(method, param1, param2, param3, param4) {\n      try {\n        var result = void 0;\n\n        switch (method) {\n          case 'getElement':\n            result = this.grid.getElement();\n            break;\n\n          case 'getItems':\n            result = this.grid.getItems(param1);\n            break;\n\n          case 'refreshItems':\n            result = this.grid.refreshItems(param1);\n            break;\n\n          case 'refreshSortData':\n            result = this.grid.refreshSortData(param1);\n            break;\n\n          case 'synchronize':\n            result = this.grid.synchronize();\n            break;\n\n          case 'layout':\n            result = this.grid.layout(param1, param2);\n            break;\n\n          case 'add':\n            result = this.grid.add(param1, param2);\n            break;\n\n          case 'remove':\n            result = this.grid.remove(param1, param2);\n            break;\n\n          case 'show':\n            result = this.grid.show(param1, param2);\n            break;\n\n          case 'hide':\n            result = this.grid.hide(param1, param2);\n            break;\n\n          case 'filter':\n            result = this.grid.filter(param1, param2);\n            break;\n\n          case 'sort':\n            result = this.grid.sort(param1, param2);\n            break;\n\n          case 'move':\n            result = this.grid.move(param1, param2, param3);\n            break;\n\n          case 'send':\n            result = this.grid.send(param1, param2, param3, param4);\n            break;\n\n          case 'on':\n            result = this.grid.on(param1, param2);\n            break;\n\n          case 'once':\n            result = this.grid.once(param1, param2);\n            break;\n\n          case 'off':\n            result = this.grid.off(param1, param2);\n            break;\n\n          case 'destroy':\n            result = this.grid.destroy(param1);\n            break;\n\n          default:\n            result = null;\n            console.error('Invalid \\'Method\\' provided: ' + method);\n            console.error('Check the Muuri documentation for a list of valid methods.');\n            break;\n        }\n\n        return result;\n      } catch (error) {\n        console.error('The following error occured in \\'getMethod()\\': ' + error);\n      }\n    }\n  }, {\n    key: 'getEvent',\n    value: function getEvent(event, param1, param2, callback) {\n      var _this2 = this;\n\n      var eventsList = ['synchronize', 'layoutStart', 'layoutEnd', 'add', 'remove', 'showStart', 'showEnd', 'hideStart', 'hideEnd', 'filter', 'sort', 'move', 'send', 'beforeSend', 'receive', 'beforeReceive', 'dragInit', 'dragStart', 'dragMove', 'dragScroll', 'dragEnd', 'dragReleaseStart', 'dragReleaseEnd', 'destroy'];\n\n      if (event === undefined || event === null || eventsList.indexOf(event) === -1) {\n        console.error('Invalid event provided to \\'getEvent()\\': ' + event);\n      } else {\n        try {\n          this.grid.on(event, function (param1, param2) {\n            if (callback) {\n              callback(param1, param2);\n            }\n\n            _this2.grid.synchronize();\n          });\n        } catch (error) {\n          console.error('The following error occured in \\'getEvent()\\': ' + error);\n        }\n      }\n    }\n  }, {\n    key: 'getItemMethod',\n    value: function getItemMethod(method, item) {\n      try {\n        var result = void 0;\n\n        switch (method) {\n          case 'getGrid':\n            result = item.getGrid();\n            break;\n\n          case 'getElement':\n            result = item.getElement();\n            break;\n\n          case 'getWidth':\n            result = item.getWidth();\n            break;\n\n          case 'getHeight':\n            result = item.getHeight();\n            break;\n\n          case 'getMargin':\n            result = item.getMargin();\n            break;\n\n          case 'getPosition':\n            result = item.getPosition();\n            break;\n\n          case 'isActive':\n            result = item.isActive();\n            break;\n\n          case 'isVisible':\n            result = item.isVisible();\n            break;\n\n          case 'isShowing':\n            result = item.isShowing();\n            break;\n\n          case 'isHiding':\n            result = item.isHiding();\n            break;\n\n          case 'isPositioning':\n            result = item.isPositioning();\n            break;\n\n          case 'isDragging':\n            result = item.isDragging();\n            break;\n\n          case 'isReleasing':\n            result = item.isReleasing();\n            break;\n\n          case 'isDestroyed':\n            result = item.isDestroyed();\n            break;\n\n          default:\n            result = null;\n            console.error('Invalid \\'Item Event\\' provided: ' + method);\n            console.error('Check the Muuri documentation for a list of valid item events.');\n            break;\n        }\n\n        return result;\n      } catch (error) {\n        console.error('The following error occured in \\'getItemMethod()\\': ' + error);\n      }\n    }\n  }]);\n  return MuuriGrid;\n}(Component);\n\nMuuriGrid.propTypes = {\n  node: PropTypes.node.isRequired,\n  defaultOptions: PropTypes.object\n};\nexport default MuuriGrid;","map":{"version":3,"sources":["../src/shared.js","../src/Emitter/Emitter.js","../src/utils/supportedTransform.js","../src/utils/getStyle.js","../src/utils/getStyleName.js","../src/utils/setStyles.js","../src/Item/ItemAnimate.js","../node_modules/hammerjs/hammer.js","../src/Ticker/Ticker.js","../src/ticker.js","../src/utils/elementMatches.js","../src/utils/addClass.js","../src/utils/normalizeArrayIndex.js","../src/utils/arrayMove.js","../src/utils/arraySwap.js","../src/utils/debounce.js","../src/utils/isTransformed.js","../src/utils/getContainingBlock.js","../src/utils/getStyleAsFloat.js","../src/utils/getOffsetDiff.js","../src/utils/getTranslate.js","../src/utils/getTranslateString.js","../src/utils/arrayInsert.js","../src/utils/isPlainObject.js","../src/utils/removeClass.js","../src/Item/ItemDrag.js","../src/Queue/Queue.js","../src/Item/ItemLayout.js","../src/Item/ItemMigrate.js","../src/Item/ItemRelease.js","../src/utils/getCurrentStyles.js","../src/Item/ItemVisibility.js","../src/utils/createUid.js","../src/Item/Item.js","../src/Packer/Packer.js","../src/utils/isNodeList.js","../src/utils/toArray.js","../src/Grid/Grid.js","../src/index.js"],"names":["namespace","gridInstances","eventSynchronize","eventLayoutStart","eventLayoutEnd","eventAdd","eventRemove","eventShowStart","eventShowEnd","eventHideStart","eventHideEnd","eventFilter","eventSort","eventMove","eventSend","eventBeforeSend","eventReceive","eventBeforeReceive","eventDragInit","eventDragStart","eventDragMove","eventDragScroll","eventDragEnd","eventDragReleaseStart","eventDragReleaseEnd","eventDestroy","Emitter","Component","event","listener","listeners","callback","i","arg1","arg2","arg3","queue","qLength","aLength","arguments","events","isTransformSupported","transformStyle","transformProp","style","styleCap","propName","prefix","document","stylesCache","styles","window","styleNameRegEx","string","prop","ItemAnimate","propsFrom","propsTo","options","animation","currentProps","currentValues","opts","cancelAnimation","propCount","propIndex","animKeyframes","animOptions","element","propValue","getStyle","getStyleName","define","raf","Ticker","id","readCallback","writeCallback","isImportant","currentIndex","reads","writes","batch","batchReads","batchWrites","length","ticker","layoutTick","visibilityTick","moveTick","scrollTick","itemId","proto","Element","matches","elementMatches","array","maxIndex","Math","isMigration","index","from","normalizeArrayIndex","to","indexA","indexB","temp","actionCancel","actionFinish","timeout","wait","action","fn","transform","display","ret","includeSelf","isTransformed","parseFloat","offsetA","offsetB","offsetDiff","offsetData","rect","getStyleAsFloat","elemA","getContainingBlock","translateData","matrixData","tempArray","startIndex","objectType","toString","Object","hasTransformLeak","checkTransformLeak","startPredicateInactive","startPredicatePending","startPredicateResolved","startPredicateRejected","ItemDrag","drag","item","grid","settings","hammer","startPredicate","startPredicateState","startPredicateResult","Hammer","debounce","DIRECTION_ALL","isPlainObject","isResolved","getTranslateString","gridContainer","dragContainer","scrollers","containerScrollers","config","predicate","handleElement","pointer","pageX","pageY","handleRect","handleLeft","handleTop","handleWidth","handleHeight","isClick","openAnchorHref","result","currentGrid","targetGrid","targetIndex","sortAction","release","isActive","targetGridElement","targetSettings","targetContainer","currentSettings","currentContainer","translate","getOffsetDiff","getTranslate","migrate","containingBlock","currentLeft","currentTop","elementRect","hasDragContainer","axis","xDiff","yDiff","itemRect","targetRect","returnData","rootGridArray","target","dragSort","rootGrid","bestScore","gridScore","grids","Array","getRectOverlapScore","sortThreshold","getTargetGrid","gridOffsetLeft","gridOffsetTop","matchScore","matchIndex","hasValidTargets","score","e","a","b","width","height","maxWidth","maxHeight","data","parent","isScrollable","overflow","href","elems","isInner","outer","inner","left","Queue","singleCallback","snapshot","ItemLayout","instant","onFinish","gridSettings","isPositioning","isJustReleased","animDuration","animEasing","animEnabled","isAnimating","cancelLayoutTick","setStyles","processCallbackQueue","targetStyles","addClass","tempStyles","ItemMigrate","position","container","isVisible","targetElement","targetItems","targetItem","containerDiff","translateX","translateY","abort","currentStyles","gridElement","ItemRelease","current","ItemVisibility","toVisible","duration","parseInt","easing","isInstant","getCurrentStyles","finishStyles","Item","createUid","_marginBottom","_top","getters","removeElement","Packer","items","slots","layout","fillGaps","isHorizontal","alignRight","alignBottom","rounding","slotSizes","top","rectId","rectStore","rectItem","leeway","itemSlot","freeSlots","newSlots","potentialSlots","ignoreCurrentSlots","ii","results","hole","rectA","rectB","rectIds","htmlCollectionType","nodeListType","type","isNodeList","packer","Grid","inst","layoutOnResize","mergeSettings","targets","toArray","fragment","layoutId","itemsLength","counter","isCallbackFunction","callbackItems","isBorderBox","hasLayoutChanged","tryFinish","elements","newItems","needsLayout","allItems","indices","itemsToShow","itemsToHide","isPredicateString","isPredicateFn","tryFinishCounter","isSwap","fromItem","toItem","fromIndex","toIndex","layoutSender","layoutReceiver","removeElements","newLayout","Boolean","right","bottom","startEvent","endEvent","method","completedItems","hiddenItems","sortComparer","isDescending","origItems","indexMap","val","itemA","itemB","criteriaName","criteriaOrder","valA","valB","getIndexMap","compareIndices","parseCriteria","mergeObjects","userSettings","defaultSettings","sourceKeys","isSourceObject","source","MuuriGrid","propTypes","PropTypes","object","props","param1","param2","param3","param4","eventsList"],"mappings":";;AAAA;;;;;;AAMO,IAAMA,SAAAA,GAAN,OAAA;AACA,IAAMC,aAAAA,GAAN,EAAA;AAEA,IAAMC,gBAAAA,GAAN,aAAA;AACA,IAAMC,gBAAAA,GAAN,aAAA;AACA,IAAMC,cAAAA,GAAN,WAAA;AACA,IAAMC,QAAAA,GAAN,KAAA;AACA,IAAMC,WAAAA,GAAN,QAAA;AACA,IAAMC,cAAAA,GAAN,WAAA;AACA,IAAMC,YAAAA,GAAN,SAAA;AACA,IAAMC,cAAAA,GAAN,WAAA;AACA,IAAMC,YAAAA,GAAN,SAAA;AACA,IAAMC,WAAAA,GAAN,QAAA;AACA,IAAMC,SAAAA,GAAN,MAAA;AACA,IAAMC,SAAAA,GAAN,MAAA;AACA,IAAMC,SAAAA,GAAN,MAAA;AACA,IAAMC,eAAAA,GAAN,YAAA;AACA,IAAMC,YAAAA,GAAN,SAAA;AACA,IAAMC,kBAAAA,GAAN,eAAA;AACA,IAAMC,aAAAA,GAAN,UAAA;AACA,IAAMC,cAAAA,GAAN,WAAA;AACA,IAAMC,aAAAA,GAAN,UAAA;AACA,IAAMC,eAAAA,GAAN,YAAA;AACA,IAAMC,YAAAA,GAAN,SAAA;AACA,IAAMC,qBAAAA,GAAN,kBAAA;AACA,IAAMC,mBAAAA,GAAN,gBAAA;AACA,IAAMC,YAAAA,GAAN,SAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChCP;;;;;;;;;;;;;;IAaMC,OAAAA,GAAAA,UAAAA,UAAAA,EAAAA;;;qBACU;;;;;UAEZ,O,GAAA,E;UACA,M,GAAA,E;UACA,Q,GAAA,C;UACA,Y,GAAA,K;;;;;;;;;;;;;;;;;;;;;uBAiBCE,K,EAAOC,Q,EAAU;UACd,KAAJ,Y,EAAuB,OAAA,IAAA,CADL,C;;UAIdC,SAAAA,GAAY,KAAA,OAAA,CAAhB,KAAgB,C;UACZ,CAAJ,S,EAAgBA,SAAAA,GAAY,KAAA,OAAA,CAAA,KAAA,IAAZA,EAAAA,CALE,C;;gBAQlB,I,CAAA,Q;aAEA,I;;;;;;;;;;;;;;yBAYGF,K,EAAOC,Q,EAAU;UAChB,KAAJ,Y,EAAuB,OAAA,IAAA;;UAEjBE,QAAAA,GAAW,YAAW;aAC1B,G,CAAA,K,EAAA,Q;kCACA,S;AAFe,OAAA,CAAA,IAAA,CAAjB,IAAiB,C;;aAKV,KAAA,EAAA,CAAA,KAAA,EAAP,QAAO,C;;;;;;;;;;;;;;wBAYLH,K,EAAOC,Q,EAAU;UACf,KAAJ,Y,EAAuB,OAAA,IAAA,CADJ,C;;UAIbC,SAAAA,GAAY,KAAA,OAAA,CAAlB,KAAkB,C;UACd,CAAA,SAAA,IAAc,CAACA,SAAAA,CAAnB,M,EAAqC,OAAA,IAAA,CALlB,C;;UAQf,CAAJ,Q,EAAe;kBACb,M,GAAA,C;eACA,I;OAViB,C;;;UAcfE,CAAAA,GAAIF,SAAAA,CAAR,M;;aACOE,CAAP,E,EAAY;YACNH,QAAAA,KAAaC,SAAAA,CAAjB,CAAiBA,C,EAAcA,SAAAA,CAAAA,MAAAA,CAAAA,CAAAA,EAAAA,CAAAA;;;aAGjC,I;;;;;;;;;;;;;;;;yBAcGF,K,EAAOK,I,EAAMC,I,EAAMC,I,EAAM;UACxB,KAAJ,Y,EAAuB,OAAA,IAAA,CADK,C;;UAItBL,SAAAA,GAAY,KAAA,OAAA,CAAlB,KAAkB,C;UACd,CAAA,SAAA,IAAc,CAACA,SAAAA,CAAnB,M,EAAqC,OAAA,IAAA;UAE/BM,KAAAA,GAAQ,KAAd,M;UACIC,OAAAA,GAAUD,KAAAA,CAAd,M;UACME,OAAAA,GAAUC,SAAAA,CAAAA,MAAAA,GAAhB,C;UACIP,CAAAA,GAAAA,KAAJ,C,CAV4B,C;;;;;WAgBvBA,CAAAA,GAAL,C,EAAYA,CAAAA,GAAIF,SAAAA,CAAhB,M,EAAkCE,CAAlC,E,EAAuC;cACrC,I,CAAWF,SAAAA,CAAX,CAAWA,C;OAjBe,C;;;;;;QAwB1B,KAAF,Q,CAxB4B,C;;WA2BvBE,CAAAA,GAAAA,OAAAA,EAAaK,OAAAA,GAAUD,KAAAA,CAA5B,M,EAA0CJ,CAAAA,GAA1C,O,EAAuDA,CAAvD,E,EAA4D;;oBAE1D,C,GAAgBI,KAAAA,CAAhB,CAAgBA,CAAAA,E,GAAhB;oBACA,C,GAAgBA,KAAAA,CAAAA,CAAAA,CAAAA,CAAhB,IAAgBA,C,GAAhB;oBACA,C,GAAgBA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,EAAhB,IAAgBA,C,GAAhB;cACgB,C,EAAA,I,EAAA,I,EAL0C,I,EAAA,CAAA;;;YAQtD,KAAJ,Y,EAAuB,OAAA,IAAA;OAnCG,C;;;QAuC1B,KAAF,Q,CAvC4B,C;;UA0CxB,CAAC,KAAL,Q,EAAoBA,KAAAA,CAAAA,MAAAA,GAAAA,CAAAA;aAEpB,I;;;;;;;;;;;;8BAUQ;UACJ,KAAJ,Y,EAAuB,OAAA,IAAA;UAEjBI,MAAAA,GAAS,KAAf,O;UACIZ,KAAAA,GAAAA,KAAJ,C,CAJQ,C;;WAOR,Y,GAAA,I,CAPQ,C;;WAUR,M,CAAA,M,GAAqB,KAAA,QAAA,GAArB,C,CAVQ,C;;WAaR,K,IAAA,M,EAAsB;YAChBY,MAAAA,CAAJ,KAAIA,C,EAAe;iBACjB,K,EAAA,M,GAAA,C;iBACA,K,IAAA,S;;;;aAIJ,I;;;;CA5KEd,CAAgBC,SAAhBD,C;ACbN;;;;;;;;AAOO,IAAIe,oBAAAA,GAAJ,KAAA;AACA,IAAIC,cAAAA,GAAJ,WAAA;AACA,IAAIC,aAAAA,GAAJ,WAAA,C;;AAGP,IAAMC,KAAAA,GAAN,WAAA;AACA,IAAMC,QAAAA,GAAN,WAAA;AACA,CAAA,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,GAAA,EAAA,IAAA,EAAA,OAAA,CAAyC,UAAA,MAAA,EAAiB;MACxD,oB,EAA0B;MACpBC,QAAAA,GAAWC,MAAAA,GAASA,MAAAA,GAATA,QAAAA,GAAjB,K;;MACIC,QAAAA,CAAAA,eAAAA,CAAAA,KAAAA,CAAAA,QAAAA,MAAJ,S,EAA4D;aACjDD,MAAAA,CAAT,WAASA,E;qBACQA,MAAAA,GAAS,MAAA,MAAA,GAAA,GAAA,GAATA,KAAAA,GAAjB,K;oBACA,Q;2BACA,I;;AAPJ,CAAA;ACdA;;;;;;AAQA,IAAME,WAAAA,GAAc,OAAA,OAAA,KAAA,UAAA,GAAgC,IAAhC,OAAgC,EAAhC,GAApB,IAAA;;;;;;;;;AASe,SAAA,QAAA,CAAA,OAAA,EAAA,KAAA,EAAkC;MAC3CC,MAAAA,GAASD,WAAAA,IAAeA,WAAAA,CAAAA,GAAAA,CAA5B,OAA4BA,C;;MACxB,CAAJ,M,EAAa;aACFE,MAAAA,CAAAA,gBAAAA,CAAAA,OAAAA,EAAT,IAASA,C;mBACMF,WAAAA,CAAAA,GAAAA,CAAAA,OAAAA,EAAf,MAAeA,C;;;SAEVC,MAAAA,CAAAA,gBAAAA,CAAwBN,KAAAA,KAAAA,WAAAA,GAAAA,cAAAA,GAA/B,KAAOM,C;;ACvBT;;;;;;;AAMA,IAAME,cAAAA,GAAN,UAAA;;;;;;;;AAQe,SAAA,YAAA,CAAA,MAAA,EAA8B;SACpCC,MAAAA,CAAAA,OAAAA,CAAAA,cAAAA,EAAAA,KAAAA,EAAP,WAAOA,E;;ACfT;;;;;;;;;;;;;;AAce,SAAA,SAAA,CAAA,OAAA,EAAA,MAAA,EAAoC;OAC5C,IAAL,I,IAAA,M,EAA2B;YACzB,K,CAAcC,IAAAA,KAAAA,WAAAA,GAAAA,aAAAA,GAAd,I,IAA6DJ,MAAAA,CAA7D,IAA6DA,C;;;AChBjE;;;;;;;;;;;;;;IAmBMK,WAAAA,GAAAA,UAAAA,UAAAA,EAAAA;;;uBACJ,O,EAAqB;;;yHAAA,O;;UAEnB,Q,GAAA,O;UACA,U,GAAA,I;UACA,S,GAAA,I;UACA,M,GAAA,E;UACA,O,GAAA,E;UACA,U,GAAA,E;UACA,Q,GAAA,E;UACA,Y,GAAA,K;UACA,S,GAAiB,KAAA,CAAA,SAAA,CAAA,IAAA,CAAjB,KAAiB,C;;;;;;;;;;;;;;;;;;;;;;;;;0BAqBbC,S,EAAWC,O,EAASC,O,EAAS;UAC7B,KAAJ,Y,EAAuB;UAEnBC,SAAAA,GAAY,KAAhB,U;UACMC,YAAAA,GAAe,KAArB,M;UACMC,aAAAA,GAAgB,KAAtB,O;UACMC,IAAAA,GAAOJ,OAAAA,IAAb,C;UACIK,eAAAA,GAAJ,K,CAPiC,C;;;UAWjC,S,EAAe;YACTC,SAAAA,GAAJ,C;YACIC,SAAAA,GAAAA,KAAJ,C,CAFa,C;;;aAMR,IAAL,Q,IAAA,O,EAAgC;YAC9B,S;sBACYL,YAAAA,CAAAA,OAAAA,CAAZ,QAAYA,C;;cACRK,SAAAA,KAAc,CAAdA,CAAAA,IAAoBR,OAAAA,CAAAA,QAAAA,CAAAA,KAAsBI,aAAAA,CAA9C,SAA8CA,C,EAA0B;8BACtE,I;;;SAVS,C;;;;;;YAmBT,CAAA,eAAA,IAAoBG,SAAAA,KAAcJ,YAAAA,CAAtC,M,EAA2D;4BACzD,I;;OA/B6B,C;;;UAoCjC,e,EAAqBD,SAAAA,CAAAA,MAAAA,GApCY,C;;WAuCjC,S,GAAiB,OAAOG,IAAAA,CAAP,QAAA,KAAA,UAAA,GAAsCA,IAAAA,CAAtC,QAAA,GAAjB,I,CAvCiC,C;;;UA2C7BH,SAAAA,IAAa,CAAjB,e,EAAmC,OA3CF,C;;mBA8CjC,M,GAAsBE,aAAAA,CAAAA,MAAAA,GAAtB,C;;WACK,IAAL,S,IAAA,O,EAAgC;qBAC9B,I,CAAA,S;sBACA,I,CAAmBJ,OAAAA,CAAnB,SAAmBA,C;OAjDY,C;;;UAqD3BS,aAAAA,GAAgB,KAAtB,U;oBACA,C,IAAA,S;oBACA,C,IAAA,O,CAvDiC,C;;UA0D3BC,WAAAA,GAAc,KAApB,Q;kBACA,Q,GAAuBL,IAAAA,CAAAA,QAAAA,IAAvB,G;kBACA,M,GAAqBA,IAAAA,CAAAA,MAAAA,IAArB,M,CA5DiC,C;;UA+D3BM,OAAAA,GAAU,KAAhB,Q;kBACYA,OAAAA,CAAAA,OAAAA,CAAAA,aAAAA,EAAZ,WAAYA,C;gBACZ,Q,GAAqB,KAArB,S;WACA,U,GAAA,S,CAlEiC,C;;;gBAsEjC,O,EAAA,O;;;;;;;;;;;;yBAUGlB,M,EAAQ;UACP,KAAA,YAAA,IAAqB,CAAC,KAA1B,U,EAA2C;UAErCkB,OAAAA,GAAU,KAAhB,Q;UACMR,YAAAA,GAAe,KAArB,M;UACMC,aAAAA,GAAgB,KAAtB,O;UACIf,QAAAA,GAAAA,KAAJ,C;UACIuB,SAAAA,GAAAA,KAAJ,C;UACIrC,CAAAA,GAAAA,KAAJ,C,CARW,C;;UAWP,CAAJ,M,EAAa;aACNA,CAAAA,GAAL,C,EAAYA,CAAAA,GAAI4B,YAAAA,CAAhB,M,EAAqC5B,CAArC,E,EAA0C;qBAC7B4B,YAAAA,CAAX,CAAWA,C;sBACCU,QAAAA,CAAAA,OAAAA,EAAkBC,YAAAA,CAA9B,QAA8BA,CAAlBD,C;kBACZ,K,CAAcxB,QAAAA,KAAAA,WAAAA,GAAAA,aAAAA,GAAd,Q,IAAA,S;;AAJJ,O,MAMO;kBACL,O,EAAA,M;OAlBS,C;;;WAsBX,U,CAAA,M;;WACA,U,GAAkB,KAAA,SAAA,GAAlB,I,CAvBW,C;;mBA0BX,M,GAAsBe,aAAAA,CAAAA,MAAAA,GAAtB,C;;;;;;;;;;;;kCAUY;aACL,CAAC,CAAC,KAAT,U;;;;;;;;;;;8BASQ;UACJ,KAAJ,Y,EAAuB;WACvB,I;WACA,Q,GAAgB,KAAA,QAAA,GAAgB,KAAA,UAAA,GAAhC,I;WACA,Y,GAAA,I;;;;;;;;;;;;;;;;gCAcU;UACJ9B,QAAAA,GAAW,KAAjB,S;WACA,U,GAAkB,KAAA,SAAA,GAAlB,I;WACA,M,CAAA,M,GAAqB,KAAA,OAAA,CAAA,MAAA,GAArB,C;kBACYA,QAAZ,E;;;;CApLEwB,CAAoB5B,SAApB4B,C;;;;;;;;;;;;;;ACdN,GAAC,UAAS,MAAT,EAAiB,QAAjB,EAA2B,UAA3B,EAAuC,SAAvC,EAAkD;AAGnD,QAAI,eAAe,GAAG,CAAC,EAAD,EAAK,QAAL,EAAe,KAAf,EAAsB,IAAtB,EAA4B,IAA5B,EAAkC,GAAlC,CAAtB;AACA,QAAI,YAAY,GAAG,QAAQ,CAAC,aAAT,CAAuB,KAAvB,CAAnB;AAEA,QAAI,aAAa,GAAG,UAApB;AAEA,QAAI,KAAK,GAAG,IAAI,CAAC,KAAjB;AACA,QAAI,GAAG,GAAG,IAAI,CAAC,GAAf;AACA,QAAI,GAAG,GAAG,IAAI,CAAC,GAAf;;;;;;;;;AASA,aAAS,iBAAT,CAA2B,EAA3B,EAA+B,OAA/B,EAAwC,OAAxC,EAAiD;AAC7C,aAAO,UAAU,CAAC,MAAM,CAAC,EAAD,EAAK,OAAL,CAAP,EAAsB,OAAtB,CAAjB;AACH;;;;;;;;;;;;AAWD,aAAS,cAAT,CAAwB,GAAxB,EAA6B,EAA7B,EAAiC,OAAjC,EAA0C;AACtC,UAAI,KAAK,CAAC,OAAN,CAAc,GAAd,CAAJ,EAAwB;AACpB,QAAA,IAAI,CAAC,GAAD,EAAM,OAAO,CAAC,EAAD,CAAb,EAAmB,OAAnB,CAAJ;AACA,eAAO,IAAP;AACH;;AACD,aAAO,KAAP;AACH;;;;;;;;;AAQD,aAAS,IAAT,CAAc,GAAd,EAAmB,QAAnB,EAA6B,OAA7B,EAAsC;AAClC,UAAI,CAAJ;;AAEA,UAAI,CAAC,GAAL,EAAU;AACN;AACH;;AAED,UAAI,GAAG,CAAC,OAAR,EAAiB;AACb,QAAA,GAAG,CAAC,OAAJ,CAAY,QAAZ,EAAsB,OAAtB;AACH,OAFD,MAEO,IAAI,GAAG,CAAC,MAAJ,KAAe,SAAnB,EAA8B;AACjC,QAAA,CAAC,GAAG,CAAJ;;AACA,eAAO,CAAC,GAAG,GAAG,CAAC,MAAf,EAAuB;AACnB,UAAA,QAAQ,CAAC,IAAT,CAAc,OAAd,EAAuB,GAAG,CAAC,CAAD,CAA1B,EAA+B,CAA/B,EAAkC,GAAlC;AACA,UAAA,CAAC;AACJ;AACJ,OANM,MAMA;AACH,aAAK,CAAL,IAAU,GAAV,EAAe;AACX,UAAA,GAAG,CAAC,cAAJ,CAAmB,CAAnB,KAAyB,QAAQ,CAAC,IAAT,CAAc,OAAd,EAAuB,GAAG,CAAC,CAAD,CAA1B,EAA+B,CAA/B,EAAkC,GAAlC,CAAzB;AACH;AACJ;AACJ;;;;;;;;;;AASD,aAAS,SAAT,CAAmB,MAAnB,EAA2B,IAA3B,EAAiC,OAAjC,EAA0C;AACtC,UAAI,kBAAkB,GAAG,wBAAwB,IAAxB,GAA+B,IAA/B,GAAsC,OAAtC,GAAgD,QAAzE;AACA,aAAO,YAAW;AACd,YAAI,CAAC,GAAG,IAAI,KAAJ,CAAU,iBAAV,CAAR;AACA,YAAI,KAAK,GAAG,CAAC,IAAI,CAAC,CAAC,KAAP,GAAe,CAAC,CAAC,KAAF,CAAQ,OAAR,CAAgB,iBAAhB,EAAmC,EAAnC,EACtB,OADsB,CACd,aADc,EACC,EADD,EAEtB,OAFsB,CAEd,4BAFc,EAEgB,gBAFhB,CAAf,GAEmD,qBAF/D;AAIA,YAAI,GAAG,GAAG,MAAM,CAAC,OAAP,KAAmB,MAAM,CAAC,OAAP,CAAe,IAAf,IAAuB,MAAM,CAAC,OAAP,CAAe,GAAzD,CAAV;;AACA,YAAI,GAAJ,EAAS;AACL,UAAA,GAAG,CAAC,IAAJ,CAAS,MAAM,CAAC,OAAhB,EAAyB,kBAAzB,EAA6C,KAA7C;AACH;;AACD,eAAO,MAAM,CAAC,KAAP,CAAa,IAAb,EAAmB,SAAnB,CAAP;AACH,OAXD;AAYH;;;;;;;;;;AASD,QAAI,MAAJ;;AACA,QAAI,OAAO,MAAM,CAAC,MAAd,KAAyB,UAA7B,EAAyC;AACrC,MAAA,MAAM,GAAG,SAAS,MAAT,CAAgB,MAAhB,EAAwB;AAC7B,YAAI,MAAM,KAAK,SAAX,IAAwB,MAAM,KAAK,IAAvC,EAA6C;AACzC,gBAAM,IAAI,SAAJ,CAAc,4CAAd,CAAN;AACH;;AAED,YAAI,MAAM,GAAG,MAAM,CAAC,MAAD,CAAnB;;AACA,aAAK,IAAI,KAAK,GAAG,CAAjB,EAAoB,KAAK,GAAG,SAAS,CAAC,MAAtC,EAA8C,KAAK,EAAnD,EAAuD;AACnD,cAAI,MAAM,GAAG,SAAS,CAAC,KAAD,CAAtB;;AACA,cAAI,MAAM,KAAK,SAAX,IAAwB,MAAM,KAAK,IAAvC,EAA6C;AACzC,iBAAK,IAAI,OAAT,IAAoB,MAApB,EAA4B;AACxB,kBAAI,MAAM,CAAC,cAAP,CAAsB,OAAtB,CAAJ,EAAoC;AAChC,gBAAA,MAAM,CAAC,OAAD,CAAN,GAAkB,MAAM,CAAC,OAAD,CAAxB;AACH;AACJ;AACJ;AACJ;;AACD,eAAO,MAAP;AACH,OAjBD;AAkBH,KAnBD,MAmBO;AACH,MAAA,MAAM,GAAG,MAAM,CAAC,MAAhB;AACH;;;;;;;;;;;AAUD,QAAI,MAAM,GAAG,SAAS,CAAC,SAAS,MAAT,CAAgB,IAAhB,EAAsB,GAAtB,EAA2B,KAA3B,EAAkC;AACrD,UAAI,IAAI,GAAG,MAAM,CAAC,IAAP,CAAY,GAAZ,CAAX;AACA,UAAI,CAAC,GAAG,CAAR;;AACA,aAAO,CAAC,GAAG,IAAI,CAAC,MAAhB,EAAwB;AACpB,YAAI,CAAC,KAAD,IAAW,KAAK,IAAI,IAAI,CAAC,IAAI,CAAC,CAAD,CAAL,CAAJ,KAAkB,SAA1C,EAAsD;AAClD,UAAA,IAAI,CAAC,IAAI,CAAC,CAAD,CAAL,CAAJ,GAAgB,GAAG,CAAC,IAAI,CAAC,CAAD,CAAL,CAAnB;AACH;;AACD,QAAA,CAAC;AACJ;;AACD,aAAO,IAAP;AACH,KAVqB,EAUnB,QAVmB,EAUT,eAVS,CAAtB;;;;;;;;;AAmBA,QAAI,KAAK,GAAG,SAAS,CAAC,SAAS,KAAT,CAAe,IAAf,EAAqB,GAArB,EAA0B;AAC5C,aAAO,MAAM,CAAC,IAAD,EAAO,GAAP,EAAY,IAAZ,CAAb;AACH,KAFoB,EAElB,OAFkB,EAET,eAFS,CAArB;;;;;;;;AAUA,aAAS,OAAT,CAAiB,KAAjB,EAAwB,IAAxB,EAA8B,UAA9B,EAA0C;AACtC,UAAI,KAAK,GAAG,IAAI,CAAC,SAAjB;AAAA,UACI,MADJ;AAGA,MAAA,MAAM,GAAG,KAAK,CAAC,SAAN,GAAkB,MAAM,CAAC,MAAP,CAAc,KAAd,CAA3B;AACA,MAAA,MAAM,CAAC,WAAP,GAAqB,KAArB;AACA,MAAA,MAAM,CAAC,MAAP,GAAgB,KAAhB;;AAEA,UAAI,UAAJ,EAAgB;AACZ,QAAA,MAAM,CAAC,MAAD,EAAS,UAAT,CAAN;AACH;AACJ;;;;;;;;;AAQD,aAAS,MAAT,CAAgB,EAAhB,EAAoB,OAApB,EAA6B;AACzB,aAAO,SAAS,OAAT,GAAmB;AACtB,eAAO,EAAE,CAAC,KAAH,CAAS,OAAT,EAAkB,SAAlB,CAAP;AACH,OAFD;AAGH;;;;;;;;;;AASD,aAAS,QAAT,CAAkB,GAAlB,EAAuB,IAAvB,EAA6B;AACzB,UAAI,OAAO,GAAP,IAAc,aAAlB,EAAiC;AAC7B,eAAO,GAAG,CAAC,KAAJ,CAAU,IAAI,GAAG,IAAI,CAAC,CAAD,CAAJ,IAAW,SAAd,GAA0B,SAAxC,EAAmD,IAAnD,CAAP;AACH;;AACD,aAAO,GAAP;AACH;;;;;;;;;AAQD,aAAS,WAAT,CAAqB,IAArB,EAA2B,IAA3B,EAAiC;AAC7B,aAAQ,IAAI,KAAK,SAAV,GAAuB,IAAvB,GAA8B,IAArC;AACH;;;;;;;;;AAQD,aAAS,iBAAT,CAA2B,MAA3B,EAAmC,KAAnC,EAA0C,OAA1C,EAAmD;AAC/C,MAAA,IAAI,CAAC,QAAQ,CAAC,KAAD,CAAT,EAAkB,UAAS,IAAT,EAAe;AACjC,QAAA,MAAM,CAAC,gBAAP,CAAwB,IAAxB,EAA8B,OAA9B,EAAuC,KAAvC;AACH,OAFG,CAAJ;AAGH;;;;;;;;;AAQD,aAAS,oBAAT,CAA8B,MAA9B,EAAsC,KAAtC,EAA6C,OAA7C,EAAsD;AAClD,MAAA,IAAI,CAAC,QAAQ,CAAC,KAAD,CAAT,EAAkB,UAAS,IAAT,EAAe;AACjC,QAAA,MAAM,CAAC,mBAAP,CAA2B,IAA3B,EAAiC,OAAjC,EAA0C,KAA1C;AACH,OAFG,CAAJ;AAGH;;;;;;;;;;AASD,aAAS,SAAT,CAAmB,IAAnB,EAAyB,MAAzB,EAAiC;AAC7B,aAAO,IAAP,EAAa;AACT,YAAI,IAAI,IAAI,MAAZ,EAAoB;AAChB,iBAAO,IAAP;AACH;;AACD,QAAA,IAAI,GAAG,IAAI,CAAC,UAAZ;AACH;;AACD,aAAO,KAAP;AACH;;;;;;;;;AAQD,aAAS,KAAT,CAAe,GAAf,EAAoB,IAApB,EAA0B;AACtB,aAAO,GAAG,CAAC,OAAJ,CAAY,IAAZ,IAAoB,CAAC,CAA5B;AACH;;;;;;;;AAOD,aAAS,QAAT,CAAkB,GAAlB,EAAuB;AACnB,aAAO,GAAG,CAAC,IAAJ,GAAW,KAAX,CAAiB,MAAjB,CAAP;AACH;;;;;;;;;;AASD,aAAS,OAAT,CAAiB,GAAjB,EAAsB,IAAtB,EAA4B,SAA5B,EAAuC;AACnC,UAAI,GAAG,CAAC,OAAJ,IAAe,CAAC,SAApB,EAA+B;AAC3B,eAAO,GAAG,CAAC,OAAJ,CAAY,IAAZ,CAAP;AACH,OAFD,MAEO;AACH,YAAI,CAAC,GAAG,CAAR;;AACA,eAAO,CAAC,GAAG,GAAG,CAAC,MAAf,EAAuB;AACnB,cAAK,SAAS,IAAI,GAAG,CAAC,CAAD,CAAH,CAAO,SAAP,KAAqB,IAAnC,IAA6C,CAAC,SAAD,IAAc,GAAG,CAAC,CAAD,CAAH,KAAW,IAA1E,EAAiF;AAC7E,mBAAO,CAAP;AACH;;AACD,UAAA,CAAC;AACJ;;AACD,eAAO,CAAC,CAAR;AACH;AACJ;;;;;;;;AAOD,aAAS,OAAT,CAAiB,GAAjB,EAAsB;AAClB,aAAO,KAAK,CAAC,SAAN,CAAgB,KAAhB,CAAsB,IAAtB,CAA2B,GAA3B,EAAgC,CAAhC,CAAP;AACH;;;;;;;;;;AASD,aAAS,WAAT,CAAqB,GAArB,EAA0B,GAA1B,EAA+B,IAA/B,EAAqC;AACjC,UAAI,OAAO,GAAG,EAAd;AACA,UAAI,MAAM,GAAG,EAAb;AACA,UAAI,CAAC,GAAG,CAAR;;AAEA,aAAO,CAAC,GAAG,GAAG,CAAC,MAAf,EAAuB;AACnB,YAAI,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC,CAAD,CAAH,CAAO,GAAP,CAAH,GAAiB,GAAG,CAAC,CAAD,CAAjC;;AACA,YAAI,OAAO,CAAC,MAAD,EAAS,GAAT,CAAP,GAAuB,CAA3B,EAA8B;AAC1B,UAAA,OAAO,CAAC,IAAR,CAAa,GAAG,CAAC,CAAD,CAAhB;AACH;;AACD,QAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACA,QAAA,CAAC;AACJ;;AAED,UAAI,IAAJ,EAAU;AACN,YAAI,CAAC,GAAL,EAAU;AACN,UAAA,OAAO,GAAG,OAAO,CAAC,IAAR,EAAV;AACH,SAFD,MAEO;AACH,UAAA,OAAO,GAAG,OAAO,CAAC,IAAR,CAAa,SAAS,eAAT,CAAyB,CAAzB,EAA4B,CAA5B,EAA+B;AAClD,mBAAO,CAAC,CAAC,GAAD,CAAD,GAAS,CAAC,CAAC,GAAD,CAAjB;AACH,WAFS,CAAV;AAGH;AACJ;;AAED,aAAO,OAAP;AACH;;;;;;;;;AAQD,aAAS,QAAT,CAAkB,GAAlB,EAAuB,QAAvB,EAAiC;AAC7B,UAAI,MAAJ,EAAY,IAAZ;AACA,UAAI,SAAS,GAAG,QAAQ,CAAC,CAAD,CAAR,CAAY,WAAZ,KAA4B,QAAQ,CAAC,KAAT,CAAe,CAAf,CAA5C;AAEA,UAAI,CAAC,GAAG,CAAR;;AACA,aAAO,CAAC,GAAG,eAAe,CAAC,MAA3B,EAAmC;AAC/B,QAAA,MAAM,GAAG,eAAe,CAAC,CAAD,CAAxB;AACA,QAAA,IAAI,GAAI,MAAD,GAAW,MAAM,GAAG,SAApB,GAAgC,QAAvC;;AAEA,YAAI,IAAI,IAAI,GAAZ,EAAiB;AACb,iBAAO,IAAP;AACH;;AACD,QAAA,CAAC;AACJ;;AACD,aAAO,SAAP;AACH;;;;;;;AAMD,QAAI,SAAS,GAAG,CAAhB;;AACA,aAAS,QAAT,GAAoB;AAChB,aAAO,SAAS,EAAhB;AACH;;;;;;;;AAOD,aAAS,mBAAT,CAA6B,OAA7B,EAAsC;AAClC,UAAI,GAAG,GAAG,OAAO,CAAC,aAAR,IAAyB,OAAnC;AACA,aAAQ,GAAG,CAAC,WAAJ,IAAmB,GAAG,CAAC,YAAvB,IAAuC,MAA/C;AACH;;AAED,QAAI,YAAY,GAAG,uCAAnB;AAEA,QAAI,aAAa,IAAI,kBAAkB,MAAtB,CAAjB;AACA,QAAI,sBAAsB,GAAG,QAAQ,CAAC,MAAD,EAAS,cAAT,CAAR,KAAqC,SAAlE;AACA,QAAI,kBAAkB,GAAG,aAAa,IAAI,YAAY,CAAC,IAAb,CAAkB,SAAS,CAAC,SAA5B,CAA1C;AAEA,QAAI,gBAAgB,GAAG,OAAvB;AACA,QAAI,cAAc,GAAG,KAArB;AACA,QAAI,gBAAgB,GAAG,OAAvB;AACA,QAAI,iBAAiB,GAAG,QAAxB;AAEA,QAAI,gBAAgB,GAAG,EAAvB;AAEA,QAAI,WAAW,GAAG,CAAlB;AACA,QAAI,UAAU,GAAG,CAAjB;AACA,QAAI,SAAS,GAAG,CAAhB;AACA,QAAI,YAAY,GAAG,CAAnB;AAEA,QAAI,cAAc,GAAG,CAArB;AACA,QAAI,cAAc,GAAG,CAArB;AACA,QAAI,eAAe,GAAG,CAAtB;AACA,QAAI,YAAY,GAAG,CAAnB;AACA,QAAI,cAAc,GAAG,EAArB;AAEA,QAAI,oBAAoB,GAAG,cAAc,GAAG,eAA5C;AACA,QAAI,kBAAkB,GAAG,YAAY,GAAG,cAAxC;AACA,QAAI,aAAa,GAAG,oBAAoB,GAAG,kBAA3C;AAEA,QAAI,QAAQ,GAAG,CAAC,GAAD,EAAM,GAAN,CAAf;AACA,QAAI,eAAe,GAAG,CAAC,SAAD,EAAY,SAAZ,CAAtB;;;;;;;;;AASA,aAAS,KAAT,CAAe,OAAf,EAAwB,QAAxB,EAAkC;AAC9B,UAAI,IAAI,GAAG,IAAX;AACA,WAAK,OAAL,GAAe,OAAf;AACA,WAAK,QAAL,GAAgB,QAAhB;AACA,WAAK,OAAL,GAAe,OAAO,CAAC,OAAvB;AACA,WAAK,MAAL,GAAc,OAAO,CAAC,OAAR,CAAgB,WAA9B,CAL8B,C;;;AAS9B,WAAK,UAAL,GAAkB,UAAS,EAAT,EAAa;AAC3B,YAAI,QAAQ,CAAC,OAAO,CAAC,OAAR,CAAgB,MAAjB,EAAyB,CAAC,OAAD,CAAzB,CAAZ,EAAiD;AAC7C,UAAA,IAAI,CAAC,OAAL,CAAa,EAAb;AACH;AACJ,OAJD;;AAMA,WAAK,IAAL;AAEH;;AAED,IAAA,KAAK,CAAC,SAAN,GAAkB;;;;;AAKd,MAAA,OAAO,EAAE,YAAW,CAAG,CALT;;;;;AAUd,MAAA,IAAI,EAAE,YAAW;AACb,aAAK,IAAL,IAAa,iBAAiB,CAAC,KAAK,OAAN,EAAe,KAAK,IAApB,EAA0B,KAAK,UAA/B,CAA9B;AACA,aAAK,QAAL,IAAiB,iBAAiB,CAAC,KAAK,MAAN,EAAc,KAAK,QAAnB,EAA6B,KAAK,UAAlC,CAAlC;AACA,aAAK,KAAL,IAAc,iBAAiB,CAAC,mBAAmB,CAAC,KAAK,OAAN,CAApB,EAAoC,KAAK,KAAzC,EAAgD,KAAK,UAArD,CAA/B;AACH,OAda;;;;;AAmBd,MAAA,OAAO,EAAE,YAAW;AAChB,aAAK,IAAL,IAAa,oBAAoB,CAAC,KAAK,OAAN,EAAe,KAAK,IAApB,EAA0B,KAAK,UAA/B,CAAjC;AACA,aAAK,QAAL,IAAiB,oBAAoB,CAAC,KAAK,MAAN,EAAc,KAAK,QAAnB,EAA6B,KAAK,UAAlC,CAArC;AACA,aAAK,KAAL,IAAc,oBAAoB,CAAC,mBAAmB,CAAC,KAAK,OAAN,CAApB,EAAoC,KAAK,KAAzC,EAAgD,KAAK,UAArD,CAAlC;AACH;AAvBa,KAAlB;;;;;;;;AAgCA,aAAS,mBAAT,CAA6B,OAA7B,EAAsC;AAClC,UAAI,IAAJ;AACA,UAAI,UAAU,GAAG,OAAO,CAAC,OAAR,CAAgB,UAAjC;;AAEA,UAAI,UAAJ,EAAgB;AACZ,QAAA,IAAI,GAAG,UAAP;AACH,OAFD,MAEO,IAAI,sBAAJ,EAA4B;AAC/B,QAAA,IAAI,GAAG,iBAAP;AACH,OAFM,MAEA,IAAI,kBAAJ,EAAwB;AAC3B,QAAA,IAAI,GAAG,UAAP;AACH,OAFM,MAEA,IAAI,CAAC,aAAL,EAAoB;AACvB,QAAA,IAAI,GAAG,UAAP;AACH,OAFM,MAEA;AACH,QAAA,IAAI,GAAG,eAAP;AACH;;AACD,aAAO,IAAK,IAAL,CAAW,OAAX,EAAoB,YAApB,CAAP;AACH;;;;;;;;;AAQD,aAAS,YAAT,CAAsB,OAAtB,EAA+B,SAA/B,EAA0C,KAA1C,EAAiD;AAC7C,UAAI,WAAW,GAAG,KAAK,CAAC,QAAN,CAAe,MAAjC;AACA,UAAI,kBAAkB,GAAG,KAAK,CAAC,eAAN,CAAsB,MAA/C;AACA,UAAI,OAAO,GAAI,SAAS,GAAG,WAAZ,IAA4B,WAAW,GAAG,kBAAd,KAAqC,CAAhF;AACA,UAAI,OAAO,GAAI,SAAS,IAAI,SAAS,GAAG,YAAhB,CAAT,IAA2C,WAAW,GAAG,kBAAd,KAAqC,CAA/F;AAEA,MAAA,KAAK,CAAC,OAAN,GAAgB,CAAC,CAAC,OAAlB;AACA,MAAA,KAAK,CAAC,OAAN,GAAgB,CAAC,CAAC,OAAlB;;AAEA,UAAI,OAAJ,EAAa;AACT,QAAA,OAAO,CAAC,OAAR,GAAkB,EAAlB;AACH,OAX4C,C;;;;AAe7C,MAAA,KAAK,CAAC,SAAN,GAAkB,SAAlB,CAf6C,C;;AAkB7C,MAAA,gBAAgB,CAAC,OAAD,EAAU,KAAV,CAAhB,CAlB6C,C;;AAqB7C,MAAA,OAAO,CAAC,IAAR,CAAa,cAAb,EAA6B,KAA7B;AAEA,MAAA,OAAO,CAAC,SAAR,CAAkB,KAAlB;AACA,MAAA,OAAO,CAAC,OAAR,CAAgB,SAAhB,GAA4B,KAA5B;AACH;;;;;;;;AAOD,aAAS,gBAAT,CAA0B,OAA1B,EAAmC,KAAnC,EAA0C;AACtC,UAAI,OAAO,GAAG,OAAO,CAAC,OAAtB;AACA,UAAI,QAAQ,GAAG,KAAK,CAAC,QAArB;AACA,UAAI,cAAc,GAAG,QAAQ,CAAC,MAA9B,CAHsC,C;;AAMtC,UAAI,CAAC,OAAO,CAAC,UAAb,EAAyB;AACrB,QAAA,OAAO,CAAC,UAAR,GAAqB,oBAAoB,CAAC,KAAD,CAAzC;AACH,OARqC,C;;;AAWtC,UAAI,cAAc,GAAG,CAAjB,IAAsB,CAAC,OAAO,CAAC,aAAnC,EAAkD;AAC9C,QAAA,OAAO,CAAC,aAAR,GAAwB,oBAAoB,CAAC,KAAD,CAA5C;AACH,OAFD,MAEO,IAAI,cAAc,KAAK,CAAvB,EAA0B;AAC7B,QAAA,OAAO,CAAC,aAAR,GAAwB,KAAxB;AACH;;AAED,UAAI,UAAU,GAAG,OAAO,CAAC,UAAzB;AACA,UAAI,aAAa,GAAG,OAAO,CAAC,aAA5B;AACA,UAAI,YAAY,GAAG,aAAa,GAAG,aAAa,CAAC,MAAjB,GAA0B,UAAU,CAAC,MAArE;AAEA,UAAI,MAAM,GAAG,KAAK,CAAC,MAAN,GAAe,SAAS,CAAC,QAAD,CAArC;AACA,MAAA,KAAK,CAAC,SAAN,GAAkB,GAAG,EAArB;AACA,MAAA,KAAK,CAAC,SAAN,GAAkB,KAAK,CAAC,SAAN,GAAkB,UAAU,CAAC,SAA/C;AAEA,MAAA,KAAK,CAAC,KAAN,GAAc,QAAQ,CAAC,YAAD,EAAe,MAAf,CAAtB;AACA,MAAA,KAAK,CAAC,QAAN,GAAiB,WAAW,CAAC,YAAD,EAAe,MAAf,CAA5B;AAEA,MAAA,cAAc,CAAC,OAAD,EAAU,KAAV,CAAd;AACA,MAAA,KAAK,CAAC,eAAN,GAAwB,YAAY,CAAC,KAAK,CAAC,MAAP,EAAe,KAAK,CAAC,MAArB,CAApC;AAEA,UAAI,eAAe,GAAG,WAAW,CAAC,KAAK,CAAC,SAAP,EAAkB,KAAK,CAAC,MAAxB,EAAgC,KAAK,CAAC,MAAtC,CAAjC;AACA,MAAA,KAAK,CAAC,gBAAN,GAAyB,eAAe,CAAC,CAAzC;AACA,MAAA,KAAK,CAAC,gBAAN,GAAyB,eAAe,CAAC,CAAzC;AACA,MAAA,KAAK,CAAC,eAAN,GAAyB,GAAG,CAAC,eAAe,CAAC,CAAjB,CAAH,GAAyB,GAAG,CAAC,eAAe,CAAC,CAAjB,CAA7B,GAAoD,eAAe,CAAC,CAApE,GAAwE,eAAe,CAAC,CAAhH;AAEA,MAAA,KAAK,CAAC,KAAN,GAAc,aAAa,GAAG,QAAQ,CAAC,aAAa,CAAC,QAAf,EAAyB,QAAzB,CAAX,GAAgD,CAA3E;AACA,MAAA,KAAK,CAAC,QAAN,GAAiB,aAAa,GAAG,WAAW,CAAC,aAAa,CAAC,QAAf,EAAyB,QAAzB,CAAd,GAAmD,CAAjF;AAEA,MAAA,KAAK,CAAC,WAAN,GAAoB,CAAC,OAAO,CAAC,SAAT,GAAqB,KAAK,CAAC,QAAN,CAAe,MAApC,GAA+C,KAAK,CAAC,QAAN,CAAe,MAAf,GAC/D,OAAO,CAAC,SAAR,CAAkB,WAD4C,GAC7B,KAAK,CAAC,QAAN,CAAe,MADc,GACL,OAAO,CAAC,SAAR,CAAkB,WAD/E;AAGA,MAAA,wBAAwB,CAAC,OAAD,EAAU,KAAV,CAAxB,CA1CsC,C;;AA6CtC,UAAI,MAAM,GAAG,OAAO,CAAC,OAArB;;AACA,UAAI,SAAS,CAAC,KAAK,CAAC,QAAN,CAAe,MAAhB,EAAwB,MAAxB,CAAb,EAA8C;AAC1C,QAAA,MAAM,GAAG,KAAK,CAAC,QAAN,CAAe,MAAxB;AACH;;AACD,MAAA,KAAK,CAAC,MAAN,GAAe,MAAf;AACH;;AAED,aAAS,cAAT,CAAwB,OAAxB,EAAiC,KAAjC,EAAwC;AACpC,UAAI,MAAM,GAAG,KAAK,CAAC,MAAnB;AACA,UAAI,MAAM,GAAG,OAAO,CAAC,WAAR,IAAuB,EAApC;AACA,UAAI,SAAS,GAAG,OAAO,CAAC,SAAR,IAAqB,EAArC;AACA,UAAI,SAAS,GAAG,OAAO,CAAC,SAAR,IAAqB,EAArC;;AAEA,UAAI,KAAK,CAAC,SAAN,KAAoB,WAApB,IAAmC,SAAS,CAAC,SAAV,KAAwB,SAA/D,EAA0E;AACtE,QAAA,SAAS,GAAG,OAAO,CAAC,SAAR,GAAoB;AAC5B,UAAA,CAAC,EAAE,SAAS,CAAC,MAAV,IAAoB,CADK;AAE5B,UAAA,CAAC,EAAE,SAAS,CAAC,MAAV,IAAoB;AAFK,SAAhC;AAKA,QAAA,MAAM,GAAG,OAAO,CAAC,WAAR,GAAsB;AAC3B,UAAA,CAAC,EAAE,MAAM,CAAC,CADiB;AAE3B,UAAA,CAAC,EAAE,MAAM,CAAC;AAFiB,SAA/B;AAIH;;AAED,MAAA,KAAK,CAAC,MAAN,GAAe,SAAS,CAAC,CAAV,IAAe,MAAM,CAAC,CAAP,GAAW,MAAM,CAAC,CAAjC,CAAf;AACA,MAAA,KAAK,CAAC,MAAN,GAAe,SAAS,CAAC,CAAV,IAAe,MAAM,CAAC,CAAP,GAAW,MAAM,CAAC,CAAjC,CAAf;AACH;;;;;;;;AAOD,aAAS,wBAAT,CAAkC,OAAlC,EAA2C,KAA3C,EAAkD;AAC9C,UAAI,IAAI,GAAG,OAAO,CAAC,YAAR,IAAwB,KAAnC;AAAA,UACI,SAAS,GAAG,KAAK,CAAC,SAAN,GAAkB,IAAI,CAAC,SADvC;AAAA,UAEI,QAFJ;AAAA,UAEc,SAFd;AAAA,UAEyB,SAFzB;AAAA,UAEoC,SAFpC;;AAIA,UAAI,KAAK,CAAC,SAAN,IAAmB,YAAnB,KAAoC,SAAS,GAAG,gBAAZ,IAAgC,IAAI,CAAC,QAAL,KAAkB,SAAtF,CAAJ,EAAsG;AAClG,YAAI,MAAM,GAAG,KAAK,CAAC,MAAN,GAAe,IAAI,CAAC,MAAjC;AACA,YAAI,MAAM,GAAG,KAAK,CAAC,MAAN,GAAe,IAAI,CAAC,MAAjC;AAEA,YAAI,CAAC,GAAG,WAAW,CAAC,SAAD,EAAY,MAAZ,EAAoB,MAApB,CAAnB;AACA,QAAA,SAAS,GAAG,CAAC,CAAC,CAAd;AACA,QAAA,SAAS,GAAG,CAAC,CAAC,CAAd;AACA,QAAA,QAAQ,GAAI,GAAG,CAAC,CAAC,CAAC,CAAH,CAAH,GAAW,GAAG,CAAC,CAAC,CAAC,CAAH,CAAf,GAAwB,CAAC,CAAC,CAA1B,GAA8B,CAAC,CAAC,CAA3C;AACA,QAAA,SAAS,GAAG,YAAY,CAAC,MAAD,EAAS,MAAT,CAAxB;AAEA,QAAA,OAAO,CAAC,YAAR,GAAuB,KAAvB;AACH,OAXD,MAWO;;AAEH,QAAA,QAAQ,GAAG,IAAI,CAAC,QAAhB;AACA,QAAA,SAAS,GAAG,IAAI,CAAC,SAAjB;AACA,QAAA,SAAS,GAAG,IAAI,CAAC,SAAjB;AACA,QAAA,SAAS,GAAG,IAAI,CAAC,SAAjB;AACH;;AAED,MAAA,KAAK,CAAC,QAAN,GAAiB,QAAjB;AACA,MAAA,KAAK,CAAC,SAAN,GAAkB,SAAlB;AACA,MAAA,KAAK,CAAC,SAAN,GAAkB,SAAlB;AACA,MAAA,KAAK,CAAC,SAAN,GAAkB,SAAlB;AACH;;;;;;;;AAOD,aAAS,oBAAT,CAA8B,KAA9B,EAAqC;;;AAGjC,UAAI,QAAQ,GAAG,EAAf;AACA,UAAI,CAAC,GAAG,CAAR;;AACA,aAAO,CAAC,GAAG,KAAK,CAAC,QAAN,CAAe,MAA1B,EAAkC;AAC9B,QAAA,QAAQ,CAAC,CAAD,CAAR,GAAc;AACV,UAAA,OAAO,EAAE,KAAK,CAAC,KAAK,CAAC,QAAN,CAAe,CAAf,EAAkB,OAAnB,CADJ;AAEV,UAAA,OAAO,EAAE,KAAK,CAAC,KAAK,CAAC,QAAN,CAAe,CAAf,EAAkB,OAAnB;AAFJ,SAAd;AAIA,QAAA,CAAC;AACJ;;AAED,aAAO;AACH,QAAA,SAAS,EAAE,GAAG,EADX;AAEH,QAAA,QAAQ,EAAE,QAFP;AAGH,QAAA,MAAM,EAAE,SAAS,CAAC,QAAD,CAHd;AAIH,QAAA,MAAM,EAAE,KAAK,CAAC,MAJX;AAKH,QAAA,MAAM,EAAE,KAAK,CAAC;AALX,OAAP;AAOH;;;;;;;;AAOD,aAAS,SAAT,CAAmB,QAAnB,EAA6B;AACzB,UAAI,cAAc,GAAG,QAAQ,CAAC,MAA9B,CADyB,C;;AAIzB,UAAI,cAAc,KAAK,CAAvB,EAA0B;AACtB,eAAO;AACH,UAAA,CAAC,EAAE,KAAK,CAAC,QAAQ,CAAC,CAAD,CAAR,CAAY,OAAb,CADL;AAEH,UAAA,CAAC,EAAE,KAAK,CAAC,QAAQ,CAAC,CAAD,CAAR,CAAY,OAAb;AAFL,SAAP;AAIH;;AAED,UAAI,CAAC,GAAG,CAAR;AAAA,UAAW,CAAC,GAAG,CAAf;AAAA,UAAkB,CAAC,GAAG,CAAtB;;AACA,aAAO,CAAC,GAAG,cAAX,EAA2B;AACvB,QAAA,CAAC,IAAI,QAAQ,CAAC,CAAD,CAAR,CAAY,OAAjB;AACA,QAAA,CAAC,IAAI,QAAQ,CAAC,CAAD,CAAR,CAAY,OAAjB;AACA,QAAA,CAAC;AACJ;;AAED,aAAO;AACH,QAAA,CAAC,EAAE,KAAK,CAAC,CAAC,GAAG,cAAL,CADL;AAEH,QAAA,CAAC,EAAE,KAAK,CAAC,CAAC,GAAG,cAAL;AAFL,OAAP;AAIH;;;;;;;;;;AASD,aAAS,WAAT,CAAqB,SAArB,EAAgC,CAAhC,EAAmC,CAAnC,EAAsC;AAClC,aAAO;AACH,QAAA,CAAC,EAAE,CAAC,GAAG,SAAJ,IAAiB,CADjB;AAEH,QAAA,CAAC,EAAE,CAAC,GAAG,SAAJ,IAAiB;AAFjB,OAAP;AAIH;;;;;;;;;AAQD,aAAS,YAAT,CAAsB,CAAtB,EAAyB,CAAzB,EAA4B;AACxB,UAAI,CAAC,KAAK,CAAV,EAAa;AACT,eAAO,cAAP;AACH;;AAED,UAAI,GAAG,CAAC,CAAD,CAAH,IAAU,GAAG,CAAC,CAAD,CAAjB,EAAsB;AAClB,eAAO,CAAC,GAAG,CAAJ,GAAQ,cAAR,GAAyB,eAAhC;AACH;;AACD,aAAO,CAAC,GAAG,CAAJ,GAAQ,YAAR,GAAuB,cAA9B;AACH;;;;;;;;;;AASD,aAAS,WAAT,CAAqB,EAArB,EAAyB,EAAzB,EAA6B,KAA7B,EAAoC;AAChC,UAAI,CAAC,KAAL,EAAY;AACR,QAAA,KAAK,GAAG,QAAR;AACH;;AACD,UAAI,CAAC,GAAG,EAAE,CAAC,KAAK,CAAC,CAAD,CAAN,CAAF,GAAe,EAAE,CAAC,KAAK,CAAC,CAAD,CAAN,CAAzB;AAAA,UACI,CAAC,GAAG,EAAE,CAAC,KAAK,CAAC,CAAD,CAAN,CAAF,GAAe,EAAE,CAAC,KAAK,CAAC,CAAD,CAAN,CADzB;AAGA,aAAO,IAAI,CAAC,IAAL,CAAW,CAAC,GAAG,CAAL,GAAW,CAAC,GAAG,CAAzB,CAAP;AACH;;;;;;;;;;AASD,aAAS,QAAT,CAAkB,EAAlB,EAAsB,EAAtB,EAA0B,KAA1B,EAAiC;AAC7B,UAAI,CAAC,KAAL,EAAY;AACR,QAAA,KAAK,GAAG,QAAR;AACH;;AACD,UAAI,CAAC,GAAG,EAAE,CAAC,KAAK,CAAC,CAAD,CAAN,CAAF,GAAe,EAAE,CAAC,KAAK,CAAC,CAAD,CAAN,CAAzB;AAAA,UACI,CAAC,GAAG,EAAE,CAAC,KAAK,CAAC,CAAD,CAAN,CAAF,GAAe,EAAE,CAAC,KAAK,CAAC,CAAD,CAAN,CADzB;AAEA,aAAO,IAAI,CAAC,KAAL,CAAW,CAAX,EAAc,CAAd,IAAmB,GAAnB,GAAyB,IAAI,CAAC,EAArC;AACH;;;;;;;;;AAQD,aAAS,WAAT,CAAqB,KAArB,EAA4B,GAA5B,EAAiC;AAC7B,aAAO,QAAQ,CAAC,GAAG,CAAC,CAAD,CAAJ,EAAS,GAAG,CAAC,CAAD,CAAZ,EAAiB,eAAjB,CAAR,GAA4C,QAAQ,CAAC,KAAK,CAAC,CAAD,CAAN,EAAW,KAAK,CAAC,CAAD,CAAhB,EAAqB,eAArB,CAA3D;AACH;;;;;;;;;;AASD,aAAS,QAAT,CAAkB,KAAlB,EAAyB,GAAzB,EAA8B;AAC1B,aAAO,WAAW,CAAC,GAAG,CAAC,CAAD,CAAJ,EAAS,GAAG,CAAC,CAAD,CAAZ,EAAiB,eAAjB,CAAX,GAA+C,WAAW,CAAC,KAAK,CAAC,CAAD,CAAN,EAAW,KAAK,CAAC,CAAD,CAAhB,EAAqB,eAArB,CAAjE;AACH;;AAED,QAAI,eAAe,GAAG;AAClB,MAAA,SAAS,EAAE,WADO;AAElB,MAAA,SAAS,EAAE,UAFO;AAGlB,MAAA,OAAO,EAAE;AAHS,KAAtB;AAMA,QAAI,oBAAoB,GAAG,WAA3B;AACA,QAAI,mBAAmB,GAAG,mBAA1B;;;;;;;AAOA,aAAS,UAAT,GAAsB;AAClB,WAAK,IAAL,GAAY,oBAAZ;AACA,WAAK,KAAL,GAAa,mBAAb;AAEA,WAAK,OAAL,GAAe,KAAf,CAJkB,CAIG;;AAErB,MAAA,KAAK,CAAC,KAAN,CAAY,IAAZ,EAAkB,SAAlB;AACH;;AAED,IAAA,OAAO,CAAC,UAAD,EAAa,KAAb,EAAoB;;;;;AAKvB,MAAA,OAAO,EAAE,SAAS,SAAT,CAAmB,EAAnB,EAAuB;AAC5B,YAAI,SAAS,GAAG,eAAe,CAAC,EAAE,CAAC,IAAJ,CAA/B,CAD4B,C;;AAI5B,YAAI,SAAS,GAAG,WAAZ,IAA2B,EAAE,CAAC,MAAH,KAAc,CAA7C,EAAgD;AAC5C,eAAK,OAAL,GAAe,IAAf;AACH;;AAED,YAAI,SAAS,GAAG,UAAZ,IAA0B,EAAE,CAAC,KAAH,KAAa,CAA3C,EAA8C;AAC1C,UAAA,SAAS,GAAG,SAAZ;AACH,SAV2B,C;;;AAa5B,YAAI,CAAC,KAAK,OAAV,EAAmB;AACf;AACH;;AAED,YAAI,SAAS,GAAG,SAAhB,EAA2B;AACvB,eAAK,OAAL,GAAe,KAAf;AACH;;AAED,aAAK,QAAL,CAAc,KAAK,OAAnB,EAA4B,SAA5B,EAAuC;AACnC,UAAA,QAAQ,EAAE,CAAC,EAAD,CADyB;AAEnC,UAAA,eAAe,EAAE,CAAC,EAAD,CAFkB;AAGnC,UAAA,WAAW,EAAE,gBAHsB;AAInC,UAAA,QAAQ,EAAE;AAJyB,SAAvC;AAMH;AAhCsB,KAApB,CAAP;AAmCA,QAAI,iBAAiB,GAAG;AACpB,MAAA,WAAW,EAAE,WADO;AAEpB,MAAA,WAAW,EAAE,UAFO;AAGpB,MAAA,SAAS,EAAE,SAHS;AAIpB,MAAA,aAAa,EAAE,YAJK;AAKpB,MAAA,UAAU,EAAE;AALQ,KAAxB,CA5zBmD,C;;AAq0BnD,QAAI,sBAAsB,GAAG;AACzB,SAAG,gBADsB;AAEzB,SAAG,cAFsB;AAGzB,SAAG,gBAHsB;AAIzB,SAAG,iBAJsB,CAIL;;AAJK,KAA7B;AAOA,QAAI,sBAAsB,GAAG,aAA7B;AACA,QAAI,qBAAqB,GAAG,qCAA5B,CA70BmD,C;;AAg1BnD,QAAI,MAAM,CAAC,cAAP,IAAyB,CAAC,MAAM,CAAC,YAArC,EAAmD;AAC/C,MAAA,sBAAsB,GAAG,eAAzB;AACA,MAAA,qBAAqB,GAAG,2CAAxB;AACH;;;;;;;;AAOD,aAAS,iBAAT,GAA6B;AACzB,WAAK,IAAL,GAAY,sBAAZ;AACA,WAAK,KAAL,GAAa,qBAAb;AAEA,MAAA,KAAK,CAAC,KAAN,CAAY,IAAZ,EAAkB,SAAlB;AAEA,WAAK,KAAL,GAAc,KAAK,OAAL,CAAa,OAAb,CAAqB,aAArB,GAAqC,EAAnD;AACH;;AAED,IAAA,OAAO,CAAC,iBAAD,EAAoB,KAApB,EAA2B;;;;;AAK9B,MAAA,OAAO,EAAE,SAAS,SAAT,CAAmB,EAAnB,EAAuB;AAC5B,YAAI,KAAK,GAAG,KAAK,KAAjB;AACA,YAAI,aAAa,GAAG,KAApB;AAEA,YAAI,mBAAmB,GAAG,EAAE,CAAC,IAAH,CAAQ,WAAR,GAAsB,OAAtB,CAA8B,IAA9B,EAAoC,EAApC,CAA1B;AACA,YAAI,SAAS,GAAG,iBAAiB,CAAC,mBAAD,CAAjC;AACA,YAAI,WAAW,GAAG,sBAAsB,CAAC,EAAE,CAAC,WAAJ,CAAtB,IAA0C,EAAE,CAAC,WAA/D;AAEA,YAAI,OAAO,GAAI,WAAW,IAAI,gBAA9B,CAR4B,C;;AAW5B,YAAI,UAAU,GAAG,OAAO,CAAC,KAAD,EAAQ,EAAE,CAAC,SAAX,EAAsB,WAAtB,CAAxB,CAX4B,C;;AAc5B,YAAI,SAAS,GAAG,WAAZ,KAA4B,EAAE,CAAC,MAAH,KAAc,CAAd,IAAmB,OAA/C,CAAJ,EAA6D;AACzD,cAAI,UAAU,GAAG,CAAjB,EAAoB;AAChB,YAAA,KAAK,CAAC,IAAN,CAAW,EAAX;AACA,YAAA,UAAU,GAAG,KAAK,CAAC,MAAN,GAAe,CAA5B;AACH;AACJ,SALD,MAKO,IAAI,SAAS,IAAI,SAAS,GAAG,YAAhB,CAAb,EAA4C;AAC/C,UAAA,aAAa,GAAG,IAAhB;AACH,SArB2B,C;;;AAwB5B,YAAI,UAAU,GAAG,CAAjB,EAAoB;AAChB;AACH,SA1B2B,C;;;AA6B5B,QAAA,KAAK,CAAC,UAAD,CAAL,GAAoB,EAApB;AAEA,aAAK,QAAL,CAAc,KAAK,OAAnB,EAA4B,SAA5B,EAAuC;AACnC,UAAA,QAAQ,EAAE,KADyB;AAEnC,UAAA,eAAe,EAAE,CAAC,EAAD,CAFkB;AAGnC,UAAA,WAAW,EAAE,WAHsB;AAInC,UAAA,QAAQ,EAAE;AAJyB,SAAvC;;AAOA,YAAI,aAAJ,EAAmB;;AAEf,UAAA,KAAK,CAAC,MAAN,CAAa,UAAb,EAAyB,CAAzB;AACH;AACJ;AA/C6B,KAA3B,CAAP;AAkDA,QAAI,sBAAsB,GAAG;AACzB,MAAA,UAAU,EAAE,WADa;AAEzB,MAAA,SAAS,EAAE,UAFc;AAGzB,MAAA,QAAQ,EAAE,SAHe;AAIzB,MAAA,WAAW,EAAE;AAJY,KAA7B;AAOA,QAAI,0BAA0B,GAAG,YAAjC;AACA,QAAI,0BAA0B,GAAG,2CAAjC;;;;;;;AAOA,aAAS,gBAAT,GAA4B;AACxB,WAAK,QAAL,GAAgB,0BAAhB;AACA,WAAK,KAAL,GAAa,0BAAb;AACA,WAAK,OAAL,GAAe,KAAf;AAEA,MAAA,KAAK,CAAC,KAAN,CAAY,IAAZ,EAAkB,SAAlB;AACH;;AAED,IAAA,OAAO,CAAC,gBAAD,EAAmB,KAAnB,EAA0B;AAC7B,MAAA,OAAO,EAAE,SAAS,SAAT,CAAmB,EAAnB,EAAuB;AAC5B,YAAI,IAAI,GAAG,sBAAsB,CAAC,EAAE,CAAC,IAAJ,CAAjC,CAD4B,C;;AAI5B,YAAI,IAAI,KAAK,WAAb,EAA0B;AACtB,eAAK,OAAL,GAAe,IAAf;AACH;;AAED,YAAI,CAAC,KAAK,OAAV,EAAmB;AACf;AACH;;AAED,YAAI,OAAO,GAAG,sBAAsB,CAAC,IAAvB,CAA4B,IAA5B,EAAkC,EAAlC,EAAsC,IAAtC,CAAd,CAZ4B,C;;AAe5B,YAAI,IAAI,IAAI,SAAS,GAAG,YAAhB,CAAJ,IAAqC,OAAO,CAAC,CAAD,CAAP,CAAW,MAAX,GAAoB,OAAO,CAAC,CAAD,CAAP,CAAW,MAA/B,KAA0C,CAAnF,EAAsF;AAClF,eAAK,OAAL,GAAe,KAAf;AACH;;AAED,aAAK,QAAL,CAAc,KAAK,OAAnB,EAA4B,IAA5B,EAAkC;AAC9B,UAAA,QAAQ,EAAE,OAAO,CAAC,CAAD,CADa;AAE9B,UAAA,eAAe,EAAE,OAAO,CAAC,CAAD,CAFM;AAG9B,UAAA,WAAW,EAAE,gBAHiB;AAI9B,UAAA,QAAQ,EAAE;AAJoB,SAAlC;AAMH;AA1B4B,KAA1B,CAAP;;;;;;;;AAmCA,aAAS,sBAAT,CAAgC,EAAhC,EAAoC,IAApC,EAA0C;AACtC,UAAI,GAAG,GAAG,OAAO,CAAC,EAAE,CAAC,OAAJ,CAAjB;AACA,UAAI,OAAO,GAAG,OAAO,CAAC,EAAE,CAAC,cAAJ,CAArB;;AAEA,UAAI,IAAI,IAAI,SAAS,GAAG,YAAhB,CAAR,EAAuC;AACnC,QAAA,GAAG,GAAG,WAAW,CAAC,GAAG,CAAC,MAAJ,CAAW,OAAX,CAAD,EAAsB,YAAtB,EAAoC,IAApC,CAAjB;AACH;;AAED,aAAO,CAAC,GAAD,EAAM,OAAN,CAAP;AACH;;AAED,QAAI,eAAe,GAAG;AAClB,MAAA,UAAU,EAAE,WADM;AAElB,MAAA,SAAS,EAAE,UAFO;AAGlB,MAAA,QAAQ,EAAE,SAHQ;AAIlB,MAAA,WAAW,EAAE;AAJK,KAAtB;AAOA,QAAI,mBAAmB,GAAG,2CAA1B;;;;;;;AAOA,aAAS,UAAT,GAAsB;AAClB,WAAK,QAAL,GAAgB,mBAAhB;AACA,WAAK,SAAL,GAAiB,EAAjB;AAEA,MAAA,KAAK,CAAC,KAAN,CAAY,IAAZ,EAAkB,SAAlB;AACH;;AAED,IAAA,OAAO,CAAC,UAAD,EAAa,KAAb,EAAoB;AACvB,MAAA,OAAO,EAAE,SAAS,UAAT,CAAoB,EAApB,EAAwB;AAC7B,YAAI,IAAI,GAAG,eAAe,CAAC,EAAE,CAAC,IAAJ,CAA1B;AACA,YAAI,OAAO,GAAG,UAAU,CAAC,IAAX,CAAgB,IAAhB,EAAsB,EAAtB,EAA0B,IAA1B,CAAd;;AACA,YAAI,CAAC,OAAL,EAAc;AACV;AACH;;AAED,aAAK,QAAL,CAAc,KAAK,OAAnB,EAA4B,IAA5B,EAAkC;AAC9B,UAAA,QAAQ,EAAE,OAAO,CAAC,CAAD,CADa;AAE9B,UAAA,eAAe,EAAE,OAAO,CAAC,CAAD,CAFM;AAG9B,UAAA,WAAW,EAAE,gBAHiB;AAI9B,UAAA,QAAQ,EAAE;AAJoB,SAAlC;AAMH;AAdsB,KAApB,CAAP;;;;;;;;AAuBA,aAAS,UAAT,CAAoB,EAApB,EAAwB,IAAxB,EAA8B;AAC1B,UAAI,UAAU,GAAG,OAAO,CAAC,EAAE,CAAC,OAAJ,CAAxB;AACA,UAAI,SAAS,GAAG,KAAK,SAArB,CAF0B,C;;AAK1B,UAAI,IAAI,IAAI,WAAW,GAAG,UAAlB,CAAJ,IAAqC,UAAU,CAAC,MAAX,KAAsB,CAA/D,EAAkE;AAC9D,QAAA,SAAS,CAAC,UAAU,CAAC,CAAD,CAAV,CAAc,UAAf,CAAT,GAAsC,IAAtC;AACA,eAAO,CAAC,UAAD,EAAa,UAAb,CAAP;AACH;;AAED,UAAI,CAAJ;AAAA,UACI,aADJ;AAAA,UAEI,cAAc,GAAG,OAAO,CAAC,EAAE,CAAC,cAAJ,CAF5B;AAAA,UAGI,oBAAoB,GAAG,EAH3B;AAAA,UAII,MAAM,GAAG,KAAK,MAJlB,CAV0B,C;;AAiB1B,MAAA,aAAa,GAAG,UAAU,CAAC,MAAX,CAAkB,UAAS,KAAT,EAAgB;AAC9C,eAAO,SAAS,CAAC,KAAK,CAAC,MAAP,EAAe,MAAf,CAAhB;AACH,OAFe,CAAhB,CAjB0B,C;;AAsB1B,UAAI,IAAI,KAAK,WAAb,EAA0B;AACtB,QAAA,CAAC,GAAG,CAAJ;;AACA,eAAO,CAAC,GAAG,aAAa,CAAC,MAAzB,EAAiC;AAC7B,UAAA,SAAS,CAAC,aAAa,CAAC,CAAD,CAAb,CAAiB,UAAlB,CAAT,GAAyC,IAAzC;AACA,UAAA,CAAC;AACJ;AACJ,OA5ByB,C;;;AA+B1B,MAAA,CAAC,GAAG,CAAJ;;AACA,aAAO,CAAC,GAAG,cAAc,CAAC,MAA1B,EAAkC;AAC9B,YAAI,SAAS,CAAC,cAAc,CAAC,CAAD,CAAd,CAAkB,UAAnB,CAAb,EAA6C;AACzC,UAAA,oBAAoB,CAAC,IAArB,CAA0B,cAAc,CAAC,CAAD,CAAxC;AACH,SAH6B,C;;;AAM9B,YAAI,IAAI,IAAI,SAAS,GAAG,YAAhB,CAAR,EAAuC;AACnC,iBAAO,SAAS,CAAC,cAAc,CAAC,CAAD,CAAd,CAAkB,UAAnB,CAAhB;AACH;;AACD,QAAA,CAAC;AACJ;;AAED,UAAI,CAAC,oBAAoB,CAAC,MAA1B,EAAkC;AAC9B;AACH;;AAED,aAAO,C;AAEH,MAAA,WAAW,CAAC,aAAa,CAAC,MAAd,CAAqB,oBAArB,CAAD,EAA6C,YAA7C,EAA2D,IAA3D,CAFR,EAGH,oBAHG,CAAP;AAKH;;;;;;;;;;;;AAYD,QAAI,aAAa,GAAG,IAApB;AACA,QAAI,cAAc,GAAG,EAArB;;AAEA,aAAS,eAAT,GAA2B;AACvB,MAAA,KAAK,CAAC,KAAN,CAAY,IAAZ,EAAkB,SAAlB;AAEA,UAAI,OAAO,GAAG,MAAM,CAAC,KAAK,OAAN,EAAe,IAAf,CAApB;AACA,WAAK,KAAL,GAAa,IAAI,UAAJ,CAAe,KAAK,OAApB,EAA6B,OAA7B,CAAb;AACA,WAAK,KAAL,GAAa,IAAI,UAAJ,CAAe,KAAK,OAApB,EAA6B,OAA7B,CAAb;AAEA,WAAK,YAAL,GAAoB,IAApB;AACA,WAAK,WAAL,GAAmB,EAAnB;AACH;;AAED,IAAA,OAAO,CAAC,eAAD,EAAkB,KAAlB,EAAyB;;;;;;;AAO5B,MAAA,OAAO,EAAE,SAAS,UAAT,CAAoB,OAApB,EAA6B,UAA7B,EAAyC,SAAzC,EAAoD;AACzD,YAAI,OAAO,GAAI,SAAS,CAAC,WAAV,IAAyB,gBAAxC;AAAA,YACI,OAAO,GAAI,SAAS,CAAC,WAAV,IAAyB,gBADxC;;AAGA,YAAI,OAAO,IAAI,SAAS,CAAC,kBAArB,IAA2C,SAAS,CAAC,kBAAV,CAA6B,gBAA5E,EAA8F;AAC1F;AACH,SANwD,C;;;AASzD,YAAI,OAAJ,EAAa;AACT,UAAA,aAAa,CAAC,IAAd,CAAmB,IAAnB,EAAyB,UAAzB,EAAqC,SAArC;AACH,SAFD,MAEO,IAAI,OAAO,IAAI,gBAAgB,CAAC,IAAjB,CAAsB,IAAtB,EAA4B,SAA5B,CAAf,EAAuD;AAC1D;AACH;;AAED,aAAK,QAAL,CAAc,OAAd,EAAuB,UAAvB,EAAmC,SAAnC;AACH,OAvB2B;;;;;AA4B5B,MAAA,OAAO,EAAE,SAAS,OAAT,GAAmB;AACxB,aAAK,KAAL,CAAW,OAAX;AACA,aAAK,KAAL,CAAW,OAAX;AACH;AA/B2B,KAAzB,CAAP;;AAkCA,aAAS,aAAT,CAAuB,SAAvB,EAAkC,SAAlC,EAA6C;AACzC,UAAI,SAAS,GAAG,WAAhB,EAA6B;AACzB,aAAK,YAAL,GAAoB,SAAS,CAAC,eAAV,CAA0B,CAA1B,EAA6B,UAAjD;AACA,QAAA,YAAY,CAAC,IAAb,CAAkB,IAAlB,EAAwB,SAAxB;AACH,OAHD,MAGO,IAAI,SAAS,IAAI,SAAS,GAAG,YAAhB,CAAb,EAA4C;AAC/C,QAAA,YAAY,CAAC,IAAb,CAAkB,IAAlB,EAAwB,SAAxB;AACH;AACJ;;AAED,aAAS,YAAT,CAAsB,SAAtB,EAAiC;AAC7B,UAAI,KAAK,GAAG,SAAS,CAAC,eAAV,CAA0B,CAA1B,CAAZ;;AAEA,UAAI,KAAK,CAAC,UAAN,KAAqB,KAAK,YAA9B,EAA4C;AACxC,YAAI,SAAS,GAAG;AAAC,UAAA,CAAC,EAAE,KAAK,CAAC,OAAV;AAAmB,UAAA,CAAC,EAAE,KAAK,CAAC;AAA5B,SAAhB;AACA,aAAK,WAAL,CAAiB,IAAjB,CAAsB,SAAtB;AACA,YAAI,GAAG,GAAG,KAAK,WAAf;;AACA,YAAI,eAAe,GAAG,YAAW;AAC7B,cAAI,CAAC,GAAG,GAAG,CAAC,OAAJ,CAAY,SAAZ,CAAR;;AACA,cAAI,CAAC,GAAG,CAAC,CAAT,EAAY;AACR,YAAA,GAAG,CAAC,MAAJ,CAAW,CAAX,EAAc,CAAd;AACH;AACJ,SALD;;AAMA,QAAA,UAAU,CAAC,eAAD,EAAkB,aAAlB,CAAV;AACH;AACJ;;AAED,aAAS,gBAAT,CAA0B,SAA1B,EAAqC;AACjC,UAAI,CAAC,GAAG,SAAS,CAAC,QAAV,CAAmB,OAA3B;AAAA,UAAoC,CAAC,GAAG,SAAS,CAAC,QAAV,CAAmB,OAA3D;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,WAAL,CAAiB,MAArC,EAA6C,CAAC,EAA9C,EAAkD;AAC9C,YAAI,CAAC,GAAG,KAAK,WAAL,CAAiB,CAAjB,CAAR;AACA,YAAI,EAAE,GAAG,IAAI,CAAC,GAAL,CAAS,CAAC,GAAG,CAAC,CAAC,CAAf,CAAT;AAAA,YAA4B,EAAE,GAAG,IAAI,CAAC,GAAL,CAAS,CAAC,GAAG,CAAC,CAAC,CAAf,CAAjC;;AACA,YAAI,EAAE,IAAI,cAAN,IAAwB,EAAE,IAAI,cAAlC,EAAkD;AAC9C,iBAAO,IAAP;AACH;AACJ;;AACD,aAAO,KAAP;AACH;;AAED,QAAI,qBAAqB,GAAG,QAAQ,CAAC,YAAY,CAAC,KAAd,EAAqB,aAArB,CAApC;AACA,QAAI,mBAAmB,GAAG,qBAAqB,KAAK,SAApD,CA9pCmD,C;;AAiqCnD,QAAI,oBAAoB,GAAG,SAA3B;AACA,QAAI,iBAAiB,GAAG,MAAxB;AACA,QAAI,yBAAyB,GAAG,cAAhC,CAnqCmD,CAmqCJ;;AAC/C,QAAI,iBAAiB,GAAG,MAAxB;AACA,QAAI,kBAAkB,GAAG,OAAzB;AACA,QAAI,kBAAkB,GAAG,OAAzB;AACA,QAAI,gBAAgB,GAAG,mBAAmB,EAA1C;;;;;;;;;AASA,aAAS,WAAT,CAAqB,OAArB,EAA8B,KAA9B,EAAqC;AACjC,WAAK,OAAL,GAAe,OAAf;AACA,WAAK,GAAL,CAAS,KAAT;AACH;;AAED,IAAA,WAAW,CAAC,SAAZ,GAAwB;;;;;AAKpB,MAAA,GAAG,EAAE,UAAS,KAAT,EAAgB;;AAEjB,YAAI,KAAK,IAAI,oBAAb,EAAmC;AAC/B,UAAA,KAAK,GAAG,KAAK,OAAL,EAAR;AACH;;AAED,YAAI,mBAAmB,IAAI,KAAK,OAAL,CAAa,OAAb,CAAqB,KAA5C,IAAqD,gBAAgB,CAAC,KAAD,CAAzE,EAAkF;AAC9E,eAAK,OAAL,CAAa,OAAb,CAAqB,KAArB,CAA2B,qBAA3B,IAAoD,KAApD;AACH;;AACD,aAAK,OAAL,GAAe,KAAK,CAAC,WAAN,GAAoB,IAApB,EAAf;AACH,OAfmB;;;;;AAoBpB,MAAA,MAAM,EAAE,YAAW;AACf,aAAK,GAAL,CAAS,KAAK,OAAL,CAAa,OAAb,CAAqB,WAA9B;AACH,OAtBmB;;;;;;AA4BpB,MAAA,OAAO,EAAE,YAAW;AAChB,YAAI,OAAO,GAAG,EAAd;AACA,QAAA,IAAI,CAAC,KAAK,OAAL,CAAa,WAAd,EAA2B,UAAS,UAAT,EAAqB;AAChD,cAAI,QAAQ,CAAC,UAAU,CAAC,OAAX,CAAmB,MAApB,EAA4B,CAAC,UAAD,CAA5B,CAAZ,EAAuD;AACnD,YAAA,OAAO,GAAG,OAAO,CAAC,MAAR,CAAe,UAAU,CAAC,cAAX,EAAf,CAAV;AACH;AACJ,SAJG,CAAJ;AAKA,eAAO,iBAAiB,CAAC,OAAO,CAAC,IAAR,CAAa,GAAb,CAAD,CAAxB;AACH,OApCmB;;;;;;AA0CpB,MAAA,eAAe,EAAE,UAAS,KAAT,EAAgB;AAC7B,YAAI,QAAQ,GAAG,KAAK,CAAC,QAArB;AACA,YAAI,SAAS,GAAG,KAAK,CAAC,eAAtB,CAF6B,C;;AAK7B,YAAI,KAAK,OAAL,CAAa,OAAb,CAAqB,SAAzB,EAAoC;AAChC,UAAA,QAAQ,CAAC,cAAT;AACA;AACH;;AAED,YAAI,OAAO,GAAG,KAAK,OAAnB;AACA,YAAI,OAAO,GAAG,KAAK,CAAC,OAAD,EAAU,iBAAV,CAAL,IAAqC,CAAC,gBAAgB,CAAC,iBAAD,CAApE;AACA,YAAI,OAAO,GAAG,KAAK,CAAC,OAAD,EAAU,kBAAV,CAAL,IAAsC,CAAC,gBAAgB,CAAC,kBAAD,CAArE;AACA,YAAI,OAAO,GAAG,KAAK,CAAC,OAAD,EAAU,kBAAV,CAAL,IAAsC,CAAC,gBAAgB,CAAC,kBAAD,CAArE;;AAEA,YAAI,OAAJ,EAAa;;AAGT,cAAI,YAAY,GAAG,KAAK,CAAC,QAAN,CAAe,MAAf,KAA0B,CAA7C;AACA,cAAI,aAAa,GAAG,KAAK,CAAC,QAAN,GAAiB,CAArC;AACA,cAAI,cAAc,GAAG,KAAK,CAAC,SAAN,GAAkB,GAAvC;;AAEA,cAAI,YAAY,IAAI,aAAhB,IAAiC,cAArC,EAAqD;AACjD;AACH;AACJ;;AAED,YAAI,OAAO,IAAI,OAAf,EAAwB;;AAEpB;AACH;;AAED,YAAI,OAAO,IACN,OAAO,IAAI,SAAS,GAAG,oBADxB,IAEC,OAAO,IAAI,SAAS,GAAG,kBAF5B,EAEiD;AAC7C,iBAAO,KAAK,UAAL,CAAgB,QAAhB,CAAP;AACH;AACJ,OA/EmB;;;;;;AAqFpB,MAAA,UAAU,EAAE,UAAS,QAAT,EAAmB;AAC3B,aAAK,OAAL,CAAa,OAAb,CAAqB,SAArB,GAAiC,IAAjC;AACA,QAAA,QAAQ,CAAC,cAAT;AACH;AAxFmB,KAAxB;;;;;;;AAgGA,aAAS,iBAAT,CAA2B,OAA3B,EAAoC;;AAEhC,UAAI,KAAK,CAAC,OAAD,EAAU,iBAAV,CAAT,EAAuC;AACnC,eAAO,iBAAP;AACH;;AAED,UAAI,OAAO,GAAG,KAAK,CAAC,OAAD,EAAU,kBAAV,CAAnB;AACA,UAAI,OAAO,GAAG,KAAK,CAAC,OAAD,EAAU,kBAAV,CAAnB,CAPgC,C;;;;;AAahC,UAAI,OAAO,IAAI,OAAf,EAAwB;AACpB,eAAO,iBAAP;AACH,OAf+B,C;;;AAkBhC,UAAI,OAAO,IAAI,OAAf,EAAwB;AACpB,eAAO,OAAO,GAAG,kBAAH,GAAwB,kBAAtC;AACH,OApB+B,C;;;AAuBhC,UAAI,KAAK,CAAC,OAAD,EAAU,yBAAV,CAAT,EAA+C;AAC3C,eAAO,yBAAP;AACH;;AAED,aAAO,iBAAP;AACH;;AAED,aAAS,mBAAT,GAA+B;AAC3B,UAAI,CAAC,mBAAL,EAA0B;AACtB,eAAO,KAAP;AACH;;AACD,UAAI,QAAQ,GAAG,EAAf;AACA,UAAI,WAAW,GAAG,MAAM,CAAC,GAAP,IAAc,MAAM,CAAC,GAAP,CAAW,QAA3C;AACA,OAAC,MAAD,EAAS,cAAT,EAAyB,OAAzB,EAAkC,OAAlC,EAA2C,aAA3C,EAA0D,MAA1D,EAAkE,OAAlE,CAA0E,UAAS,GAAT,EAAc;;;AAIpF,QAAA,QAAQ,CAAC,GAAD,CAAR,GAAgB,WAAW,GAAG,MAAM,CAAC,GAAP,CAAW,QAAX,CAAoB,cAApB,EAAoC,GAApC,CAAH,GAA8C,IAAzE;AACH,OALD;AAMA,aAAO,QAAP;AACH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BD,QAAI,cAAc,GAAG,CAArB;AACA,QAAI,WAAW,GAAG,CAAlB;AACA,QAAI,aAAa,GAAG,CAApB;AACA,QAAI,WAAW,GAAG,CAAlB;AACA,QAAI,gBAAgB,GAAG,WAAvB;AACA,QAAI,eAAe,GAAG,EAAtB;AACA,QAAI,YAAY,GAAG,EAAnB;;;;;;;;AAQA,aAAS,UAAT,CAAoB,OAApB,EAA6B;AACzB,WAAK,OAAL,GAAe,MAAM,CAAC,EAAD,EAAK,KAAK,QAAV,EAAoB,OAAO,IAAI,EAA/B,CAArB;AAEA,WAAK,EAAL,GAAU,QAAQ,EAAlB;AAEA,WAAK,OAAL,GAAe,IAAf,CALyB,C;;AAQzB,WAAK,OAAL,CAAa,MAAb,GAAsB,WAAW,CAAC,KAAK,OAAL,CAAa,MAAd,EAAsB,IAAtB,CAAjC;AAEA,WAAK,KAAL,GAAa,cAAb;AAEA,WAAK,YAAL,GAAoB,EAApB;AACA,WAAK,WAAL,GAAmB,EAAnB;AACH;;AAED,IAAA,UAAU,CAAC,SAAX,GAAuB;;;;;AAKnB,MAAA,QAAQ,EAAE,EALS;;;;;;;AAYnB,MAAA,GAAG,EAAE,UAAS,OAAT,EAAkB;AACnB,QAAA,MAAM,CAAC,KAAK,OAAN,EAAe,OAAf,CAAN,CADmB,C;;AAInB,aAAK,OAAL,IAAgB,KAAK,OAAL,CAAa,WAAb,CAAyB,MAAzB,EAAhB;AACA,eAAO,IAAP;AACH,OAlBkB;;;;;;;AAyBnB,MAAA,aAAa,EAAE,UAAS,eAAT,EAA0B;AACrC,YAAI,cAAc,CAAC,eAAD,EAAkB,eAAlB,EAAmC,IAAnC,CAAlB,EAA4D;AACxD,iBAAO,IAAP;AACH;;AAED,YAAI,YAAY,GAAG,KAAK,YAAxB;AACA,QAAA,eAAe,GAAG,4BAA4B,CAAC,eAAD,EAAkB,IAAlB,CAA9C;;AACA,YAAI,CAAC,YAAY,CAAC,eAAe,CAAC,EAAjB,CAAjB,EAAuC;AACnC,UAAA,YAAY,CAAC,eAAe,CAAC,EAAjB,CAAZ,GAAmC,eAAnC;AACA,UAAA,eAAe,CAAC,aAAhB,CAA8B,IAA9B;AACH;;AACD,eAAO,IAAP;AACH,OArCkB;;;;;;;AA4CnB,MAAA,iBAAiB,EAAE,UAAS,eAAT,EAA0B;AACzC,YAAI,cAAc,CAAC,eAAD,EAAkB,mBAAlB,EAAuC,IAAvC,CAAlB,EAAgE;AAC5D,iBAAO,IAAP;AACH;;AAED,QAAA,eAAe,GAAG,4BAA4B,CAAC,eAAD,EAAkB,IAAlB,CAA9C;AACA,eAAO,KAAK,YAAL,CAAkB,eAAe,CAAC,EAAlC,CAAP;AACA,eAAO,IAAP;AACH,OApDkB;;;;;;;AA2DnB,MAAA,cAAc,EAAE,UAAS,eAAT,EAA0B;AACtC,YAAI,cAAc,CAAC,eAAD,EAAkB,gBAAlB,EAAoC,IAApC,CAAlB,EAA6D;AACzD,iBAAO,IAAP;AACH;;AAED,YAAI,WAAW,GAAG,KAAK,WAAvB;AACA,QAAA,eAAe,GAAG,4BAA4B,CAAC,eAAD,EAAkB,IAAlB,CAA9C;;AACA,YAAI,OAAO,CAAC,WAAD,EAAc,eAAd,CAAP,KAA0C,CAAC,CAA/C,EAAkD;AAC9C,UAAA,WAAW,CAAC,IAAZ,CAAiB,eAAjB;AACA,UAAA,eAAe,CAAC,cAAhB,CAA+B,IAA/B;AACH;;AACD,eAAO,IAAP;AACH,OAvEkB;;;;;;;AA8EnB,MAAA,kBAAkB,EAAE,UAAS,eAAT,EAA0B;AAC1C,YAAI,cAAc,CAAC,eAAD,EAAkB,oBAAlB,EAAwC,IAAxC,CAAlB,EAAiE;AAC7D,iBAAO,IAAP;AACH;;AAED,QAAA,eAAe,GAAG,4BAA4B,CAAC,eAAD,EAAkB,IAAlB,CAA9C;AACA,YAAI,KAAK,GAAG,OAAO,CAAC,KAAK,WAAN,EAAmB,eAAnB,CAAnB;;AACA,YAAI,KAAK,GAAG,CAAC,CAAb,EAAgB;AACZ,eAAK,WAAL,CAAiB,MAAjB,CAAwB,KAAxB,EAA+B,CAA/B;AACH;;AACD,eAAO,IAAP;AACH,OAzFkB;;;;;;AA+FnB,MAAA,kBAAkB,EAAE,YAAW;AAC3B,eAAO,KAAK,WAAL,CAAiB,MAAjB,GAA0B,CAAjC;AACH,OAjGkB;;;;;;;AAwGnB,MAAA,gBAAgB,EAAE,UAAS,eAAT,EAA0B;AACxC,eAAO,CAAC,CAAC,KAAK,YAAL,CAAkB,eAAe,CAAC,EAAlC,CAAT;AACH,OA1GkB;;;;;;;AAiHnB,MAAA,IAAI,EAAE,UAAS,KAAT,EAAgB;AAClB,YAAI,IAAI,GAAG,IAAX;AACA,YAAI,KAAK,GAAG,KAAK,KAAjB;;AAEA,iBAAS,IAAT,CAAc,KAAd,EAAqB;AACjB,UAAA,IAAI,CAAC,OAAL,CAAa,IAAb,CAAkB,KAAlB,EAAyB,KAAzB;AACH,SANiB,C;;;AASlB,YAAI,KAAK,GAAG,WAAZ,EAAyB;AACrB,UAAA,IAAI,CAAC,IAAI,CAAC,OAAL,CAAa,KAAb,GAAqB,QAAQ,CAAC,KAAD,CAA9B,CAAJ;AACH;;AAED,QAAA,IAAI,CAAC,IAAI,CAAC,OAAL,CAAa,KAAd,CAAJ,CAbkB,CAaO;;AAEzB,YAAI,KAAK,CAAC,eAAV,EAA2B;AAAA;AACvB,UAAA,IAAI,CAAC,KAAK,CAAC,eAAP,CAAJ;AACH,SAjBiB,C;;;AAoBlB,YAAI,KAAK,IAAI,WAAb,EAA0B;AACtB,UAAA,IAAI,CAAC,IAAI,CAAC,OAAL,CAAa,KAAb,GAAqB,QAAQ,CAAC,KAAD,CAA9B,CAAJ;AACH;AACJ,OAxIkB;;;;;;;;AAgJnB,MAAA,OAAO,EAAE,UAAS,KAAT,EAAgB;AACrB,YAAI,KAAK,OAAL,EAAJ,EAAoB;AAChB,iBAAO,KAAK,IAAL,CAAU,KAAV,CAAP;AACH,SAHoB,C;;;AAKrB,aAAK,KAAL,GAAa,YAAb;AACH,OAtJkB;;;;;;AA4JnB,MAAA,OAAO,EAAE,YAAW;AAChB,YAAI,CAAC,GAAG,CAAR;;AACA,eAAO,CAAC,GAAG,KAAK,WAAL,CAAiB,MAA5B,EAAoC;AAChC,cAAI,EAAE,KAAK,WAAL,CAAiB,CAAjB,EAAoB,KAApB,IAA6B,YAAY,GAAG,cAA5C,CAAF,CAAJ,EAAoE;AAChE,mBAAO,KAAP;AACH;;AACD,UAAA,CAAC;AACJ;;AACD,eAAO,IAAP;AACH,OArKkB;;;;;;AA2KnB,MAAA,SAAS,EAAE,UAAS,SAAT,EAAoB;;;AAG3B,YAAI,cAAc,GAAG,MAAM,CAAC,EAAD,EAAK,SAAL,CAA3B,CAH2B,C;;AAM3B,YAAI,CAAC,QAAQ,CAAC,KAAK,OAAL,CAAa,MAAd,EAAsB,CAAC,IAAD,EAAO,cAAP,CAAtB,CAAb,EAA4D;AACxD,eAAK,KAAL;AACA,eAAK,KAAL,GAAa,YAAb;AACA;AACH,SAV0B,C;;;AAa3B,YAAI,KAAK,KAAL,IAAc,gBAAgB,GAAG,eAAnB,GAAqC,YAAnD,CAAJ,EAAsE;AAClE,eAAK,KAAL,GAAa,cAAb;AACH;;AAED,aAAK,KAAL,GAAa,KAAK,OAAL,CAAa,cAAb,CAAb,CAjB2B,C;;;AAqB3B,YAAI,KAAK,KAAL,IAAc,WAAW,GAAG,aAAd,GAA8B,WAA9B,GAA4C,eAA1D,CAAJ,EAAgF;AAC5E,eAAK,OAAL,CAAa,cAAb;AACH;AACJ,OAnMkB;;;;;;;;;AA4MnB,MAAA,OAAO,EAAE,UAAS,SAAT,EAAoB,CAAG,CA5Mb;AA4Ma;;;;;;;AAOhC,MAAA,cAAc,EAAE,YAAW,CAAG,CAnNX;;;;;;;AA0NnB,MAAA,KAAK,EAAE,YAAW,CAAG;AA1NF,KAAvB;;;;;;;AAkOA,aAAS,QAAT,CAAkB,KAAlB,EAAyB;AACrB,UAAI,KAAK,GAAG,eAAZ,EAA6B;AACzB,eAAO,QAAP;AACH,OAFD,MAEO,IAAI,KAAK,GAAG,WAAZ,EAAyB;AAC5B,eAAO,KAAP;AACH,OAFM,MAEA,IAAI,KAAK,GAAG,aAAZ,EAA2B;AAC9B,eAAO,MAAP;AACH,OAFM,MAEA,IAAI,KAAK,GAAG,WAAZ,EAAyB;AAC5B,eAAO,OAAP;AACH;;AACD,aAAO,EAAP;AACH;;;;;;;;AAOD,aAAS,YAAT,CAAsB,SAAtB,EAAiC;AAC7B,UAAI,SAAS,IAAI,cAAjB,EAAiC;AAC7B,eAAO,MAAP;AACH,OAFD,MAEO,IAAI,SAAS,IAAI,YAAjB,EAA+B;AAClC,eAAO,IAAP;AACH,OAFM,MAEA,IAAI,SAAS,IAAI,cAAjB,EAAiC;AACpC,eAAO,MAAP;AACH,OAFM,MAEA,IAAI,SAAS,IAAI,eAAjB,EAAkC;AACrC,eAAO,OAAP;AACH;;AACD,aAAO,EAAP;AACH;;;;;;;;;AAQD,aAAS,4BAAT,CAAsC,eAAtC,EAAuD,UAAvD,EAAmE;AAC/D,UAAI,OAAO,GAAG,UAAU,CAAC,OAAzB;;AACA,UAAI,OAAJ,EAAa;AACT,eAAO,OAAO,CAAC,GAAR,CAAY,eAAZ,CAAP;AACH;;AACD,aAAO,eAAP;AACH;;;;;;;;AAOD,aAAS,cAAT,GAA0B;AACtB,MAAA,UAAU,CAAC,KAAX,CAAiB,IAAjB,EAAuB,SAAvB;AACH;;AAED,IAAA,OAAO,CAAC,cAAD,EAAiB,UAAjB,EAA6B;;;;;AAKhC,MAAA,QAAQ,EAAE;;;;;AAKN,QAAA,QAAQ,EAAE;AALJ,OALsB;;;;;;;;AAmBhC,MAAA,QAAQ,EAAE,UAAS,KAAT,EAAgB;AACtB,YAAI,cAAc,GAAG,KAAK,OAAL,CAAa,QAAlC;AACA,eAAO,cAAc,KAAK,CAAnB,IAAwB,KAAK,CAAC,QAAN,CAAe,MAAf,KAA0B,cAAzD;AACH,OAtB+B;;;;;;;;AA8BhC,MAAA,OAAO,EAAE,UAAS,KAAT,EAAgB;AACrB,YAAI,KAAK,GAAG,KAAK,KAAjB;AACA,YAAI,SAAS,GAAG,KAAK,CAAC,SAAtB;AAEA,YAAI,YAAY,GAAG,KAAK,IAAI,WAAW,GAAG,aAAlB,CAAxB;AACA,YAAI,OAAO,GAAG,KAAK,QAAL,CAAc,KAAd,CAAd,CALqB,C;;AAQrB,YAAI,YAAY,KAAK,SAAS,GAAG,YAAZ,IAA4B,CAAC,OAAlC,CAAhB,EAA4D;AACxD,iBAAO,KAAK,GAAG,eAAf;AACH,SAFD,MAEO,IAAI,YAAY,IAAI,OAApB,EAA6B;AAChC,cAAI,SAAS,GAAG,SAAhB,EAA2B;AACvB,mBAAO,KAAK,GAAG,WAAf;AACH,WAFD,MAEO,IAAI,EAAE,KAAK,GAAG,WAAV,CAAJ,EAA4B;AAC/B,mBAAO,WAAP;AACH;;AACD,iBAAO,KAAK,GAAG,aAAf;AACH;;AACD,eAAO,YAAP;AACH;AAjD+B,KAA7B,CAAP;;;;;;;;AA0DA,aAAS,aAAT,GAAyB;AACrB,MAAA,cAAc,CAAC,KAAf,CAAqB,IAArB,EAA2B,SAA3B;AAEA,WAAK,EAAL,GAAU,IAAV;AACA,WAAK,EAAL,GAAU,IAAV;AACH;;AAED,IAAA,OAAO,CAAC,aAAD,EAAgB,cAAhB,EAAgC;;;;;AAKnC,MAAA,QAAQ,EAAE;AACN,QAAA,KAAK,EAAE,KADD;AAEN,QAAA,SAAS,EAAE,EAFL;AAGN,QAAA,QAAQ,EAAE,CAHJ;AAIN,QAAA,SAAS,EAAE;AAJL,OALyB;AAYnC,MAAA,cAAc,EAAE,YAAW;AACvB,YAAI,SAAS,GAAG,KAAK,OAAL,CAAa,SAA7B;AACA,YAAI,OAAO,GAAG,EAAd;;AACA,YAAI,SAAS,GAAG,oBAAhB,EAAsC;AAClC,UAAA,OAAO,CAAC,IAAR,CAAa,kBAAb;AACH;;AACD,YAAI,SAAS,GAAG,kBAAhB,EAAoC;AAChC,UAAA,OAAO,CAAC,IAAR,CAAa,kBAAb;AACH;;AACD,eAAO,OAAP;AACH,OAtBkC;AAwBnC,MAAA,aAAa,EAAE,UAAS,KAAT,EAAgB;AAC3B,YAAI,OAAO,GAAG,KAAK,OAAnB;AACA,YAAI,QAAQ,GAAG,IAAf;AACA,YAAI,QAAQ,GAAG,KAAK,CAAC,QAArB;AACA,YAAI,SAAS,GAAG,KAAK,CAAC,SAAtB;AACA,YAAI,CAAC,GAAG,KAAK,CAAC,MAAd;AACA,YAAI,CAAC,GAAG,KAAK,CAAC,MAAd,CAN2B,C;;AAS3B,YAAI,EAAE,SAAS,GAAG,OAAO,CAAC,SAAtB,CAAJ,EAAsC;AAClC,cAAI,OAAO,CAAC,SAAR,GAAoB,oBAAxB,EAA8C;AAC1C,YAAA,SAAS,GAAI,CAAC,KAAK,CAAP,GAAY,cAAZ,GAA8B,CAAC,GAAG,CAAL,GAAU,cAAV,GAA2B,eAApE;AACA,YAAA,QAAQ,GAAG,CAAC,IAAI,KAAK,EAArB;AACA,YAAA,QAAQ,GAAG,IAAI,CAAC,GAAL,CAAS,KAAK,CAAC,MAAf,CAAX;AACH,WAJD,MAIO;AACH,YAAA,SAAS,GAAI,CAAC,KAAK,CAAP,GAAY,cAAZ,GAA8B,CAAC,GAAG,CAAL,GAAU,YAAV,GAAyB,cAAlE;AACA,YAAA,QAAQ,GAAG,CAAC,IAAI,KAAK,EAArB;AACA,YAAA,QAAQ,GAAG,IAAI,CAAC,GAAL,CAAS,KAAK,CAAC,MAAf,CAAX;AACH;AACJ;;AACD,QAAA,KAAK,CAAC,SAAN,GAAkB,SAAlB;AACA,eAAO,QAAQ,IAAI,QAAQ,GAAG,OAAO,CAAC,SAA/B,IAA4C,SAAS,GAAG,OAAO,CAAC,SAAvE;AACH,OA9CkC;AAgDnC,MAAA,QAAQ,EAAE,UAAS,KAAT,EAAgB;AACtB,eAAO,cAAc,CAAC,SAAf,CAAyB,QAAzB,CAAkC,IAAlC,CAAuC,IAAvC,EAA6C,KAA7C,MACF,KAAK,KAAL,GAAa,WAAb,IAA6B,EAAE,KAAK,KAAL,GAAa,WAAf,KAA+B,KAAK,aAAL,CAAmB,KAAnB,CAD1D,CAAP;AAEH,OAnDkC;AAqDnC,MAAA,IAAI,EAAE,UAAS,KAAT,EAAgB;AAElB,aAAK,EAAL,GAAU,KAAK,CAAC,MAAhB;AACA,aAAK,EAAL,GAAU,KAAK,CAAC,MAAhB;AAEA,YAAI,SAAS,GAAG,YAAY,CAAC,KAAK,CAAC,SAAP,CAA5B;;AAEA,YAAI,SAAJ,EAAe;AACX,UAAA,KAAK,CAAC,eAAN,GAAwB,KAAK,OAAL,CAAa,KAAb,GAAqB,SAA7C;AACH;;AACD,aAAK,MAAL,CAAY,IAAZ,CAAiB,IAAjB,CAAsB,IAAtB,EAA4B,KAA5B;AACH;AAhEkC,KAAhC,CAAP;;;;;;;;AAyEA,aAAS,eAAT,GAA2B;AACvB,MAAA,cAAc,CAAC,KAAf,CAAqB,IAArB,EAA2B,SAA3B;AACH;;AAED,IAAA,OAAO,CAAC,eAAD,EAAkB,cAAlB,EAAkC;;;;;AAKrC,MAAA,QAAQ,EAAE;AACN,QAAA,KAAK,EAAE,OADD;AAEN,QAAA,SAAS,EAAE,CAFL;AAGN,QAAA,QAAQ,EAAE;AAHJ,OAL2B;AAWrC,MAAA,cAAc,EAAE,YAAW;AACvB,eAAO,CAAC,iBAAD,CAAP;AACH,OAboC;AAerC,MAAA,QAAQ,EAAE,UAAS,KAAT,EAAgB;AACtB,eAAO,KAAK,MAAL,CAAY,QAAZ,CAAqB,IAArB,CAA0B,IAA1B,EAAgC,KAAhC,MACF,IAAI,CAAC,GAAL,CAAS,KAAK,CAAC,KAAN,GAAc,CAAvB,IAA4B,KAAK,OAAL,CAAa,SAAzC,IAAsD,KAAK,KAAL,GAAa,WADjE,CAAP;AAEH,OAlBoC;AAoBrC,MAAA,IAAI,EAAE,UAAS,KAAT,EAAgB;AAClB,YAAI,KAAK,CAAC,KAAN,KAAgB,CAApB,EAAuB;AACnB,cAAI,KAAK,GAAG,KAAK,CAAC,KAAN,GAAc,CAAd,GAAkB,IAAlB,GAAyB,KAArC;AACA,UAAA,KAAK,CAAC,eAAN,GAAwB,KAAK,OAAL,CAAa,KAAb,GAAqB,KAA7C;AACH;;AACD,aAAK,MAAL,CAAY,IAAZ,CAAiB,IAAjB,CAAsB,IAAtB,EAA4B,KAA5B;AACH;AA1BoC,KAAlC,CAAP;;;;;;;;AAmCA,aAAS,eAAT,GAA2B;AACvB,MAAA,UAAU,CAAC,KAAX,CAAiB,IAAjB,EAAuB,SAAvB;AAEA,WAAK,MAAL,GAAc,IAAd;AACA,WAAK,MAAL,GAAc,IAAd;AACH;;AAED,IAAA,OAAO,CAAC,eAAD,EAAkB,UAAlB,EAA8B;;;;;AAKjC,MAAA,QAAQ,EAAE;AACN,QAAA,KAAK,EAAE,OADD;AAEN,QAAA,QAAQ,EAAE,CAFJ;AAGN,QAAA,IAAI,EAAE,GAHA;AAGG;AACT,QAAA,SAAS,EAAE,CAJL,CAIM;;AAJN,OALuB;AAYjC,MAAA,cAAc,EAAE,YAAW;AACvB,eAAO,CAAC,iBAAD,CAAP;AACH,OAdgC;AAgBjC,MAAA,OAAO,EAAE,UAAS,KAAT,EAAgB;AACrB,YAAI,OAAO,GAAG,KAAK,OAAnB;AACA,YAAI,aAAa,GAAG,KAAK,CAAC,QAAN,CAAe,MAAf,KAA0B,OAAO,CAAC,QAAtD;AACA,YAAI,aAAa,GAAG,KAAK,CAAC,QAAN,GAAiB,OAAO,CAAC,SAA7C;AACA,YAAI,SAAS,GAAG,KAAK,CAAC,SAAN,GAAkB,OAAO,CAAC,IAA1C;AAEA,aAAK,MAAL,GAAc,KAAd,CANqB,C;;;AAUrB,YAAI,CAAC,aAAD,IAAkB,CAAC,aAAnB,IAAqC,KAAK,CAAC,SAAN,IAAmB,SAAS,GAAG,YAA/B,KAAgD,CAAC,SAA1F,EAAsG;AAClG,eAAK,KAAL;AACH,SAFD,MAEO,IAAI,KAAK,CAAC,SAAN,GAAkB,WAAtB,EAAmC;AACtC,eAAK,KAAL;AACA,eAAK,MAAL,GAAc,iBAAiB,CAAC,YAAW;AACvC,iBAAK,KAAL,GAAa,gBAAb;AACA,iBAAK,OAAL;AACH,WAH8B,EAG5B,OAAO,CAAC,IAHoB,EAGd,IAHc,CAA/B;AAIH,SANM,MAMA,IAAI,KAAK,CAAC,SAAN,GAAkB,SAAtB,EAAiC;AACpC,iBAAO,gBAAP;AACH;;AACD,eAAO,YAAP;AACH,OAtCgC;AAwCjC,MAAA,KAAK,EAAE,YAAW;AACd,QAAA,YAAY,CAAC,KAAK,MAAN,CAAZ;AACH,OA1CgC;AA4CjC,MAAA,IAAI,EAAE,UAAS,KAAT,EAAgB;AAClB,YAAI,KAAK,KAAL,KAAe,gBAAnB,EAAqC;AACjC;AACH;;AAED,YAAI,KAAK,IAAK,KAAK,CAAC,SAAN,GAAkB,SAAhC,EAA4C;AACxC,eAAK,OAAL,CAAa,IAAb,CAAkB,KAAK,OAAL,CAAa,KAAb,GAAqB,IAAvC,EAA6C,KAA7C;AACH,SAFD,MAEO;AACH,eAAK,MAAL,CAAY,SAAZ,GAAwB,GAAG,EAA3B;AACA,eAAK,OAAL,CAAa,IAAb,CAAkB,KAAK,OAAL,CAAa,KAA/B,EAAsC,KAAK,MAA3C;AACH;AACJ;AAvDgC,KAA9B,CAAP;;;;;;;;AAgEA,aAAS,gBAAT,GAA4B;AACxB,MAAA,cAAc,CAAC,KAAf,CAAqB,IAArB,EAA2B,SAA3B;AACH;;AAED,IAAA,OAAO,CAAC,gBAAD,EAAmB,cAAnB,EAAmC;;;;;AAKtC,MAAA,QAAQ,EAAE;AACN,QAAA,KAAK,EAAE,QADD;AAEN,QAAA,SAAS,EAAE,CAFL;AAGN,QAAA,QAAQ,EAAE;AAHJ,OAL4B;AAWtC,MAAA,cAAc,EAAE,YAAW;AACvB,eAAO,CAAC,iBAAD,CAAP;AACH,OAbqC;AAetC,MAAA,QAAQ,EAAE,UAAS,KAAT,EAAgB;AACtB,eAAO,KAAK,MAAL,CAAY,QAAZ,CAAqB,IAArB,CAA0B,IAA1B,EAAgC,KAAhC,MACF,IAAI,CAAC,GAAL,CAAS,KAAK,CAAC,QAAf,IAA2B,KAAK,OAAL,CAAa,SAAxC,IAAqD,KAAK,KAAL,GAAa,WADhE,CAAP;AAEH;AAlBqC,KAAnC,CAAP;;;;;;;;AA2BA,aAAS,eAAT,GAA2B;AACvB,MAAA,cAAc,CAAC,KAAf,CAAqB,IAArB,EAA2B,SAA3B;AACH;;AAED,IAAA,OAAO,CAAC,eAAD,EAAkB,cAAlB,EAAkC;;;;;AAKrC,MAAA,QAAQ,EAAE;AACN,QAAA,KAAK,EAAE,OADD;AAEN,QAAA,SAAS,EAAE,EAFL;AAGN,QAAA,QAAQ,EAAE,GAHJ;AAIN,QAAA,SAAS,EAAE,oBAAoB,GAAG,kBAJ5B;AAKN,QAAA,QAAQ,EAAE;AALJ,OAL2B;AAarC,MAAA,cAAc,EAAE,YAAW;AACvB,eAAO,aAAa,CAAC,SAAd,CAAwB,cAAxB,CAAuC,IAAvC,CAA4C,IAA5C,CAAP;AACH,OAfoC;AAiBrC,MAAA,QAAQ,EAAE,UAAS,KAAT,EAAgB;AACtB,YAAI,SAAS,GAAG,KAAK,OAAL,CAAa,SAA7B;AACA,YAAI,QAAJ;;AAEA,YAAI,SAAS,IAAI,oBAAoB,GAAG,kBAA3B,CAAb,EAA6D;AACzD,UAAA,QAAQ,GAAG,KAAK,CAAC,eAAjB;AACH,SAFD,MAEO,IAAI,SAAS,GAAG,oBAAhB,EAAsC;AACzC,UAAA,QAAQ,GAAG,KAAK,CAAC,gBAAjB;AACH,SAFM,MAEA,IAAI,SAAS,GAAG,kBAAhB,EAAoC;AACvC,UAAA,QAAQ,GAAG,KAAK,CAAC,gBAAjB;AACH;;AAED,eAAO,KAAK,MAAL,CAAY,QAAZ,CAAqB,IAArB,CAA0B,IAA1B,EAAgC,KAAhC,KACH,SAAS,GAAG,KAAK,CAAC,eADf,IAEH,KAAK,CAAC,QAAN,GAAiB,KAAK,OAAL,CAAa,SAF3B,IAGH,KAAK,CAAC,WAAN,IAAqB,KAAK,OAAL,CAAa,QAH/B,IAIH,GAAG,CAAC,QAAD,CAAH,GAAgB,KAAK,OAAL,CAAa,QAJ1B,IAIsC,KAAK,CAAC,SAAN,GAAkB,SAJ/D;AAKH,OAlCoC;AAoCrC,MAAA,IAAI,EAAE,UAAS,KAAT,EAAgB;AAClB,YAAI,SAAS,GAAG,YAAY,CAAC,KAAK,CAAC,eAAP,CAA5B;;AACA,YAAI,SAAJ,EAAe;AACX,eAAK,OAAL,CAAa,IAAb,CAAkB,KAAK,OAAL,CAAa,KAAb,GAAqB,SAAvC,EAAkD,KAAlD;AACH;;AAED,aAAK,OAAL,CAAa,IAAb,CAAkB,KAAK,OAAL,CAAa,KAA/B,EAAsC,KAAtC;AACH;AA3CoC,KAAlC,CAAP;;;;;;;;;;;;AAwDA,aAAS,aAAT,GAAyB;AACrB,MAAA,UAAU,CAAC,KAAX,CAAiB,IAAjB,EAAuB,SAAvB,EADqB,C;;;AAKrB,WAAK,KAAL,GAAa,KAAb;AACA,WAAK,OAAL,GAAe,KAAf;AAEA,WAAK,MAAL,GAAc,IAAd;AACA,WAAK,MAAL,GAAc,IAAd;AACA,WAAK,KAAL,GAAa,CAAb;AACH;;AAED,IAAA,OAAO,CAAC,aAAD,EAAgB,UAAhB,EAA4B;;;;;AAK/B,MAAA,QAAQ,EAAE;AACN,QAAA,KAAK,EAAE,KADD;AAEN,QAAA,QAAQ,EAAE,CAFJ;AAGN,QAAA,IAAI,EAAE,CAHA;AAIN,QAAA,QAAQ,EAAE,GAJJ;AAIO;AACb,QAAA,IAAI,EAAE,GALA;AAKG;AACT,QAAA,SAAS,EAAE,CANL;AAMM;AACZ,QAAA,YAAY,EAAE,EAPR,CAOU;;AAPV,OALqB;AAe/B,MAAA,cAAc,EAAE,YAAW;AACvB,eAAO,CAAC,yBAAD,CAAP;AACH,OAjB8B;AAmB/B,MAAA,OAAO,EAAE,UAAS,KAAT,EAAgB;AACrB,YAAI,OAAO,GAAG,KAAK,OAAnB;AAEA,YAAI,aAAa,GAAG,KAAK,CAAC,QAAN,CAAe,MAAf,KAA0B,OAAO,CAAC,QAAtD;AACA,YAAI,aAAa,GAAG,KAAK,CAAC,QAAN,GAAiB,OAAO,CAAC,SAA7C;AACA,YAAI,cAAc,GAAG,KAAK,CAAC,SAAN,GAAkB,OAAO,CAAC,IAA/C;AAEA,aAAK,KAAL;;AAEA,YAAK,KAAK,CAAC,SAAN,GAAkB,WAAnB,IAAoC,KAAK,KAAL,KAAe,CAAvD,EAA2D;AACvD,iBAAO,KAAK,WAAL,EAAP;AACH,SAXoB,C;;;;AAerB,YAAI,aAAa,IAAI,cAAjB,IAAmC,aAAvC,EAAsD;AAClD,cAAI,KAAK,CAAC,SAAN,IAAmB,SAAvB,EAAkC;AAC9B,mBAAO,KAAK,WAAL,EAAP;AACH;;AAED,cAAI,aAAa,GAAG,KAAK,KAAL,GAAc,KAAK,CAAC,SAAN,GAAkB,KAAK,KAAvB,GAA+B,OAAO,CAAC,QAArD,GAAiE,IAArF;AACA,cAAI,aAAa,GAAG,CAAC,KAAK,OAAN,IAAiB,WAAW,CAAC,KAAK,OAAN,EAAe,KAAK,CAAC,MAArB,CAAX,GAA0C,OAAO,CAAC,YAAvF;AAEA,eAAK,KAAL,GAAa,KAAK,CAAC,SAAnB;AACA,eAAK,OAAL,GAAe,KAAK,CAAC,MAArB;;AAEA,cAAI,CAAC,aAAD,IAAkB,CAAC,aAAvB,EAAsC;AAClC,iBAAK,KAAL,GAAa,CAAb;AACH,WAFD,MAEO;AACH,iBAAK,KAAL,IAAc,CAAd;AACH;;AAED,eAAK,MAAL,GAAc,KAAd,CAjBkD,C;;;AAqBlD,cAAI,QAAQ,GAAG,KAAK,KAAL,GAAa,OAAO,CAAC,IAApC;;AACA,cAAI,QAAQ,KAAK,CAAjB,EAAoB;;;AAGhB,gBAAI,CAAC,KAAK,kBAAL,EAAL,EAAgC;AAC5B,qBAAO,gBAAP;AACH,aAFD,MAEO;AACH,mBAAK,MAAL,GAAc,iBAAiB,CAAC,YAAW;AACvC,qBAAK,KAAL,GAAa,gBAAb;AACA,qBAAK,OAAL;AACH,eAH8B,EAG5B,OAAO,CAAC,QAHoB,EAGV,IAHU,CAA/B;AAIA,qBAAO,WAAP;AACH;AACJ;AACJ;;AACD,eAAO,YAAP;AACH,OAvE8B;AAyE/B,MAAA,WAAW,EAAE,YAAW;AACpB,aAAK,MAAL,GAAc,iBAAiB,CAAC,YAAW;AACvC,eAAK,KAAL,GAAa,YAAb;AACH,SAF8B,EAE5B,KAAK,OAAL,CAAa,QAFe,EAEL,IAFK,CAA/B;AAGA,eAAO,YAAP;AACH,OA9E8B;AAgF/B,MAAA,KAAK,EAAE,YAAW;AACd,QAAA,YAAY,CAAC,KAAK,MAAN,CAAZ;AACH,OAlF8B;AAoF/B,MAAA,IAAI,EAAE,YAAW;AACb,YAAI,KAAK,KAAL,IAAc,gBAAlB,EAAoC;AAChC,eAAK,MAAL,CAAY,QAAZ,GAAuB,KAAK,KAA5B;AACA,eAAK,OAAL,CAAa,IAAb,CAAkB,KAAK,OAAL,CAAa,KAA/B,EAAsC,KAAK,MAA3C;AACH;AACJ;AAzF8B,KAA5B,CAAP;;;;;;;;AAkGA,aAAS,MAAT,CAAgB,OAAhB,EAAyB,OAAzB,EAAkC;AAC9B,MAAA,OAAO,GAAG,OAAO,IAAI,EAArB;AACA,MAAA,OAAO,CAAC,WAAR,GAAsB,WAAW,CAAC,OAAO,CAAC,WAAT,EAAsB,MAAM,CAAC,QAAP,CAAgB,MAAtC,CAAjC;AACA,aAAO,IAAI,OAAJ,CAAY,OAAZ,EAAqB,OAArB,CAAP;AACH;;;;;;AAKD,IAAA,MAAM,CAAC,OAAP,GAAiB,OAAjB;;;;;;AAMA,IAAA,MAAM,CAAC,QAAP,GAAkB;;;;;;;AAOd,MAAA,SAAS,EAAE,KAPG;;;;;;;;AAed,MAAA,WAAW,EAAE,oBAfC;;;;;;AAqBd,MAAA,MAAM,EAAE,IArBM;;;;;;;;;AA8Bd,MAAA,WAAW,EAAE,IA9BC;;;;;;;AAqCd,MAAA,UAAU,EAAE,IArCE;;;;;;;AA4Cd,MAAA,MAAM,EAAE,C;AAEJ,OAAC,gBAAD,EAAmB;AAAC,QAAA,MAAM,EAAE;AAAT,OAAnB,CAFI,EAGJ,CAAC,eAAD,EAAkB;AAAC,QAAA,MAAM,EAAE;AAAT,OAAlB,EAAmC,CAAC,QAAD,CAAnC,CAHI,EAIJ,CAAC,eAAD,EAAkB;AAAC,QAAA,SAAS,EAAE;AAAZ,OAAlB,CAJI,EAKJ,CAAC,aAAD,EAAgB;AAAC,QAAA,SAAS,EAAE;AAAZ,OAAhB,EAAmD,CAAC,OAAD,CAAnD,CALI,EAMJ,CAAC,aAAD,CANI,EAOJ,CAAC,aAAD,EAAgB;AAAC,QAAA,KAAK,EAAE,WAAR;AAAqB,QAAA,IAAI,EAAE;AAA3B,OAAhB,EAA+C,CAAC,KAAD,CAA/C,CAPI,EAQJ,CAAC,eAAD,CARI,CA5CM;;;;;;;AA4Dd,MAAA,QAAQ,EAAE;;;;;;AAMN,QAAA,UAAU,EAAE,MANN;;;;;;;AAaN,QAAA,WAAW,EAAE,MAbP;;;;;;;;;AAsBN,QAAA,YAAY,EAAE,MAtBR;;;;;;;AA6BN,QAAA,cAAc,EAAE,MA7BV;;;;;;;AAoCN,QAAA,QAAQ,EAAE,MApCJ;;;;;;;;AA4CN,QAAA,iBAAiB,EAAE;AA5Cb;AA5DI,KAAlB;AA4GA,QAAI,IAAI,GAAG,CAAX;AACA,QAAI,WAAW,GAAG,CAAlB;;;;;;;;AAQA,aAAS,OAAT,CAAiB,OAAjB,EAA0B,OAA1B,EAAmC;AAC/B,WAAK,OAAL,GAAe,MAAM,CAAC,EAAD,EAAK,MAAM,CAAC,QAAZ,EAAsB,OAAO,IAAI,EAAjC,CAArB;AAEA,WAAK,OAAL,CAAa,WAAb,GAA2B,KAAK,OAAL,CAAa,WAAb,IAA4B,OAAvD;AAEA,WAAK,QAAL,GAAgB,EAAhB;AACA,WAAK,OAAL,GAAe,EAAf;AACA,WAAK,WAAL,GAAmB,EAAnB;AACA,WAAK,WAAL,GAAmB,EAAnB;AAEA,WAAK,OAAL,GAAe,OAAf;AACA,WAAK,KAAL,GAAa,mBAAmB,CAAC,IAAD,CAAhC;AACA,WAAK,WAAL,GAAmB,IAAI,WAAJ,CAAgB,IAAhB,EAAsB,KAAK,OAAL,CAAa,WAAnC,CAAnB;AAEA,MAAA,cAAc,CAAC,IAAD,EAAO,IAAP,CAAd;AAEA,MAAA,IAAI,CAAC,KAAK,OAAL,CAAa,WAAd,EAA2B,UAAS,IAAT,EAAe;AAC1C,YAAI,UAAU,GAAG,KAAK,GAAL,CAAS,IAAK,IAAI,CAAC,CAAD,CAAT,CAAc,IAAI,CAAC,CAAD,CAAlB,CAAT,CAAjB;AACA,QAAA,IAAI,CAAC,CAAD,CAAJ,IAAW,UAAU,CAAC,aAAX,CAAyB,IAAI,CAAC,CAAD,CAA7B,CAAX;AACA,QAAA,IAAI,CAAC,CAAD,CAAJ,IAAW,UAAU,CAAC,cAAX,CAA0B,IAAI,CAAC,CAAD,CAA9B,CAAX;AACH,OAJG,EAID,IAJC,CAAJ;AAKH;;AAED,IAAA,OAAO,CAAC,SAAR,GAAoB;;;;;;AAMhB,MAAA,GAAG,EAAE,UAAS,OAAT,EAAkB;AACnB,QAAA,MAAM,CAAC,KAAK,OAAN,EAAe,OAAf,CAAN,CADmB,C;;AAInB,YAAI,OAAO,CAAC,WAAZ,EAAyB;AACrB,eAAK,WAAL,CAAiB,MAAjB;AACH;;AACD,YAAI,OAAO,CAAC,WAAZ,EAAyB;;AAErB,eAAK,KAAL,CAAW,OAAX;AACA,eAAK,KAAL,CAAW,MAAX,GAAoB,OAAO,CAAC,WAA5B;AACA,eAAK,KAAL,CAAW,IAAX;AACH;;AACD,eAAO,IAAP;AACH,OApBe;;;;;;;;AA4BhB,MAAA,IAAI,EAAE,UAAS,KAAT,EAAgB;AAClB,aAAK,OAAL,CAAa,OAAb,GAAuB,KAAK,GAAG,WAAH,GAAiB,IAA7C;AACH,OA9Be;;;;;;;;AAsChB,MAAA,SAAS,EAAE,UAAS,SAAT,EAAoB;AAC3B,YAAI,OAAO,GAAG,KAAK,OAAnB;;AACA,YAAI,OAAO,CAAC,OAAZ,EAAqB;AACjB;AACH,SAJ0B,C;;;AAO3B,aAAK,WAAL,CAAiB,eAAjB,CAAiC,SAAjC;AAEA,YAAI,UAAJ;AACA,YAAI,WAAW,GAAG,KAAK,WAAvB,CAV2B,C;;;;AAe3B,YAAI,aAAa,GAAG,OAAO,CAAC,aAA5B,CAf2B,C;;;AAmB3B,YAAI,CAAC,aAAD,IAAmB,aAAa,IAAI,aAAa,CAAC,KAAd,GAAsB,gBAA9D,EAAiF;AAC7E,UAAA,aAAa,GAAG,OAAO,CAAC,aAAR,GAAwB,IAAxC;AACH;;AAED,YAAI,CAAC,GAAG,CAAR;;AACA,eAAO,CAAC,GAAG,WAAW,CAAC,MAAvB,EAA+B;AAC3B,UAAA,UAAU,GAAG,WAAW,CAAC,CAAD,CAAxB,CAD2B,C;;;;;;;AAS3B,cAAI,OAAO,CAAC,OAAR,KAAoB,WAApB,MAA+B;AAC3B,WAAC,aAAD,IAAkB,UAAU,IAAI,aAAhC,IAA6C;AAC7C,UAAA,UAAU,CAAC,gBAAX,CAA4B,aAA5B,CAFJ,CAAJ,EAEqD;AAAA;AACjD,YAAA,UAAU,CAAC,SAAX,CAAqB,SAArB;AACH,WAJD,MAIO;AACH,YAAA,UAAU,CAAC,KAAX;AACH,WAf0B,C;;;;AAmB3B,cAAI,CAAC,aAAD,IAAkB,UAAU,CAAC,KAAX,IAAoB,WAAW,GAAG,aAAd,GAA8B,WAAlD,CAAtB,EAAsF;AAClF,YAAA,aAAa,GAAG,OAAO,CAAC,aAAR,GAAwB,UAAxC;AACH;;AACD,UAAA,CAAC;AACJ;AACJ,OAtFe;;;;;;;AA6FhB,MAAA,GAAG,EAAE,UAAS,UAAT,EAAqB;AACtB,YAAI,UAAU,YAAY,UAA1B,EAAsC;AAClC,iBAAO,UAAP;AACH;;AAED,YAAI,WAAW,GAAG,KAAK,WAAvB;;AACA,aAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,WAAW,CAAC,MAAhC,EAAwC,CAAC,EAAzC,EAA6C;AACzC,cAAI,WAAW,CAAC,CAAD,CAAX,CAAe,OAAf,CAAuB,KAAvB,IAAgC,UAApC,EAAgD;AAC5C,mBAAO,WAAW,CAAC,CAAD,CAAlB;AACH;AACJ;;AACD,eAAO,IAAP;AACH,OAzGe;;;;;;;;AAiHhB,MAAA,GAAG,EAAE,UAAS,UAAT,EAAqB;AACtB,YAAI,cAAc,CAAC,UAAD,EAAa,KAAb,EAAoB,IAApB,CAAlB,EAA6C;AACzC,iBAAO,IAAP;AACH,SAHqB,C;;;AAMtB,YAAI,QAAQ,GAAG,KAAK,GAAL,CAAS,UAAU,CAAC,OAAX,CAAmB,KAA5B,CAAf;;AACA,YAAI,QAAJ,EAAc;AACV,eAAK,MAAL,CAAY,QAAZ;AACH;;AAED,aAAK,WAAL,CAAiB,IAAjB,CAAsB,UAAtB;AACA,QAAA,UAAU,CAAC,OAAX,GAAqB,IAArB;AAEA,aAAK,WAAL,CAAiB,MAAjB;AACA,eAAO,UAAP;AACH,OAjIe;;;;;;;AAwIhB,MAAA,MAAM,EAAE,UAAS,UAAT,EAAqB;AACzB,YAAI,cAAc,CAAC,UAAD,EAAa,QAAb,EAAuB,IAAvB,CAAlB,EAAgD;AAC5C,iBAAO,IAAP;AACH;;AAED,QAAA,UAAU,GAAG,KAAK,GAAL,CAAS,UAAT,CAAb,CALyB,C;;AAQzB,YAAI,UAAJ,EAAgB;AACZ,cAAI,WAAW,GAAG,KAAK,WAAvB;AACA,cAAI,KAAK,GAAG,OAAO,CAAC,WAAD,EAAc,UAAd,CAAnB;;AAEA,cAAI,KAAK,KAAK,CAAC,CAAf,EAAkB;AACd,YAAA,WAAW,CAAC,MAAZ,CAAmB,KAAnB,EAA0B,CAA1B;AACA,iBAAK,WAAL,CAAiB,MAAjB;AACH;AACJ;;AAED,eAAO,IAAP;AACH,OA3Je;;;;;;;;AAmKhB,MAAA,EAAE,EAAE,UAAS,MAAT,EAAiB,OAAjB,EAA0B;AAC1B,YAAI,MAAM,KAAK,SAAf,EAA0B;AACtB;AACH;;AACD,YAAI,OAAO,KAAK,SAAhB,EAA2B;AACvB;AACH;;AAED,YAAI,QAAQ,GAAG,KAAK,QAApB;AACA,QAAA,IAAI,CAAC,QAAQ,CAAC,MAAD,CAAT,EAAmB,UAAS,KAAT,EAAgB;AACnC,UAAA,QAAQ,CAAC,KAAD,CAAR,GAAkB,QAAQ,CAAC,KAAD,CAAR,IAAmB,EAArC;AACA,UAAA,QAAQ,CAAC,KAAD,CAAR,CAAgB,IAAhB,CAAqB,OAArB;AACH,SAHG,CAAJ;AAIA,eAAO,IAAP;AACH,OAjLe;;;;;;;;AAyLhB,MAAA,GAAG,EAAE,UAAS,MAAT,EAAiB,OAAjB,EAA0B;AAC3B,YAAI,MAAM,KAAK,SAAf,EAA0B;AACtB;AACH;;AAED,YAAI,QAAQ,GAAG,KAAK,QAApB;AACA,QAAA,IAAI,CAAC,QAAQ,CAAC,MAAD,CAAT,EAAmB,UAAS,KAAT,EAAgB;AACnC,cAAI,CAAC,OAAL,EAAc;AACV,mBAAO,QAAQ,CAAC,KAAD,CAAf;AACH,WAFD,MAEO;AACH,YAAA,QAAQ,CAAC,KAAD,CAAR,IAAmB,QAAQ,CAAC,KAAD,CAAR,CAAgB,MAAhB,CAAuB,OAAO,CAAC,QAAQ,CAAC,KAAD,CAAT,EAAkB,OAAlB,CAA9B,EAA0D,CAA1D,CAAnB;AACH;AACJ,SANG,CAAJ;AAOA,eAAO,IAAP;AACH,OAvMe;;;;;;;AA8MhB,MAAA,IAAI,EAAE,UAAS,KAAT,EAAgB,IAAhB,EAAsB;;AAExB,YAAI,KAAK,OAAL,CAAa,SAAjB,EAA4B;AACxB,UAAA,eAAe,CAAC,KAAD,EAAQ,IAAR,CAAf;AACH,SAJuB,C;;;AAOxB,YAAI,QAAQ,GAAG,KAAK,QAAL,CAAc,KAAd,KAAwB,KAAK,QAAL,CAAc,KAAd,EAAqB,KAArB,EAAvC;;AACA,YAAI,CAAC,QAAD,IAAa,CAAC,QAAQ,CAAC,MAA3B,EAAmC;AAC/B;AACH;;AAED,QAAA,IAAI,CAAC,IAAL,GAAY,KAAZ;;AACA,QAAA,IAAI,CAAC,cAAL,GAAsB,YAAW;AAC7B,UAAA,IAAI,CAAC,QAAL,CAAc,cAAd;AACH,SAFD;;AAIA,YAAI,CAAC,GAAG,CAAR;;AACA,eAAO,CAAC,GAAG,QAAQ,CAAC,MAApB,EAA4B;AACxB,UAAA,QAAQ,CAAC,CAAD,CAAR,CAAY,IAAZ;AACA,UAAA,CAAC;AACJ;AACJ,OApOe;;;;;;AA0OhB,MAAA,OAAO,EAAE,YAAW;AAChB,aAAK,OAAL,IAAgB,cAAc,CAAC,IAAD,EAAO,KAAP,CAA9B;AAEA,aAAK,QAAL,GAAgB,EAAhB;AACA,aAAK,OAAL,GAAe,EAAf;AACA,aAAK,KAAL,CAAW,OAAX;AACA,aAAK,OAAL,GAAe,IAAf;AACH;AAjPe,KAApB;;;;;;;AAyPA,aAAS,cAAT,CAAwB,OAAxB,EAAiC,GAAjC,EAAsC;AAClC,UAAI,OAAO,GAAG,OAAO,CAAC,OAAtB;;AACA,UAAI,CAAC,OAAO,CAAC,KAAb,EAAoB;AAChB;AACH;;AACD,UAAI,IAAJ;AACA,MAAA,IAAI,CAAC,OAAO,CAAC,OAAR,CAAgB,QAAjB,EAA2B,UAAS,KAAT,EAAgB,IAAhB,EAAsB;AACjD,QAAA,IAAI,GAAG,QAAQ,CAAC,OAAO,CAAC,KAAT,EAAgB,IAAhB,CAAf;;AACA,YAAI,GAAJ,EAAS;AACL,UAAA,OAAO,CAAC,WAAR,CAAoB,IAApB,IAA4B,OAAO,CAAC,KAAR,CAAc,IAAd,CAA5B;AACA,UAAA,OAAO,CAAC,KAAR,CAAc,IAAd,IAAsB,KAAtB;AACH,SAHD,MAGO;AACH,UAAA,OAAO,CAAC,KAAR,CAAc,IAAd,IAAsB,OAAO,CAAC,WAAR,CAAoB,IAApB,KAA6B,EAAnD;AACH;AACJ,OARG,CAAJ;;AASA,UAAI,CAAC,GAAL,EAAU;AACN,QAAA,OAAO,CAAC,WAAR,GAAsB,EAAtB;AACH;AACJ;;;;;;;;AAOD,aAAS,eAAT,CAAyB,KAAzB,EAAgC,IAAhC,EAAsC;AAClC,UAAI,YAAY,GAAG,QAAQ,CAAC,WAAT,CAAqB,OAArB,CAAnB;AACA,MAAA,YAAY,CAAC,SAAb,CAAuB,KAAvB,EAA8B,IAA9B,EAAoC,IAApC;AACA,MAAA,YAAY,CAAC,OAAb,GAAuB,IAAvB;AACA,MAAA,IAAI,CAAC,MAAL,CAAY,aAAZ,CAA0B,YAA1B;AACH;;AAED,IAAA,MAAM,CAAC,MAAD,EAAS;AACX,MAAA,WAAW,EAAE,WADF;AAEX,MAAA,UAAU,EAAE,UAFD;AAGX,MAAA,SAAS,EAAE,SAHA;AAIX,MAAA,YAAY,EAAE,YAJH;AAMX,MAAA,cAAc,EAAE,cANL;AAOX,MAAA,WAAW,EAAE,WAPF;AAQX,MAAA,aAAa,EAAE,aARJ;AASX,MAAA,WAAW,EAAE,WATF;AAUX,MAAA,gBAAgB,EAAE,gBAVP;AAWX,MAAA,eAAe,EAAE,eAXN;AAYX,MAAA,YAAY,EAAE,YAZH;AAcX,MAAA,cAAc,EAAE,cAdL;AAeX,MAAA,cAAc,EAAE,cAfL;AAgBX,MAAA,eAAe,EAAE,eAhBN;AAiBX,MAAA,YAAY,EAAE,YAjBH;AAkBX,MAAA,cAAc,EAAE,cAlBL;AAmBX,MAAA,oBAAoB,EAAE,oBAnBX;AAoBX,MAAA,kBAAkB,EAAE,kBApBT;AAqBX,MAAA,aAAa,EAAE,aArBJ;AAuBX,MAAA,OAAO,EAAE,OAvBE;AAwBX,MAAA,KAAK,EAAE,KAxBI;AAyBX,MAAA,WAAW,EAAE,WAzBF;AA2BX,MAAA,UAAU,EAAE,UA3BD;AA4BX,MAAA,UAAU,EAAE,UA5BD;AA6BX,MAAA,iBAAiB,EAAE,iBA7BR;AA8BX,MAAA,eAAe,EAAE,eA9BN;AA+BX,MAAA,gBAAgB,EAAE,gBA/BP;AAiCX,MAAA,UAAU,EAAE,UAjCD;AAkCX,MAAA,cAAc,EAAE,cAlCL;AAmCX,MAAA,GAAG,EAAE,aAnCM;AAoCX,MAAA,GAAG,EAAE,aApCM;AAqCX,MAAA,KAAK,EAAE,eArCI;AAsCX,MAAA,KAAK,EAAE,eAtCI;AAuCX,MAAA,MAAM,EAAE,gBAvCG;AAwCX,MAAA,KAAK,EAAE,eAxCI;AA0CX,MAAA,EAAE,EAAE,iBA1CO;AA2CX,MAAA,GAAG,EAAE,oBA3CM;AA4CX,MAAA,IAAI,EAAE,IA5CK;AA6CX,MAAA,KAAK,EAAE,KA7CI;AA8CX,MAAA,MAAM,EAAE,MA9CG;AA+CX,MAAA,MAAM,EAAE,MA/CG;AAgDX,MAAA,OAAO,EAAE,OAhDE;AAiDX,MAAA,MAAM,EAAE,MAjDG;AAkDX,MAAA,QAAQ,EAAE;AAlDC,KAAT,CAAN,CAzgFmD,C;;;AAgkFnD,QAAI,UAAU,GAAI,OAAO,MAAP,KAAkB,WAAlB,GAAgC,MAAhC,GAA0C,OAAO,IAAP,KAAgB,WAAhB,GAA8B,IAA9B,GAAqC,EAAjG,CAhkFmD,CAgkFmD;;AACtG,IAAA,UAAU,CAAC,MAAX,GAAoB,MAApB;;AAEA,QAAI,OAAOiB,SAAP,KAAkB,UAAlB,IAAgCA,SAAM,CAAC,GAA3C,EAAgD;AAC5CA,MAAAA,SAAM,CAAC,YAAW;AACd,eAAO,MAAP;AACH,OAFK,CAANA;AAGH,KAJD,MAIO,IAAoC,MAAM,CAAC,OAA3C,EAAoD;AACvD,MAAA,MAAA,CAAA,OAAA,GAAiB,MAAjB;AACH,KAFM,MAEA;AACH,MAAA,MAAM,CAAC,UAAD,CAAN,GAAqB,MAArB;AACH;AAEA,GA7kFD,EA6kFG,MA7kFH,EA6kFW,QA7kFX,EA6kFqB,QA7kFrB;;ACLA;;;;;;;AASA,SAAA,WAAA,CAAA,EAAA,EAAyB;SAChBrB,MAAAA,CAAAA,UAAAA,CAAAA,EAAAA,EAAP,EAAOA,C;;;AAGT,IAAMsB,GAAAA,GAAM,CACVtB,MAAAA,CAAAA,qBAAAA,IACAA,MAAAA,CADAA,2BAAAA,IAEAA,MAAAA,CAFAA,wBAAAA,IAGAA,MAAAA,CAHAA,uBAAAA,IADU,WAAA,EAAA,IAAA,CAAZ,MAAY,CAAZ;;;;;;;;;IAeMuB,MAAAA,GAAAA,UAAAA,UAAAA,EAAAA;;;oBACU;;;;;UAEZ,S,GAAA,I;UAEA,M,GAAA,E;UACA,M,GAAA,E;UACA,O,GAAA,E;UAEA,M,GAAA,E;UACA,W,GAAA,E;UACA,Y,GAAA,E;UAEA,M,GAAc,KAAA,CAAA,MAAA,CAAA,IAAA,CAAd,KAAc,C;;;;;;wBAGZC,E,EAAIC,Y,EAAcC,a,EAAeC,W,EAAa;;;UAG1CC,YAAAA,GAAe,KAAA,MAAA,CAAA,OAAA,CAArB,EAAqB,C;;UACjBA,YAAAA,GAAe,CAAnB,C,EAAuB,KAAA,MAAA,CAAA,YAAA,IAAA,SAAA,CAJyB,C;;;oBAQlC,KAAA,MAAA,CAAA,OAAA,CAAd,EAAc,C,GAA0B,KAAA,MAAA,CAAA,IAAA,CAAxC,EAAwC,C,CARQ,C;;WAWhD,M,CAAA,E,IAAA,Y;WACA,O,CAAA,E,IAAA,a,CAZgD,C;;UAe5C,CAAC,KAAL,S,EAAqB,KAAA,SAAA,GAAiBN,GAAAA,CAAI,KAArB,MAAiBA,CAAjB;;;;2BAGhBE,E,EAAI;UACHI,YAAAA,GAAe,KAAA,MAAA,CAAA,OAAA,CAArB,EAAqB,C;;UACjBA,YAAAA,GAAe,CAAnB,C,EAAuB;aACrB,M,CAAA,Y,IAAA,S;aACA,M,CAAA,E,IAAA,S;aACA,O,CAAA,E,IAAA,S;;;;;6BAIK;UACD3C,KAAAA,GAAQ,KAAd,M;UACM4C,KAAAA,GAAQ,KAAd,M;UACMC,MAAAA,GAAS,KAAf,O;UACMC,KAAAA,GAAQ,KAAd,M;UACMC,UAAAA,GAAa,KAAnB,W;UACMC,WAAAA,GAAc,KAApB,Y;UACMC,MAAAA,GAASjD,KAAAA,CAAf,M;UACIuC,EAAAA,GAAAA,KAAJ,C;UACI3C,CAAAA,GAAAA,KAAJ,C,CATO,C;;WAYP,S,GAAA,I,CAZO,C;;WAeFA,CAAAA,GAAL,C,EAAYA,CAAAA,GAAZ,M,EAAwBA,CAAxB,E,EAA6B;aACtBI,KAAAA,CAAL,CAAKA,C;YACD,CAAJ,E,EAAS;cAET,I,CAAA,E;mBAEA,E,IAAiB4C,KAAAA,CAAjB,EAAiBA,C;cACjB,E,IAAA,S;oBAEA,E,IAAkBC,MAAAA,CAAlB,EAAkBA,C;eAClB,E,IAAA,S;OAzBK,C;;;YA6BP,M,GAAA,C,CA7BO,C;;WAgCFjD,CAAAA,GAAL,C,EAAYA,CAAAA,GAAZ,M,EAAwBA,CAAxB,E,EAA6B;aACtBkD,KAAAA,CAAL,CAAKA,C;;YACDC,UAAAA,CAAJ,EAAIA,C,EAAgB;qBAClB,E;qBACA,E,IAAA,S;;OApCG,C;;;WAyCFnD,CAAAA,GAAL,C,EAAYA,CAAAA,GAAZ,M,EAAwBA,CAAxB,E,EAA6B;aACtBkD,KAAAA,CAAL,CAAKA,C;;YACDE,WAAAA,CAAJ,EAAIA,C,EAAiB;sBACnB,E;sBACA,E,IAAA,S;;OA7CG,C;;;YAkDP,M,GAAA,C,CAlDO,C;;UAqDH,CAAC,KAAD,SAAA,IAAmBhD,KAAAA,CAAvB,M,EAAqC;aACnC,S,GAAiBqC,GAAAA,CAAI,KAArB,MAAiBA,C;;;;;CAjGjBC,CAAe/C,SAAf+C,C;AC5BN;;;;;;;AAQA,IAAMY,MAAAA,GAAS,IAAf,MAAe,EAAf;AAEA,IAAMC,UAAAA,GAAN,QAAA;AACA,IAAMC,cAAAA,GAAN,YAAA;AACA,IAAMC,QAAAA,GAAN,MAAA;AACA,IAAMC,UAAAA,GAAN,QAAA;;AAIO,SAAA,aAAA,CAAA,MAAA,EAAA,YAAA,EAAA,aAAA,EAA4D;SAC1DJ,MAAAA,CAAAA,GAAAA,CAAWK,MAAAA,GAAXL,UAAAA,EAAAA,YAAAA,EAAP,aAAOA,C;;;AAGF,SAAA,gBAAA,CAAA,MAAA,EAAkC;SAChCA,MAAAA,CAAAA,MAAAA,CAAcK,MAAAA,GAArB,UAAOL,C;;;AAGF,SAAA,iBAAA,CAAA,MAAA,EAAA,YAAA,EAAA,aAAA,EAAgE;SAC9DA,MAAAA,CAAAA,GAAAA,CAAWK,MAAAA,GAAXL,cAAAA,EAAAA,YAAAA,EAAP,aAAOA,C;;;AAGF,SAAA,oBAAA,CAAA,MAAA,EAAsC;SACpCA,MAAAA,CAAAA,MAAAA,CAAcK,MAAAA,GAArB,cAAOL,C;;;AAGF,SAAA,WAAA,CAAA,MAAA,EAAA,YAAA,EAAA,aAAA,EAA0D;SACxDA,MAAAA,CAAAA,GAAAA,CAAWK,MAAAA,GAAXL,QAAAA,EAAAA,YAAAA,EAAAA,aAAAA,EAAP,IAAOA,C;;;AAGF,SAAA,cAAA,CAAA,MAAA,EAAgC;SAC9BA,MAAAA,CAAAA,MAAAA,CAAcK,MAAAA,GAArB,QAAOL,C;;;AAGF,SAAA,aAAA,CAAA,MAAA,EAAA,YAAA,EAAA,aAAA,EAA4D;SAC1DA,MAAAA,CAAAA,GAAAA,CAAWK,MAAAA,GAAXL,UAAAA,EAAAA,YAAAA,EAAAA,aAAAA,EAAP,IAAOA,C;;;AAGF,SAAA,gBAAA,CAAA,MAAA,EAAkC;SAChCA,MAAAA,CAAAA,MAAAA,CAAcK,MAAAA,GAArB,UAAOL,C;;AC9CT;;;;;;;AAMA,IAAMM,KAAAA,GAAQC,OAAAA,CAAd,SAAA;AACA,IAAMC,OAAAA,GACJF,KAAAA,CAAAA,OAAAA,IACAA,KAAAA,CADAA,eAAAA,IAEAA,KAAAA,CAFAA,qBAAAA,IAGAA,KAAAA,CAHAA,kBAAAA,IAIAA,KAAAA,CAJAA,iBAAAA,IAKAA,KAAAA,CANF,gBAAA;;;;;;;;AAce,SAAA,cAAA,CAAA,EAAA,EAAA,QAAA,EAAsC;SAC5CE,OAAAA,CAAAA,IAAAA,CAAAA,EAAAA,EAAP,QAAOA,C;;ACtBT;;;;;;;;;;;;;;AAcA,SAAA,cAAA,CAAA,OAAA,EAAA,SAAA,EAA4C;UAC1C,S,CAAA,G,CAAA,S;;;;;;;;;;AASF,SAAA,cAAA,CAAA,OAAA,EAAA,SAAA,EAA4C;MACtC,CAACC,cAAAA,CAAAA,OAAAA,EAAAA,MAAL,SAAKA,C,EAA0C;YAC7C,S,IAAA,MAAA,S;;;;AAIJ,IAAA,QAAA,GAAgB,eAAeF,OAAAA,CAAf,SAAA,GAAA,cAAA,GAAhB,cAAA;AC9BA;;;;;;;;;;;;;;;;AAee,SAAA,mBAAA,CAAA,KAAA,EAAA,KAAA,EAAA,WAAA,EAAwD;MAC/DR,MAAAA,GAASW,KAAAA,CAAf,M;MACMC,QAAAA,GAAWC,IAAAA,CAAAA,GAAAA,CAAAA,CAAAA,EAAYC,WAAAA,GAAAA,MAAAA,GAAuBd,MAAAA,GAApD,CAAiBa,C;SACVE,KAAAA,GAAAA,QAAAA,GAAAA,QAAAA,GAA8BA,KAAAA,GAAAA,CAAAA,GAAYF,IAAAA,CAAAA,GAAAA,CAASD,QAAAA,GAAAA,KAAAA,GAATC,CAAAA,EAAZE,CAAYF,CAAZE,GAArC,K;;AClBF;;;;;;;;;;;;;;;;;AAiBe,SAAA,SAAA,CAAA,KAAA,EAAA,SAAA,EAAA,OAAA,EAA8C;;MAEvDJ,KAAAA,CAAAA,MAAAA,GAAJ,C,EAAsB,OAFqC,C;;MAKrDK,IAAAA,GAAOC,mBAAAA,CAAAA,KAAAA,EAAb,SAAaA,C;MACPC,EAAAA,GAAKD,mBAAAA,CAAAA,KAAAA,EAAX,OAAWA,C,CANgD,C;;MASvDD,IAAAA,KAAJ,E,EAAiB;UACf,M,CAAA,E,EAAA,C,EAAoBL,KAAAA,CAAAA,MAAAA,CAAAA,IAAAA,EAAAA,CAAAA,EAApB,CAAoBA,C;;;AC3BxB;;;;;;;;;;;;;;;;;AAiBe,SAAA,SAAA,CAAA,KAAA,EAAA,KAAA,EAAA,SAAA,EAA4C;;MAErDA,KAAAA,CAAAA,MAAAA,GAAJ,C,EAAsB,OAFmC,C;;MAKnDQ,MAAAA,GAASF,mBAAAA,CAAAA,KAAAA,EAAf,KAAeA,C;MACTG,MAAAA,GAASH,mBAAAA,CAAAA,KAAAA,EAAf,SAAeA,C;MACXI,IAAAA,GAAAA,KAAJ,C,CAPyD,C;;MAUrDF,MAAAA,KAAJ,M,EAAuB;WACdR,KAAAA,CAAP,MAAOA,C;UACP,M,IAAgBA,KAAAA,CAAhB,MAAgBA,C;UAChB,M,IAAA,I;;;AC9BJ;;;;;;;AAMA,IAAMW,YAAAA,GAAN,QAAA;AACA,IAAMC,YAAAA,GAAN,QAAA;;;;;;;;;;;;;;AAce,SAAA,QAAA,CAAA,EAAA,EAAA,IAAA,EAA4B;MACrCC,OAAAA,GAAAA,KAAJ,C;;MAEIC,IAAAA,GAAJ,C,EAAc;WACL,UAAA,MAAA,EAAiB;UAClBD,OAAAA,KAAJ,S,EAA2B;kBACf1D,MAAAA,CAAAA,YAAAA,CAAV,OAAUA,C;YACN4D,MAAAA,KAAJ,Y,EAA6BC,EAAAA;;;UAG3BD,MAAAA,KAAAA,YAAAA,IAA2BA,MAAAA,KAA/B,Y,EAAwD;kBAC5C,MAAA,CAAA,UAAA,CAAkB,YAAW;oBACrC,S;;AADQ,SAAA,EAAV,IAAU,C;;AAPd,K;;;SAeK,UAAA,MAAA,EAAiB;QAClBA,MAAAA,KAAJ,Y,EAA6BC,EAAAA;AAD/B,G;;ACxCF;;;;;;;;;;;;;;;;;;;;AAoBe,SAAA,aAAA,CAAA,OAAA,EAAgC;MACvCC,SAAAA,GAAY3C,QAAAA,CAAAA,OAAAA,EAAlB,WAAkBA,C;MACd,CAAA,SAAA,IAAc2C,SAAAA,KAAlB,M,EAAwC,OAAA,KAAA;MAElCC,OAAAA,GAAU5C,QAAAA,CAAAA,OAAAA,EAAhB,SAAgBA,C;MACZ4C,OAAAA,KAAAA,QAAAA,IAAwBA,OAAAA,KAA5B,M,EAAgD,OAAA,KAAA;SAEhD,I;;AC3BF;;;;;;;;;;;;;;;;;;;;;AAsBe,SAAA,kBAAA,CAAA,OAAA,EAAA,WAAA,EAAkD;;;;MAI3DC,GAAAA,GAAM,CAACC,WAAAA,GAAAA,OAAAA,GAAwBhD,OAAAA,CAAzB,aAAA,KAAV,Q;;SACO+C,GAAAA,IAAOA,GAAAA,KAAPA,QAAAA,IAA2B7C,QAAAA,CAAAA,GAAAA,EAAAA,UAAAA,CAAAA,KAA3B6C,QAAAA,IAAqE,CAACE,aAAAA,CAA7E,GAA6EA,C,EAAoB;UACzFF,GAAAA,CAAAA,aAAAA,IAAN,Q;;;SAEF,G;;AC9BF;;;;;;;;;;;;;;;;AAgBe,SAAA,eAAA,CAAA,EAAA,EAAA,KAAA,EAAoC;SAC1CG,UAAAA,CAAWhD,QAAAA,CAAAA,EAAAA,EAAXgD,KAAWhD,CAAXgD,CAAAA,IAAP,C;;ACjBF;;;;;;;AASA,IAAMC,OAAAA,GAAN,EAAA;AACA,IAAMC,OAAAA,GAAN,EAAA;AACA,IAAMC,UAAAA,GAAN,EAAA;;;;;;;;;;;;;;AAcA,SAAA,SAAA,CAAA,OAAA,EAAA,UAAA,EAAwC;MAChCN,GAAAA,GAAMO,UAAAA,IAAZ,E;MACIC,IAAAA,GAAAA,KAAJ,C,CAFsC,C;;MAKtC,I,GAAA,C;MACA,G,GAAA,C,CANsC,C;;MASlCvD,OAAAA,KAAJ,Q,EAA0B,OAAA,GAAA,CATY,C;;MAYtC,I,GAAWjB,MAAAA,CAAAA,WAAAA,IAAX,C;MACA,G,GAAUA,MAAAA,CAAAA,WAAAA,IAAV,C,CAbsC,C;;MAgBlCiB,OAAAA,CAAAA,IAAAA,KAAiBjB,MAAAA,CAArB,I,EAAkC,OAAA,GAAA,CAhBI,C;;SAmB/BiB,OAAAA,CAAP,qBAAOA,E;MACP,I,IAAYuD,IAAAA,CAAZ,I;MACA,G,IAAWA,IAAAA,CAAX,G,CArBsC,C;;MAwBtC,I,IAAYC,eAAAA,CAAAA,OAAAA,EAAZ,mBAAYA,C;MACZ,G,IAAWA,eAAAA,CAAAA,OAAAA,EAAX,kBAAWA,C;SAEX,G;;;;;;;;;;;;;;;AAca,SAAA,aAAA,CAAA,KAAA,EAAA,KAAA,EAAA,uBAAA,EAA8D;aAC3E,I,GAAA,C;aACA,G,GAAA,C,CAF2E,C;;MAKvEC,KAAAA,KAAJ,K,EAAqB,OAAA,UAAA,CALsD,C;;MAQ3E,uB,EAA6B;YACnBC,kBAAAA,CAAAA,KAAAA,EAAR,IAAQA,C;YACAA,kBAAAA,CAAAA,KAAAA,EAAR,IAAQA,C,CAFmB,C;;QAKvBD,KAAAA,KAAJ,K,EAAqB,OAAA,UAAA;GAboD,C;;;YAiB3E,K,EAAA,O;YACA,K,EAAA,O;aACA,I,GAAkBL,OAAAA,CAAAA,IAAAA,GAAeD,OAAAA,CAAjC,I;aACA,G,GAAiBC,OAAAA,CAAAA,GAAAA,GAAcD,OAAAA,CAA/B,G;SAEA,U;;ACxFF;;;;;;;AAQA,IAAMQ,aAAAA,GAAN,EAAA;;;;;;;;;;AAUe,SAAA,YAAA,CAAA,OAAA,EAA+B;gBAC5C,C,GAAA,C;gBACA,C,GAAA,C;MAEMd,SAAAA,GAAY3C,QAAAA,CAAAA,OAAAA,EAAlB,WAAkBA,C;MACd,CAAJ,S,EAAgB,OAAA,aAAA;MAEV0D,UAAAA,GAAaf,SAAAA,CAAAA,OAAAA,CAAAA,SAAAA,EAAAA,EAAAA,EAAAA,KAAAA,CAAnB,GAAmBA,C;gBACnB,C,GAAkBK,UAAAA,CAAWU,UAAAA,CAAXV,CAAWU,CAAXV,CAAAA,IAAlB,C;gBACA,C,GAAkBA,UAAAA,CAAWU,UAAAA,CAAXV,CAAWU,CAAXV,CAAAA,IAAlB,C;SAEA,a;;AC7BF;;;;;;;;;;;;;;;;AAce,SAAA,kBAAA,CAAA,CAAA,EAAA,CAAA,EAAkC;SACxC,gBAAA,CAAA,GAAA,iBAAA,GAAA,CAAA,GAAP,K;;ACfF;;;;;;;AAMA,IAAMW,SAAAA,GAAN,EAAA;;;;;;;;;;;AAWe,SAAA,WAAA,CAAA,KAAA,EAAA,KAAA,EAAA,KAAA,EAA0C;MACnDC,UAAAA,GAAa,OAAA,KAAA,KAAA,QAAA,GAAA,KAAA,GAAoC,CAArD,C;MACIA,UAAAA,GAAJ,C,EAAoBA,UAAAA,GAAalC,KAAAA,CAAAA,MAAAA,GAAAA,UAAAA,GAAbkC,CAAAA;QAEpB,M,CAAA,K,CAAA,K,EAAA,iBAAA,CAAgBD,SAAAA,CAAAA,MAAAA,CAAAA,UAAAA,EAAAA,CAAAA,EAAhB,KAAgBA,CAAhB,C;YACA,M,GAAA,C;;ACtBF;;;;;;;AAMA,IAAME,UAAAA,GAAN,iBAAA;AACA,IAAMC,QAAAA,GAAWC,MAAAA,CAAAA,SAAAA,CAAjB,QAAA;;;;;;;;AAQe,SAAA,aAAA,CAAA,GAAA,EAA4B;SAClC,CAAA,OAAA,GAAA,KAAA,WAAA,GAAA,WAAA,GAAA,OAAA,CAAA,GAAA,CAAA,MAAA,QAAA,IAA2BD,QAAAA,CAAAA,IAAAA,CAAAA,GAAAA,MAAlC,U;;AChBF;;;;;;;;;;;;;;AAcA,SAAA,iBAAA,CAAA,OAAA,EAAA,SAAA,EAA+C;UAC7C,S,CAAA,M,CAAA,S;;;;;;;;;;AASF,SAAA,iBAAA,CAAA,OAAA,EAAA,SAAA,EAA+C;MACzCrC,cAAAA,CAAAA,OAAAA,EAAwB,MAA5B,SAAIA,C,EAA0C;YAC5C,S,GAAoB,CAAC,MAAM3B,OAAAA,CAAN,SAAA,GAAD,GAAA,EAAA,OAAA,CAAwC,MAAA,SAAA,GAAxC,GAAA,EAAA,GAAA,EAApB,IAAoB,E;;;;AAIxB,IAAA,WAAA,GAAgB,eAAeyB,OAAAA,CAAf,SAAA,GAAA,iBAAA,GAAhB,iBAAA;AC9BA;;;;;;;;AA6CA,IAAIyC,gBAAAA,GAAmBC,kBAAvB,EAAA,C;;AAGA,IAAMC,sBAAAA,GAAN,CAAA;AACA,IAAMC,qBAAAA,GAAN,CAAA;AACA,IAAMC,sBAAAA,GAAN,CAAA;AACA,IAAMC,sBAAAA,GAAN,CAAA;;;;;;;;IAQMC,QAAAA,GAAAA,UAAAA,UAAAA,EAAAA;;;oBACJ,I,EAAkB;;;mHAAA,I;;QAEZ,CAAJ,M,EAAa;YACL,IAAA,KAAA,CAAA,MAAA,SAAA,GAAN,8CAAM,C;KAHQ,C;;;;;QASZN,gBAAAA,KAAJ,I,EAA+B;yBACVC,kBAAnB,E;;;QAGIM,IAAAA,GAAN,K;QACMzE,OAAAA,GAAU0E,IAAAA,CAAhB,Q;QACMC,IAAAA,GAAOD,IAAAA,CAAb,OAAaA,E;QACPE,QAAAA,GAAWD,IAAAA,CAAjB,S;QACIE,SAAAA,GAAAA,KAAJ,C,CAjBgB,C;;QAoBVC,cAAAA,GACJ,OAAOF,QAAAA,CAAP,kBAAA,KAAA,UAAA,GACIA,QAAAA,CADJ,kBAAA,GAEIJ,QAAAA,CAHN,qB;QAIIO,mBAAAA,GAAJ,sB;QACIC,oBAAAA,GAAAA,KAAJ,C,CAzBgB,C;;UA4BhB,K,GAAA,I;UACA,O,GAAeL,IAAAA,CAAf,G;UACA,O,GAAeE,SAAAA,GAAS,IAAII,MAAAA,CAAJ,OAAA,CAAxB,OAAwB,C;UACxB,Y,GAAA,K;UACA,Y,GAAA,K,CAhCgB,C;;UAmChB,M,GAnCgB,C;;;UAsChB,S,GAAiB,KAAA,CAAA,SAAA,CAAA,IAAA,CAAjB,KAAiB,C;UACjB,Y,GAAoB,KAAA,CAAA,YAAA,CAAA,IAAA,CAApB,KAAoB,C;UACpB,U,GAAkB,KAAA,CAAA,UAAA,CAAA,IAAA,CAAlB,KAAkB,C;UAClB,c,GAAsB,KAAA,CAAA,cAAA,CAAA,IAAA,CAAtB,KAAsB,C;UACtB,Y,GAAoB,KAAA,CAAA,YAAA,CAAA,IAAA,CAApB,KAAoB,C;UACpB,a,GAAqB,KAAA,CAAA,aAAA,CAAA,IAAA,CAArB,KAAqB,C,CA3CL,C;;;UA+ChB,2B,GAAmC,UAAA,KAAA,EAAgB;UAC7C,CAAC,KAAD,YAAA,IAAsBF,mBAAAA,KAA1B,qB,EAAyE;8BACvE,sB;;aACA,Q,CAAA,K;;AAHJ,K,CA/CgB,C;;;UAuDhB,qB,GAA6BG,QAAAA,CAAS,KAAA,CAATA,aAAAA,EAA6BN,QAAAA,CAA1D,gBAA6BM,C,CAvDb,C;;cA0DhB,G,CACE,IAAID,MAAAA,CAAJ,GAAA,CAAe;aAAA,MAAA;gBAAA,CAAA;iBAAA,CAAA;iBAIFA,MAAAA,CAAOE;AAJL,KAAf,C,EA3Dc,C;;cAoEhB,G,CACE,IAAIF,MAAAA,CAAJ,KAAA,CAAiB;aAAA,UAAA;gBAAA,CAAA;iBAAA,IAAA;YAIT;AAJS,KAAjB,C,EArEc,C;;QA8EZG,aAAAA,CAAcR,QAAAA,CAAlB,kBAAIQ,C,EAA4C;gBAC9C,G,CAAWR,QAAAA,CAAX,kB;KA/Ec,C;;;cAmFhB,E,CAAA,6B,EACqC,UAAA,CAAA,EAAK;;UAElCG,mBAAAA,KAAJ,sB,EAAoD;8BAClD,qB;OAHoC,C;;;UAOlCA,mBAAAA,KAAJ,qB,EAAmD;+BAC1BD,cAAAA,CAAeL,IAAAA,CAAfK,KAAAA,EAAvB,CAAuBA,C;;YACnBE,oBAAAA,KAAJ,I,EAAmC;gCACjC,sB;;eACA,Q,CAAA,C;AAFF,S,MAGO,IAAIA,oBAAAA,KAAJ,KAAA,EAAoC;gCACzC,sB;;;WAKC,IAAID,mBAAAA,KAAAA,sBAAAA,IAAkDN,IAAAA,CAAtD,SAAA,EAAsE;eACzE,O,CAAA,C;;AApBN,K,EAAA,E,CAAA,+B,EAuBuC,UAAA,CAAA,EAAK;;UAElCY,UAAAA,GAAaN,mBAAAA,KAAnB,sB,CAFwC,C;;;;qBAOzBN,IAAAA,CAAf,K,EAAA,C,EAPwC,C;;4BAUxC,sB,CAVwC,C;;UAapCY,UAAAA,IAAcZ,IAAAA,CAAlB,S,EAAkCA,IAAAA,CAAAA,MAAAA,CAAAA,CAAAA;AApCtC,K,EAnFgB,C;;YA2HhB,gB,CAAA,W,EAAA,c,EAAA,K;;;;;;;;;;;;;;;;;;;2BAeK;UACCC,IAAAA,GAAO,KAAb,K;UACM1E,OAAAA,GAAU0E,IAAAA,CAAhB,Q;;UACMC,IAAAA,GAAO,KAAb,QAAa,E;;UAET,CAAC,KAAL,S,EAAqB,OAAA,IAAA,CALhB,C;;;UASD,KAAJ,Y,EAAuB;aACrB,gB;;eACA,I;OAXG,C;;;qBAeUD,IAAAA,CAAf,G;uBACiBA,IAAAA,CAAjB,G,EAhBK,C;;WAmBL,sB,GAnBK,C;;;WAsBL,qB,CAAA,Q,EAtBK,C;;;;UA0BD1E,OAAAA,CAAAA,UAAAA,KAAuB2E,IAAAA,CAA3B,Q,EAA0C;aACxC,Q,CAAA,W,CAAA,O;;gBACA,K,CAAA,a,IAA+BW,kBAAAA,CAAmB,KAAnBA,MAAAA,EAAgC,KAA/D,MAA+BA,C;OA5B5B,C;;;kBAgCL,O,EAAqBX,IAAAA,CAAAA,SAAAA,CAArB,iB,EAhCK,C;;WAmCL,M;;aAEA,I;;;;;;;;;;;;8BAUQ;UACJ,KAAJ,Y,EAAuB,OAAA,IAAA;WACvB,I;;WACA,O,CAAA,O;;WACA,K,CAAA,Q,CAAA,mB,CAAA,W,EAAA,c,EAAA,K;;WACA,Y,GAAA,I;aACA,I;;;;;;;;;;;;;;;;;+BAeS;aACF9I,aAAAA,CAAc,KAAdA,OAAAA,CAAAA,IAAP,I;;;;;;;;;;;6BASO;;WAEP,S,GAAA,K,CAFO,C;;WAKP,U,GAAA,I,CALO,C;;WAQP,gB,GAAA,I,CARO,C;;WAWP,U,GAAA,I;WACA,gB,GAAA,I,CAZO,C;;;WAgBP,U,GAAA,E,CAhBO,C;;WAmBP,K,GAAA,C;WACA,I,GAAA,C,CApBO,C;;WAuBP,M,GAAA,C;WACA,M,GAAA,C,CAxBO,C;;;WA4BP,e,GAAA,C;WACA,e,GAAA,C,CA7BO,C;;;WAiCP,e,GAAA,C;WACA,e,GAAA,C;;;;;;;;;;;;2CAUqB;UACf0J,aAAAA,GAAgB,KAAA,QAAA,GAAtB,Q;;UACMC,aAAAA,GAAgB,KAAtB,U;UACMC,SAAAA,GAAY,KAAlB,U;UACIC,kBAAAA,GAAAA,KAAJ,C;UACI9H,CAAAA,GAAAA,KAAJ,C,CALqB,C;;gBAQrB,M,GAAA,C;uBACiB,KAAA,KAAA,CAAjB,Q,EAAA,S,EATqB,C;;;;UAcjB4H,aAAAA,KAAJ,a,EAAqC;6BACnC,E;yBACA,a,EAAA,kB;2BACA,I,CAAA,a;;aACK5H,CAAAA,GAAL,C,EAAYA,CAAAA,GAAI8H,kBAAAA,CAAhB,M,EAA2C9H,CAA3C,E,EAAgD;cAC1C,CAAC6H,SAAAA,CAAAA,QAAAA,CAAmBC,kBAAAA,CAAxB,CAAwBA,CAAnBD,C,EAA2C;sBAC9C,I,CAAeC,kBAAAA,CAAf,CAAeA,C;;;OApBA,C;;;WA0BhB9H,CAAAA,GAAL,C,EAAYA,CAAAA,GAAI6H,SAAAA,CAAhB,M,EAAkC7H,CAAlC,E,EAAuC;kBACrC,C,EAAA,gB,CAAA,Q,EAAwC,KAAxC,S;;;;;;;;;;;;;6CAWqB;UACjB6H,SAAAA,GAAY,KAAlB,U;UACI7H,CAAAA,GAAAA,KAAJ,C;;WAEKA,CAAAA,GAAL,C,EAAYA,CAAAA,GAAI6H,SAAAA,CAAhB,M,EAAkC7H,CAAlC,E,EAAuC;kBACrC,C,EAAA,mB,CAAA,Q,EAA2C,KAA3C,S;;;gBAGF,M,GAAA,C;;;;;;;;;;;;;yCAWmB0B,O,EAAS;UACtBqG,MAAAA,GAASrG,OAAAA,IAAW,KAAA,QAAA,GAAA,SAAA,CAAXA,kBAAAA,IAAf,C;aACQ,KAAA,mBAAA,GAA2B;kBACvBwC,IAAAA,CAAAA,GAAAA,CAAS6D,MAAAA,CAAT7D,QAAAA,KADuB,CAAA;eAE1BA,IAAAA,CAAAA,GAAAA,CAAS6D,MAAAA,CAAT7D,KAAAA,EAAAA,CAAAA,KAF0B,CAAA;gBAGzB,OAAO6D,MAAAA,CAAP,MAAA,KAAA,QAAA,GAAoCA,MAAAA,CAApC,MAAA,GAAoD;AAH3B,O;;;;;;;;;;;;;6CAeZnI,K,EAAO;UACxBoI,SAAAA,GAAY,KAAlB,mB;UACM5F,OAAAA,GAAU,KAAA,KAAA,CAAhB,Q;UACI6F,aAAAA,GAAJ,O,CAH8B,C;;UAM1B,CAACD,SAAAA,CAAL,M,EAAuB,OAAA,aAAA,CANO,C;;sBASd,CAACpI,KAAAA,CAAAA,eAAAA,CAAAA,CAAAA,KAAD,CAAA,EAAhB,M;;aACOqI,aAAAA,IAAiB,CAAClE,cAAAA,CAAAA,aAAAA,EAA8BiE,SAAAA,CAAvD,MAAyBjE,C,EAAiD;wBACxDkE,aAAAA,KAAAA,OAAAA,GAA4BA,aAAAA,CAA5BA,aAAAA,GAAhB,I;;;aAEKA,aAAAA,IAAP,I;;;;;;;;;;;;;;2CAYqBrI,K,EAAO;UACtBoI,SAAAA,GAAY,KAAlB,mB;UACME,OAAAA,GAAUtI,KAAAA,CAAAA,eAAAA,CAAhB,CAAgBA,C;UACVuI,KAAAA,GAASD,OAAAA,IAAWA,OAAAA,CAAZ,KAACA,IAAf,C;UACME,KAAAA,GAASF,OAAAA,IAAWA,OAAAA,CAAZ,KAACA,IAAf,C;UACIG,UAAAA,GAAAA,KAAJ,C;UACIC,UAAAA,GAAAA,KAAJ,C;UACIC,SAAAA,GAAAA,KAAJ,C;UACIC,WAAAA,GAAAA,KAAJ,C;UACIC,YAAAA,GAAAA,KAAJ,C,CAT4B,C;;;UAaxB7I,KAAAA,CAAAA,QAAAA,GAAiBoI,SAAAA,CAAjBpI,QAAAA,IAAuCoI,SAAAA,CAA3C,K,EAA4D,OAbhC,C;;mBAgBfA,SAAAA,CAAAA,aAAAA,CAAb,qBAAaA,E;mBACAK,UAAAA,CAAAA,IAAAA,IAAmBlH,MAAAA,CAAAA,WAAAA,IAAhC,CAAakH,C;kBACDA,UAAAA,CAAAA,GAAAA,IAAkBlH,MAAAA,CAAAA,WAAAA,IAA9B,CAAYkH,C;oBACEA,UAAAA,CAAd,K;qBACeA,UAAAA,CAAf,M,CApB4B,C;;WAuB5B,oB,GAvB4B,C;;;aA2B1BG,WAAAA,IAAAA,YAAAA,IAEAL,KAAAA,IAFAK,UAAAA,IAGAL,KAAAA,GAAQG,UAAAA,GAHRE,WAAAA,IAIAJ,KAAAA,IAJAI,SAAAA,IAKAJ,KAAAA,GAAQG,SAAAA,GANV,Y;;;;;;;;;;;;0CAiBoB3I,K,EAAO;UACrBwC,OAAAA,GAAU,KAAA,KAAA,CAAhB,Q,CAD2B,C;;WAI3B,oB,GAJ2B,C;;;;UAQvBsG,OAAAA,CAAJ,KAAIA,C,EAAgBC,cAAAA,CAAAA,OAAAA,CAAAA;;;;;;;;;;;2CASC;UACfX,SAAAA,GAAY,KAAlB,mB;;UACA,S,EAAe;YACTA,SAAAA,CAAJ,U,EAA0B;oBACxB,U,GAAuB7G,MAAAA,CAAAA,YAAAA,CAAoB6G,SAAAA,CAA3C,UAAuB7G,C;;;aAEzB,mB,GAAA,I;;;;;;;;;;;;;oCAWY;UACV,CAAC,KAAL,S,EAAqB;UAEf2F,IAAAA,GAAO,KAAb,K;;UACME,QAAAA,GAAW,KAAA,QAAA,GAAjB,S;;UACI4B,MAAAA,GAAAA,KAAJ,C;UACIC,WAAAA,GAAAA,KAAJ,C;UACI9F,YAAAA,GAAAA,KAAJ,C;UACI+F,UAAAA,GAAAA,KAAJ,C;UACIC,WAAAA,GAAAA,KAAJ,C;UACIC,UAAAA,GAAAA,KAAJ,C;UACI7E,WAAAA,GAAAA,KAAJ,C,CAXc,C;;UAcV,OAAO6C,QAAAA,CAAP,iBAAA,KAAJ,U,EAAsD;iBAC3CA,QAAAA,CAAAA,iBAAAA,CAAAA,IAAAA,EAAiC,KAA1C,UAASA,C;AADX,O,MAEO;iBACIJ,QAAAA,CAAAA,oBAAAA,CAAAA,IAAAA,EAAoCI,QAAAA,CAA7C,iBAASJ,C;OAjBG,C;;;UAqBV,CAAA,MAAA,IAAW,OAAOgC,MAAAA,CAAP,KAAA,KAAf,Q,EAAiD;oBAEnC9B,IAAAA,CAAd,OAAcA,E;mBACD8B,MAAAA,CAAAA,IAAAA,IAAb,W;oBACcC,WAAAA,KAAd,U;qBACeA,WAAAA,CAAAA,MAAAA,CAAAA,OAAAA,CAAf,IAAeA,C;oBACDvE,mBAAAA,CAAoBwE,UAAAA,CAApBxE,MAAAA,EAAuCsE,MAAAA,CAAvCtE,KAAAA,EAAd,WAAcA,C;mBACDsE,MAAAA,CAAAA,MAAAA,KAAAA,MAAAA,GAAAA,MAAAA,GAAb,M,CA5Bc,C;;UA+BV,CAAJ,W,EAAkB;;YAEZ7F,YAAAA,KAAJ,W,EAAkC;;WAE/BiG,UAAAA,KAAAA,MAAAA,GAAAA,SAAAA,GAAD,S,EACEH,WAAAA,CADF,M,EAAA,Y,EAAA,W,EAFgC,C;;cAS5BA,WAAAA,CAAAA,aAAAA,CAAJ,SAAIA,C,EAAsC;wBACxC,K,CAAA,S,EAA6B;oBAAA,IAAA;yBAAA,YAAA;uBAAA,WAAA;sBAInBG;AAJmB,a;WAVC,C;;;sBAmBhC,M;;;WAKC;;cAECH,WAAAA,CAAAA,aAAAA,CAAJ,eAAIA,C,EAA4C;wBAC9C,K,CAAA,e,EAAmC;oBAAA,IAAA;wBAAA,WAAA;yBAAA,YAAA;sBAAA,UAAA;uBAKxBE;AALwB,a;WAHlC,C;;;cAaCD,UAAAA,CAAAA,aAAAA,CAAJ,kBAAIA,C,EAA8C;uBAChD,K,CAAA,kB,EAAqC;oBAAA,IAAA;wBAAA,WAAA;yBAAA,YAAA;sBAAA,UAAA;uBAK1BC;AAL0B,a;WAdpC,C;;;eAwBH,O,GAAeD,UAAAA,CAAf,G,CAxBG,C;;eA2BH,Y,GAAoBhC,IAAAA,CAAAA,OAAAA,KAAiB,KAArC,O,CA3BG,C;;sBA8BH,M,CAAA,M,CAAA,Y,EAAA,C;;sBACYgC,UAAAA,CAAZ,M,EAAA,I,EAAA,W,EA/BG,C;;;;eAoCH,S,GAAA,I,CApCG,C;;cAuCCD,WAAAA,CAAAA,aAAAA,CAAJ,SAAIA,C,EAAsC;wBACxC,K,CAAA,S,EAA6B;oBAAA,IAAA;wBAAA,WAAA;yBAAA,YAAA;sBAAA,UAAA;uBAKlBE;AALkB,a;WAxC5B,C;;;cAkDCD,UAAAA,CAAAA,aAAAA,CAAJ,YAAIA,C,EAAwC;uBAC1C,K,CAAA,Y,EAA+B;oBAAA,IAAA;wBAAA,WAAA;yBAAA,YAAA;sBAAA,UAAA;uBAKpBC;AALoB,a;WAnD9B,C;;;sBA6DH,M;qBACA,M;;;;;;;;;;;;;uCAWe;UACXjC,IAAAA,GAAO,KAAb,K;UACMmC,OAAAA,GAAUnC,IAAAA,CAAhB,Q;UACM1E,OAAAA,GAAU0E,IAAAA,CAAhB,Q;UACMoC,QAAAA,GAAWpC,IAAAA,CAAjB,S;UACMgC,UAAAA,GAAahC,IAAAA,CAAnB,OAAmBA,E;UACbqC,iBAAAA,GAAoBL,UAAAA,CAA1B,Q;UACMM,cAAAA,GAAiBN,UAAAA,CAAvB,S;UACMO,eAAAA,GAAkBD,cAAAA,CAAAA,aAAAA,IAAxB,iB;;UACME,eAAAA,GAAkB,KAAA,QAAA,GAAxB,S;;UACMC,gBAAAA,GAAmBnH,OAAAA,CAAzB,U;UACIoH,SAAAA,GAAAA,KAAJ,C;UACI/D,UAAAA,GAAAA,KAAJ,C,CAZiB,C;;;;WAiBjB,Y,GAAA,K;WACA,O,GAlBiB,C;;kBAqBjB,O,EAAqB6D,eAAAA,CAArB,S;kBACA,O,EAAqBA,eAAAA,CAArB,gB;kBACA,O,EAAqBA,eAAAA,CAArB,e,EAvBiB,C;;eA0BjB,O,EAAkBF,cAAAA,CAAlB,S;eACA,O,EAAkBF,QAAAA,GAAWE,cAAAA,CAAXF,gBAAAA,GAA6CE,cAAAA,CAA/D,e,EA3BiB,C;;;UA+BbC,eAAAA,KAAJ,gB,EAA0C;wBACxC,W,CAAA,O;qBACaI,aAAAA,CAAAA,gBAAAA,EAAAA,eAAAA,EAAb,IAAaA,C;oBACDC,YAAAA,CAAZ,OAAYA,C;kBACZ,C,IAAejE,UAAAA,CAAf,I;kBACA,C,IAAeA,UAAAA,CAAf,G;OApCe,C;;;WAwCjB,kB;;WACA,gB,GAzCiB,C;;;;;mBA8CJgE,aAAAA,CAAAA,eAAAA,EAAAA,iBAAAA,EAAb,IAAaA,C;cACb,e,GAA0BhE,UAAAA,CAA1B,I;cACA,e,GAA0BA,UAAAA,CAA1B,G,CAhDiB,C;;WAmDjB,K,GAAa2D,cAAAA,CAAAA,WAAAA,GAA6B,IAAA,QAAA,CAA7BA,IAA6B,CAA7BA,GAAb,I,CAnDiB,C;;;UAuDbC,eAAAA,KAAJ,gB,EAA0C;gBACxC,K,CAAA,a,IAA+B3B,kBAAAA,CAAmB8B,SAAAA,CAAnB9B,CAAAA,EAAgC8B,SAAAA,CAA/D,CAA+B9B,C;OAxDhB,C;;;WA4DjB,M,CAAA,e,CAAA,O;;gBACUZ,IAAAA,CAAV,M,EAAuBoC,QAAAA,GAAWE,cAAAA,CAAXF,aAAAA,GAA0CE,cAAAA,CAAjE,Y,EA7DiB,C;;cAgEjB,K;;;;;;;;;;;;6BAUOxJ,K,EAAO;UACRkH,IAAAA,GAAO,KAAb,K,CADc,C;;UAIV,CAACA,IAAAA,CAAL,S,EAAqB;UAEf1E,OAAAA,GAAU0E,IAAAA,CAAhB,Q;;UACMC,IAAAA,GAAO,KAAb,QAAa,E;;UACPC,QAAAA,GAAWD,IAAAA,CAAjB,S;UACMkC,OAAAA,GAAUnC,IAAAA,CAAhB,Q;UACM6C,OAAAA,GAAU7C,IAAAA,CAAhB,Q;UACMa,aAAAA,GAAgBZ,IAAAA,CAAtB,Q;UACMa,aAAAA,GAAgBZ,QAAAA,CAAAA,aAAAA,IAAtB,a;UACM4C,eAAAA,GAAkB9D,kBAAAA,CAAAA,aAAAA,EAAxB,IAAwBA,C;UAClB0D,SAAAA,GAAYE,YAAAA,CAAlB,OAAkBA,C;UACdG,WAAAA,GAAcL,SAAAA,CAAlB,C;UACIM,UAAAA,GAAaN,SAAAA,CAAjB,C;UACMO,WAAAA,GAAc3H,OAAAA,CAApB,qBAAoBA,E;UACd4H,gBAAAA,GAAmBpC,aAAAA,KAAzB,a;UACInC,UAAAA,GAAAA,KAAJ,C,CAnBc,C;;;;UAwBd,gB,EAAsB;qBACPgE,aAAAA,CAAAA,eAAAA,EAAb,aAAaA,C;OAzBD,C;;;UA6BV3C,IAAAA,CAAJ,aAAIA,E,EAAsB;aACxB,O,CAAA,I,CAAA,I,EAAwB;AAAE7B,UAAAA,SAAAA,EAAWyC,kBAAAA,CAAAA,WAAAA,EAArC,UAAqCA;AAAb,S;OA9BZ,C;;;UAkCViC,OAAAA,CAAJ,S,EAAuB;uBACNA,OAAAA,CAAf,e;sBACcA,OAAAA,CAAd,e;gBACA,I,CAAA,I,EAAmB;AAAE1E,UAAAA,SAAAA,EAAWyC,kBAAAA,CAAAA,WAAAA,EAAhC,UAAgCA;AAAb,S;OArCP,C;;;UAyCVZ,IAAAA,CAAJ,WAAIA,E,EAAoBmC,OAAAA,CAAAA,MAAAA,GAzCV,C;;WA4Cd,S,GAAA,I;WACA,U,GAAA,K;WACA,U,GAAA,a;WACA,gB,GAAA,e;WACA,e,GAAuBc,WAAAA,CAAvB,I;WACA,e,GAAuBA,WAAAA,CAAvB,G;WACA,K,GAAa,KAAA,MAAA,GAAb,W;WACA,I,GAAY,KAAA,MAAA,GAAZ,U,CAnDc,C;;WAsDd,K,CAAA,a,EAAA,I,EAAA,K,EAtDc,C;;;;UA0Dd,gB,EAAsB;;aAEpB,e,GAAuBtE,UAAAA,CAAvB,I;aACA,e,GAAuBA,UAAAA,CAAvB,G,CAHoB,C;;;YAOhBrD,OAAAA,CAAAA,UAAAA,KAAJ,a,EAA0C;eACxC,M,GAAcyH,WAAAA,GAAc,KAA5B,e;eACA,M,GAAcC,UAAAA,GAAa,KAA3B,e;;;;aAMG;iBACH,K,GAAaD,WAAAA,GAAc,KAA3B,e;iBACA,I,GAAYC,UAAAA,GAAa,KAAzB,e;0BACA,W,CAAA,O;oBACA,K,CAAA,a,IAA+BpC,kBAAAA,CAAmB,KAAnBA,KAAAA,EAA+B,KAA9D,IAA+BA,C;;OA7ErB,C;;;eAkFd,O,EAAkBV,QAAAA,CAAlB,iB;;WACA,oB,GAnFc,C;;;WAsFd,K,CAAA,c,EAAA,I,EAAA,K;;;;;;;;;;;;4BAUMpH,K,EAAO;UACPkH,IAAAA,GAAO,KAAb,K,CADa,C;;UAIT,CAACA,IAAAA,CAAL,S,EAAqB;aACnB,I;;;;UAIIE,QAAAA,GAAW,KAAA,QAAA,GAAjB,S;;UACMiD,IAAAA,GAAOjD,QAAAA,CAAb,Q;UACMkD,KAAAA,GAAQtK,KAAAA,CAAAA,MAAAA,GAAe,KAAA,UAAA,CAA7B,M;UACMuK,KAAAA,GAAQvK,KAAAA,CAAAA,MAAAA,GAAe,KAAA,UAAA,CAA7B,M,CAZa,C;;WAeb,U,GAAA,K,CAfa,C;;UAkBTqK,IAAAA,KAAJ,G,EAAkB;aAChB,K,IAAA,K;aACA,M,IAAA,K;aACA,e,IAAA,K;OArBW,C;;;UAyBTA,IAAAA,KAAJ,G,EAAkB;aAChB,I,IAAA,K;aACA,M,IAAA,K;aACA,e,IAAA,K;OA5BW,C;;;kBAgCDnD,IAAAA,CAAZ,G,EAAsB,KAAtB,Y,EAAyC,KAAzC,U;;;;;;;;;;;mCASa;;UAET,CAAC,KAAA,KAAA,CAAL,S,EAA2B,OAFd,C;;UAKT,KAAA,QAAA,GAAA,SAAA,CAAJ,Q,EAAwC,KAAA,qBAAA;;;;;;;;;;;iCAS7B;UACLA,IAAAA,GAAO,KAAb,K,CADW,C;;UAIP,CAACA,IAAAA,CAAL,S,EAAqB,OAJV,C;;WAOX,Q,CAAA,K,CAAA,a,IAAqCY,kBAAAA,CAAmB,KAAnBA,KAAAA,EAA+B,KAApE,IAAqCA,C,CAP1B,C;;WAUX,Q,GAAA,K,CAAA,a,EAAA,I,EAA2C,KAA3C,U;;;;;;;;;;;;8BAUQ9H,K,EAAO;UACTkH,IAAAA,GAAO,KAAb,K,CADe,C;;UAIX,CAACA,IAAAA,CAAL,S,EAAqB;aACnB,I;;OALa,C;;;WAUf,gB,GAAA,K,CAVe,C;;oBAaDA,IAAAA,CAAd,G,EAAwB,KAAxB,c,EAA6C,KAA7C,Y;;;;;;;;;;;qCASe;UACTA,IAAAA,GAAO,KAAb,K,CADe,C;;UAIX,CAACA,IAAAA,CAAL,S,EAAqB;UAEf1E,OAAAA,GAAU0E,IAAAA,CAAhB,Q;;UACMC,IAAAA,GAAO,KAAb,QAAa,E;;UACPC,QAAAA,GAAWD,IAAAA,CAAjB,S;UACMkD,IAAAA,GAAOjD,QAAAA,CAAb,Q;UACMW,aAAAA,GAAgBZ,IAAAA,CAAtB,Q;UACItB,UAAAA,GAAAA,KAAJ,C,CAXe,C;;UAcTE,IAAAA,GAAOvD,OAAAA,CAAb,qBAAaA,E;UACP8H,KAAAA,GAAQ,KAAA,eAAA,GAAuBvE,IAAAA,CAArC,I;UACMwE,KAAAA,GAAQ,KAAA,eAAA,GAAuBxE,IAAAA,CAArC,G,CAhBe,C;;UAmBX,KAAA,UAAA,KAAJ,a,EAAuC;qBACxB8D,aAAAA,CAAc,KAAdA,gBAAAA,EAAb,aAAaA,C;aACb,e,GAAuBhE,UAAAA,CAAvB,I;aACA,e,GAAuBA,UAAAA,CAAvB,G;OAtBa,C;;;UA0BXwE,IAAAA,KAAJ,G,EAAkB;aAChB,K,IAAA,K;aACA,M,GAAc,KAAA,KAAA,GAAa,KAA3B,e;OA5Ba,C;;;UAgCXA,IAAAA,KAAJ,G,EAAkB;aAChB,I,IAAA,K;aACA,M,GAAc,KAAA,IAAA,GAAY,KAA1B,e;OAlCa,C;;;UAsCXjD,QAAAA,CAAJ,Q,EAAuB,KAAA,qBAAA;;;;;;;;;;;mCASV;UACPF,IAAAA,GAAO,KAAb,K,CADa,C;;UAIT,CAACA,IAAAA,CAAL,S,EAAqB,OAJR,C;;WAOb,Q,CAAA,K,CAAA,a,IAAqCY,kBAAAA,CAAmB,KAAnBA,KAAAA,EAA+B,KAApE,IAAqCA,C,CAPxB,C;;WAUb,Q,GAAA,K,CAAA,e,EAAA,I,EAA6C,KAA7C,gB;;;;;;;;;;;;2BAUK9H,K,EAAO;UACNkH,IAAAA,GAAO,KAAb,K;UACM1E,OAAAA,GAAU0E,IAAAA,CAAhB,Q;;UACMC,IAAAA,GAAO,KAAb,QAAa,E;;UACPC,QAAAA,GAAWD,IAAAA,CAAjB,S;UACMkC,OAAAA,GAAUnC,IAAAA,CAAhB,Q,CALY,C;;UAQR,CAACA,IAAAA,CAAL,S,EAAqB;aACnB,I;;OATU,C;;;qBAcGA,IAAAA,CAAf,G;uBACiBA,IAAAA,CAAjB,G,EAfY,C;;eAkBZ,Q,IAAqB,KAAA,qBAAA,CAArB,QAAqB,C,CAlBT,C;;WAqBZ,sB,GArBY,C;;;cAwBZ,e,GAA0B,KAA1B,e;cACA,e,GAA0B,KAA1B,e,CAzBY,C;;WA4BZ,M,GA5BY,C;;;kBA+BZ,O,EAAqBE,QAAAA,CAArB,iB,EA/BY,C;;WAkCZ,K,CAAA,Y,EAAA,I,EAAA,K,EAlCY,C;;;WAqCZ,Y,GAAoB,KAApB,gBAAoB,E,GAA0BiC,OAAAA,CAA9C,KAA8CA,E;;;;CA16B5CrC,CAAiBjH,SAAjBiH,C;;;;;;;;;;;;;;;;;;;;;;;;;AAo8BNA,QAAAA,CAAAA,qBAAAA,GAAiC,UAAA,IAAA,EAAA,KAAA,EAAA,OAAA,EAA0B;MACnDC,IAAAA,GAAOC,IAAAA,CAAb,K;;MACMkB,SAAAA,GAAYnB,IAAAA,CAAAA,mBAAAA,IAA4BA,IAAAA,CAAAA,oBAAAA,CAA9C,OAA8CA,C,CAFW,C;;;;;;MAQrDjH,KAAAA,CAAJ,O,EAAmB;SACjB,qB,CAAA,K;;;GATuD,C;;;;;;MAiBrD,CAACoI,SAAAA,CAAL,a,EAA8B;cAC5B,a,GAA0BnB,IAAAA,CAAAA,wBAAAA,CAA1B,KAA0BA,C;QACtB,CAACmB,SAAAA,CAAL,a,EAA8B,OAAA,KAAA;GAnByB,C;;;;MAwBrDA,SAAAA,CAAJ,K,EAAqB;cACnB,K,GAAA,K;;QACI,CAACA,SAAAA,CAAL,U,EAA2B;gBACzB,U,GAAuB,MAAA,CAAA,UAAA,CAAkB,YAAM;kBAC7C,K,GAAA,C;;YACInB,IAAAA,CAAAA,sBAAAA,CAA4BmB,SAAAA,CAAhC,KAAInB,C,EAA8C;eAChD,2B,CAAiCmB,SAAAA,CAAjC,K;;eACA,oB;;AAJmB,OAAA,EAMpBA,SAAAA,CANH,KAAuB,C;;;;SAUpBnB,IAAAA,CAAAA,sBAAAA,CAAP,KAAOA,C;AArCTD,CAAAA;;;;;;;;;;;;;;;;AAqDAA,QAAAA,CAAAA,oBAAAA,GAAkC,YAAM;MAChCwD,QAAAA,GAAN,E;MACMC,UAAAA,GAAN,E;MACMC,UAAAA,GAAN,E;MACMC,aAAAA,GAAN,E;;WAEA,a,CAAA,I,EAAA,Q,EAAA,S,EAAkD;QAC5CC,MAAAA,GAAJ,I;QACMC,QAAAA,GAAWC,QAAAA,CAAAA,SAAAA,CAAjB,Q;QACIC,SAAAA,GAAY,CAAhB,C;QACIC,SAAAA,GAAAA,KAAJ,C;QACIC,KAAAA,GAAAA,KAAJ,C;QACI9D,IAAAA,GAAAA,KAAJ,C;QACI/G,CAAAA,GAAAA,KAAJ,C,CAPgD,C;;QAU5CyK,QAAAA,KAAJ,I,EAAuB;oBACrB,C,IAAA,Q;cACA,a;AAFF,K,MAGO;cACGA,QAAAA,CAAAA,IAAAA,CAAAA,QAAAA,EAAR,IAAQA,C;KAdsC,C;;;QAkB5C,CAACK,KAAAA,CAAAA,OAAAA,CAAL,KAAKA,C,EAAsB,OAAA,MAAA,CAlBqB,C;;SAqB3C9K,CAAAA,GAAL,C,EAAYA,CAAAA,GAAI6K,KAAAA,CAAhB,M,EAA8B7K,CAA9B,E,EAAmC;aAC1B6K,KAAAA,CAAP,CAAOA,C,CAD0B,C;;UAI7B9D,IAAAA,CAAJ,Y,EAAuB,SAJU,C;;;WAQjC,mB,GARiC,C;;;iBAWjC,K,GAAmBA,IAAAA,CAAnB,M;iBACA,M,GAAoBA,IAAAA,CAApB,O;iBACA,I,GAAkBA,IAAAA,CAAlB,K;iBACA,G,GAAiBA,IAAAA,CAAjB,I;kBACYgE,mBAAAA,CAAAA,QAAAA,EAAZ,UAAYA,C,CAfqB,C;;UAkB7BH,SAAAA,GAAAA,SAAAA,IAAyBA,SAAAA,GAA7B,S,EAAoD;oBAClD,S;iBACA,I;;KAzC4C,C;;;kBA8ChD,M,GAAA,C;WAEA,M;;;SAGK,UAAA,IAAA,EAAA,OAAA,EAAmB;QAClB/D,IAAAA,GAAOC,IAAAA,CAAb,K;;QACM4D,QAAAA,GAAW7D,IAAAA,CAAjB,QAAiBA,E,CAFO,C;;;QAKlBmE,aAAAA,GAAgBtJ,OAAAA,IAAW,OAAOA,OAAAA,CAAP,SAAA,KAAXA,QAAAA,GAAmDA,OAAAA,CAAnDA,SAAAA,GAAtB,E;QACMsH,UAAAA,GAAatH,OAAAA,IAAWA,OAAAA,CAAAA,MAAAA,KAAXA,MAAAA,GAAAA,MAAAA,GAAnB,M,CANwB,C;;aASxB,K,GAAiBoF,IAAAA,CAAjB,M;aACA,M,GAAkBA,IAAAA,CAAlB,O;aACA,I,GAAgBD,IAAAA,CAAhB,e;aACA,G,GAAeA,IAAAA,CAAf,e,CAZwB,C;;QAelBE,IAAAA,GAAOkE,aAAAA,CAAAA,IAAAA,EAAAA,QAAAA,EAAb,aAAaA,C,CAfW,C;;;QAmBpB,CAAJ,I,EAAW,OAAA,KAAA;QAEPC,cAAAA,GAAJ,C;QACIC,aAAAA,GAAJ,C;QACIC,UAAAA,GAAa,CAAjB,C;QACIC,UAAAA,GAAAA,KAAJ,C;QACIC,eAAAA,GAAAA,KAAJ,C;QACId,MAAAA,GAAAA,KAAJ,C;QACIe,KAAAA,GAAAA,KAAJ,C;QACIvL,CAAAA,GAAAA,KAAJ,C,CA5BwB,C;;;;QAiCpB+G,IAAAA,KAAJ,Q,EAAuB;eACrB,I,GAAgBF,IAAAA,CAAAA,MAAAA,GAAcC,IAAAA,CAA9B,W;eACA,G,GAAeD,IAAAA,CAAAA,MAAAA,GAAcC,IAAAA,CAA7B,U;AAFF,K,MAGO;WACL,c,CAAA,C,EAAA,C,EAAA,C,EAAA,C;;uBACiBC,IAAAA,CAAAA,KAAAA,GAAaA,IAAAA,CAA9B,W;sBACgBA,IAAAA,CAAAA,IAAAA,GAAYA,IAAAA,CAA5B,U;KAvCsB,C;;;SA2CnB/G,CAAAA,GAAL,C,EAAYA,CAAAA,GAAI+G,IAAAA,CAAAA,MAAAA,CAAhB,M,EAAoC/G,CAApC,E,EAAyC;eAC9B+G,IAAAA,CAAAA,MAAAA,CAAT,CAASA,C,CAD8B,C;;;UAKnC,CAACyD,MAAAA,CAAD,SAAA,IAAqBA,MAAAA,KAAzB,I,EAA0C;;OALH,C;;;wBAUvC,I,CAVuC,C;;iBAavC,K,GAAmBA,MAAAA,CAAnB,M;iBACA,M,GAAoBA,MAAAA,CAApB,O;iBACA,I,GAAkBA,MAAAA,CAAAA,KAAAA,GAAeA,MAAAA,CAAfA,WAAAA,GAAlB,c;iBACA,G,GAAiBA,MAAAA,CAAAA,IAAAA,GAAcA,MAAAA,CAAdA,UAAAA,GAAjB,a;cACQO,mBAAAA,CAAAA,QAAAA,EAAR,UAAQA,C,CAjB+B,C;;;UAqBnCQ,KAAAA,GAAJ,U,EAAwB;qBACtB,C;qBACA,K;;KAlEoB,C;;;;QAwEpBH,UAAAA,GAAAA,aAAAA,IAA8BtE,IAAAA,CAAAA,OAAAA,OAAlC,I,EAA2D;mBAC5CwE,eAAAA,GAAkB,CAAlBA,CAAAA,GAAb,C;mBACA,Q;KA1EsB,C;;;QA8EpBF,UAAAA,IAAJ,a,EAAiC;iBAC/B,I,GAAA,I;iBACA,K,GAAA,U;iBACA,M,GAAA,U;aACA,U;;;WAGF,K;AArFF,G;AAzDFxE,CAAkC,EAAlCA;;;;;;;;;;;;;AA4JA,SAAA,cAAA,CAAA,CAAA,EAA2B;MACrB4E,CAAAA,CAAJ,c,EAAsBA,CAAAA,CAAAA,cAAAA;;;;;;;;;;;;;AAYxB,SAAA,mBAAA,CAAA,CAAA,EAAA,CAAA,EAAmC;;MAG/BC,CAAAA,CAAAA,IAAAA,GAASA,CAAAA,CAATA,KAAAA,IAAoBC,CAAAA,CAApBD,IAAAA,IACAC,CAAAA,CAAAA,IAAAA,GAASA,CAAAA,CAATA,KAAAA,IAAoBD,CAAAA,CADpBA,IAAAA,IAEAA,CAAAA,CAAAA,GAAAA,GAAQA,CAAAA,CAARA,MAAAA,IAAoBC,CAAAA,CAFpBD,GAAAA,IAGAC,CAAAA,CAAAA,GAAAA,GAAQA,CAAAA,CAARA,MAAAA,IAAoBD,CAAAA,CAJtB,G,EAKE;WACA,C;GAR+B,C;;;MAY3BE,KAAAA,GAAQzH,IAAAA,CAAAA,GAAAA,CAASuH,CAAAA,CAAAA,IAAAA,GAASA,CAAAA,CAAlBvH,KAAAA,EAA2BwH,CAAAA,CAAAA,IAAAA,GAASA,CAAAA,CAApCxH,KAAAA,IAA+CA,IAAAA,CAAAA,GAAAA,CAASuH,CAAAA,CAATvH,IAAAA,EAAiBwH,CAAAA,CAA9E,IAA6DxH,C;MACvD0H,MAAAA,GAAS1H,IAAAA,CAAAA,GAAAA,CAASuH,CAAAA,CAAAA,GAAAA,GAAQA,CAAAA,CAAjBvH,MAAAA,EAA2BwH,CAAAA,CAAAA,GAAAA,GAAQA,CAAAA,CAAnCxH,MAAAA,IAA+CA,IAAAA,CAAAA,GAAAA,CAASuH,CAAAA,CAATvH,GAAAA,EAAgBwH,CAAAA,CAA9E,GAA8DxH,C;MACxD2H,QAAAA,GAAW3H,IAAAA,CAAAA,GAAAA,CAASuH,CAAAA,CAATvH,KAAAA,EAAkBwH,CAAAA,CAAnC,KAAiBxH,C;MACX4H,SAAAA,GAAY5H,IAAAA,CAAAA,GAAAA,CAASuH,CAAAA,CAATvH,MAAAA,EAAmBwH,CAAAA,CAArC,MAAkBxH,C;SAETyH,KAAAA,GAAD,MAACA,IAAmBE,QAAAA,GAArB,SAAEF,IAAT,G;;;;;;;;;;;AAUF,SAAA,gBAAA,CAAA,OAAA,EAAA,IAAA,EAAyC;MACjCxG,GAAAA,GAAM4G,IAAAA,IAAZ,E;MACIC,MAAAA,GAAS5J,OAAAA,CAAb,U,CAFuC,C;;;;MAQvC,gB,EAAsB;;QAEhBE,QAAAA,CAAAA,OAAAA,EAAAA,UAAAA,CAAAA,KAAJ,O,EAA+C,OAAA,GAAA,CAF3B,C;;WAKb0J,MAAAA,IAAUA,MAAAA,KAAVA,QAAAA,IAAiCA,MAAAA,KAAWhL,QAAAA,CAAnD,e,EAA6E;UACvEiL,YAAAA,CAAJ,MAAIA,C,EAAsB9G,GAAAA,CAAAA,IAAAA,CAAAA,MAAAA;eACjB7C,QAAAA,CAAAA,MAAAA,EAAAA,UAAAA,CAAAA,KAAAA,OAAAA,GAAAA,IAAAA,GAAkD0J,MAAAA,CAA3D,U;KAPkB,C;;;;eAYpB,I,IAAmB7G,GAAAA,CAAAA,IAAAA,CAAnB,MAAmBA,C;WACnB,G;GArBqC,C;;;;;;SA6BhC6G,MAAAA,IAAUA,MAAAA,KAAjB,Q,EAAsC;;;QAGhC1J,QAAAA,CAAAA,OAAAA,EAAAA,UAAAA,CAAAA,KAAAA,OAAAA,IAA6C,CAAC+C,aAAAA,CAAlD,MAAkDA,C,EAAuB;eAC9D2G,MAAAA,CAAT,U;;KAJkC,C;;;QAShCC,YAAAA,CAAJ,MAAIA,C,EAAsB9G,GAAAA,CAAAA,IAAAA,CAAAA,MAAAA,EATU,C;;cAYpC,M;aACS6G,MAAAA,CAAT,U;GA1CqC,C;;;;MA+CnC7G,GAAAA,CAAIA,GAAAA,CAAAA,MAAAA,GAAJA,CAAAA,CAAAA,KAAwBnE,QAAAA,CAA5B,e,EAAsD;QAChDmE,GAAAA,CAAAA,MAAAA,GAAJ,C,IAAA,M;;OAGG;UACH,I,CAAA,M;;;SAGF,G;;;;;;;;;;AASF,SAAA,YAAA,CAAA,OAAA,EAA+B;MACzB+G,QAAAA,GAAW5J,QAAAA,CAAAA,OAAAA,EAAf,UAAeA,C;MACX4J,QAAAA,KAAAA,MAAAA,IAAuBA,QAAAA,KAA3B,Q,EAAkD,OAAA,IAAA;aAEvC5J,QAAAA,CAAAA,OAAAA,EAAX,YAAWA,C;MACP4J,QAAAA,KAAAA,MAAAA,IAAuBA,QAAAA,KAA3B,Q,EAAkD,OAAA,IAAA;aAEvC5J,QAAAA,CAAAA,OAAAA,EAAX,YAAWA,C;MACP4J,QAAAA,KAAAA,MAAAA,IAAuBA,QAAAA,KAA3B,Q,EAAkD,OAAA,IAAA;SAElD,K;;;;;;;;;;;AAUF,SAAA,OAAA,CAAA,KAAA,EAAwB;SACfhI,IAAAA,CAAAA,GAAAA,CAAStE,KAAAA,CAATsE,MAAAA,IAAAA,CAAAA,IAA8BA,IAAAA,CAAAA,GAAAA,CAAStE,KAAAA,CAATsE,MAAAA,IAA9BA,CAAAA,IAA4DtE,KAAAA,CAAAA,SAAAA,GAAnE,G;;;;;;;;;AAQF,SAAA,cAAA,CAAA,OAAA,EAAiC;;MAE3BwC,OAAAA,CAAAA,OAAAA,CAAAA,WAAAA,OAAJ,G,EAA2C,OAFZ,C;;MAKzB+J,IAAAA,GAAO/J,OAAAA,CAAAA,YAAAA,CAAb,MAAaA,C;MACT,CAAJ,I,EAAW,OANoB,C;;MAS3BoI,MAAAA,GAASpI,OAAAA,CAAAA,YAAAA,CAAb,QAAaA,C;;MACToI,MAAAA,IAAUA,MAAAA,KAAd,O,EAAkC;WAChC,I,CAAA,I,EAAA,M;AADF,G,MAEO;WACL,Q,CAAA,I,GAAA,I;;;;;;;;;;;;;;;;AAeJ,SAAA,kBAAA,GAA8B;;MAExB,CAAJ,oB,EAA2B,OAAA,IAAA,CAFC,C;;MAKxB,CAACxJ,QAAAA,CAAL,I,EAAoB,OAAA,IAAA,CALQ,C;;MAQtBoL,KAAAA,GAAQ,CAAA,CAAA,EAAA,CAAA,EAAA,GAAA,CAAW,UAAA,IAAA,EAAA,OAAA,EAAmB;WACnCpL,QAAAA,CAAAA,aAAAA,CAAP,KAAOA,C;SACP,K,CAAA,Q,GAAsBqL,OAAAA,GAAAA,OAAAA,GAAtB,U;SACA,K,CAAA,O,GAAA,O;SACA,K,CAAA,U,GAAA,Q;SACA,K,CAAA,I,GAAkBA,OAAAA,GAAAA,KAAAA,GAAlB,K;SACA,K,CAAA,a,IAAA,M;WACA,I;AAPF,GAAc,C;MASRC,KAAAA,GAAQtL,QAAAA,CAAAA,IAAAA,CAAAA,WAAAA,CAA0BoL,KAAAA,CAAxC,CAAwCA,CAA1BpL,C;MACRuL,KAAAA,GAAQD,KAAAA,CAAAA,WAAAA,CAAkBF,KAAAA,CAAhC,CAAgCA,CAAlBE,C;MACRE,IAAAA,GAAOD,KAAAA,CAAAA,qBAAAA,GAAb,I;QACA,K,CAAA,a,IAAA,U;MACMpH,GAAAA,GAAMqH,IAAAA,KAASD,KAAAA,CAAAA,qBAAAA,GAArB,I;WACA,I,CAAA,W,CAAA,K;SACA,G;;ACx4CF;;;;;;;;;;;;;;IAcME,KAAAA,GAAAA,UAAAA,UAAAA,EAAAA;;;mBACU;;;;;UAEZ,M,GAAA,E;UACA,Y,GAAA,K;;;;;;;;;;;;;;;;;;;;wBAgBE1M,Q,EAAU;UACR,KAAJ,Y,EAAuB,OAAA,IAAA;;WACvB,M,CAAA,I,CAAA,Q;;aACA,I;;;;;;;;;;;;;;0BAYIE,I,EAAMC,I,EAAM;UACZ,KAAJ,Y,EAAuB,OAAA,IAAA;UAEjBE,KAAAA,GAAQ,KAAd,M;UACMiD,MAAAA,GAASjD,KAAAA,CAAf,M;UACIJ,CAAAA,GAAAA,KAAJ,C,CALgB,C;;UAQZ,CAAJ,M,EAAa,OAAA,IAAA;UAEP0M,cAAAA,GAAiBrJ,MAAAA,KAAvB,C;UACMsJ,QAAAA,GAAWD,cAAAA,GAAiBtM,KAAAA,CAAjBsM,CAAiBtM,CAAjBsM,GAA4BtM,KAAAA,CAAAA,KAAAA,CAA7C,CAA6CA,C,CAX7B,C;;YAchB,M,GAAA,C,CAdgB,C;;UAiBhB,c,EAAoB;iBAClB,I,EAAA,I;eACA,I;OAnBc,C;;;WAuBXJ,CAAAA,GAAL,C,EAAYA,CAAAA,GAAZ,M,EAAwBA,CAAxB,E,EAA6B;iBAC3B,C,EAAA,I,EAAA,I;YACI,KAAJ,Y,EAAuB;;;aAGzB,I;;;;;;;;;;;;8BAUQ;UACJ,KAAJ,Y,EAAuB,OAAA,IAAA;WAEvB,Y,GAAA,I;WACA,M,CAAA,M,GAAA,C;aAEA,I;;;;CA/EEyM,CAAc9M,SAAd8M,C;ACdN;;;;;;;;;;;;;;IAwBMG,UAAAA,GAAAA,UAAAA,UAAAA,EAAAA;;;sBACJ,I,EAAkB;;;uHAAA,I;;UAEhB,K,GAAA,I;UACA,S,GAAA,K;UACA,Y,GAAA,K;UACA,c,GAAA,K;UACA,c,GAAA,E;UACA,a,GAAA,E;UACA,Y,GAAA,C;UACA,W,GAAA,C;UACA,W,GAAA,C;UACA,U,GAAA,C;UACA,kB,GAAA,K;UACA,e,GAAuB;gBACX,KAAA,CAAA,OAAA,CAAA,IAAA,CAAA,KAAA;AADW,K;UAGvB,M,GAAc,IAAd,KAAc,E,CAhBE,C;;UAmBhB,e,GAAuB,KAAA,CAAA,eAAA,CAAA,IAAA,CAAvB,KAAuB,C;UACvB,e,GAAuB,KAAA,CAAA,eAAA,CAAA,IAAA,CAAvB,KAAuB,C;;;;;;;;;;;;;;;;;;;;;0BAiBnBC,O,EAASC,Q,EAAU;UACnB,KAAJ,Y,EAAuB;UAEjBhG,IAAAA,GAAO,KAAb,K;UACM1E,OAAAA,GAAU0E,IAAAA,CAAhB,Q;UACMmC,OAAAA,GAAUnC,IAAAA,CAAhB,Q;;UACMiG,YAAAA,GAAejG,IAAAA,CAAAA,OAAAA,GAArB,S;;UACMkG,aAAAA,GAAgB,KAAtB,S;UACMC,cAAAA,GAAiBhE,OAAAA,CAAAA,SAAAA,IAAqBA,OAAAA,CAAAA,qBAAAA,KAA5C,K;UACMiE,YAAAA,GAAeD,cAAAA,GACjBF,YAAAA,CADiBE,mBAAAA,GAEjBF,YAAAA,CAFJ,c;UAGMI,UAAAA,GAAaF,cAAAA,GAAiBF,YAAAA,CAAjBE,iBAAAA,GAAkDF,YAAAA,CAArE,Y;UACMK,WAAAA,GAAc,CAAA,OAAA,IAAY,CAAC,KAAb,kBAAA,IAAwCF,YAAAA,GAA5D,C;UACIG,WAAAA,GAAAA,KAAJ,C,CAduB,C;;;UAkBvB,a,EAAmB,KAAA,MAAA,CAAA,KAAA,CAAA,IAAA,EAAA,IAAA,EAlBI,C;;UAqBvB,c,EAAoBpE,OAAAA,CAAAA,qBAAAA,GAAAA,IAAAA,CArBG,C;;UAwBnB,OAAA,QAAA,KAAJ,U,EAAoC,KAAA,MAAA,CAAA,GAAA,CAAA,QAAA,EAxBb,C;;UA2BnB,CAAJ,W,EAAkB;aAChB,c;;aACA,mB;;yBACiBqE,gBAAAA,CAAiBxG,IAAAA,CAAlC,GAAiBwG,C;sBACHxG,IAAAA,CAAAA,QAAAA,CAAd,WAAcA,E;aACd,I,CAAA,K,EAAiB,KAAjB,a;SACA,W,IAAgByG,SAAAA,CAAAA,OAAAA,EAAmB,KAAnC,aAAgBA,C;aAChB,kB,GAAA,K;eACO,KAAP,OAAO,E;OAnCc,C;;;;WAwCvB,S,GAAA,I;WACA,e,CAAA,M,GAAA,U;WACA,e,CAAA,Q,GAAA,Y;WACA,c,GAAA,a,CA3CuB,C;;oBA8CTzG,IAAAA,CAAd,G,EAAwB,KAAxB,e,EAA8C,KAA9C,e;aAEA,I;;;;;;;;;;;;;;yBAYG0G,oB,EAAsBC,Y,EAAc;UACnC,KAAA,YAAA,IAAqB,CAAC,KAA1B,S,EAA0C,OAAA,IAAA;UAEpC3G,IAAAA,GAAO,KAAb,K,CAHuC,C;;uBAMtBA,IAAAA,CAAjB,G,EANuC,C;;WASvC,Q,CAAA,I,CAAA,Y,EATuC,C;;;kBAY3BA,IAAAA,CAAZ,Q,EAA2BA,IAAAA,CAAAA,OAAAA,GAAAA,SAAAA,CAA3B,oB,EAZuC,C;;WAevC,S,GAAA,K,CAfuC,C;;UAkBvC,oB,EAA0B,KAAA,MAAA,CAAA,KAAA,CAAA,IAAA,EAAA,IAAA;aAE1B,I;;;;;;;;;;;;8BAUQ;UACJ,KAAJ,Y,EAAuB,OAAA,IAAA;WACvB,I,CAAA,I,EAAA,E;;WACA,M,CAAA,O;;WACA,K,GAAa,KAAA,cAAA,GAAsB,KAAA,aAAA,GAAqB,KAAA,eAAA,GAAxD,I;WACA,Y,GAAA,I;aACA,I;;;;;;;;;;;;;;;;qCAce;UACX,KAAJ,Y,EAAuB;UAEjBA,IAAAA,GAAO,KAAb,K;UACM6C,OAAAA,GAAU7C,IAAAA,CAAhB,Q;UACMmC,OAAAA,GAAUnC,IAAAA,CAAhB,Q;WAEA,W,GAAmBmC,OAAAA,CAAAA,SAAAA,GACfA,OAAAA,CADeA,eAAAA,GAEfU,OAAAA,CAAAA,SAAAA,GACEA,OAAAA,CADFA,eAAAA,GAFJ,C;WAMA,U,GAAkBV,OAAAA,CAAAA,SAAAA,GACdA,OAAAA,CADcA,eAAAA,GAEdU,OAAAA,CAAAA,SAAAA,GACEA,OAAAA,CADFA,eAAAA,GAFJ,C;;;;;;;;;;;0CAaoB;UAChB,KAAJ,Y,EAAuB;UAEjB7C,IAAAA,GAAO,KAAb,K;WAEA,a,CAAA,S,GAA+BY,kBAAAA,CAC7BZ,IAAAA,CAAAA,KAAAA,GAAa,KADgBY,WAAAA,EAE7BZ,IAAAA,CAAAA,IAAAA,GAAY,KAFd,UAA+BY,C;;;;;;;;;;;8BAYvB;UACJ,KAAJ,Y,EAAuB;UAEjBZ,IAAAA,GAAO,KAAb,K;UACM6C,OAAAA,GAAU7C,IAAAA,CAAhB,Q;UACMmC,OAAAA,GAAUnC,IAAAA,CAAhB,Q,CALQ,C;;UAQJ,KAAJ,S,EAAoB;aAClB,S,GAAA,K;oBACYA,IAAAA,CAAZ,Q,EAA2BA,IAAAA,CAAAA,OAAAA,GAAAA,SAAAA,CAA3B,oB;OAVM,C;;;UAcJmC,OAAAA,CAAJ,S,EAAuBA,OAAAA,CAAAA,IAAAA;UACnBU,OAAAA,CAAJ,S,EAAuBA,OAAAA,CAAAA,IAAAA,GAff,C;;WAkBR,M,CAAA,K,CAAA,K,EAAA,I;;;;;;;;;;;sCASgB;UACVvH,OAAAA,GAAU,KAAA,KAAA,CAAhB,Q;UACMoH,SAAAA,GAAYE,YAAAA,CAAlB,OAAkBA,C;WAClB,Y,GAAoBF,SAAAA,CAApB,C;WACA,W,GAAmBA,SAAAA,CAAnB,C;;;;;;;;;;;sCASgB;UACV1C,IAAAA,GAAO,KAAb,K;UACM1E,OAAAA,GAAU0E,IAAAA,CAAhB,Q;UACMC,IAAAA,GAAOD,IAAAA,CAAb,OAAaA,E;UACPE,QAAAA,GAAWD,IAAAA,CAAjB,S,CAJgB,C;;WAOhB,c;;WACA,mB,GARgB,C;;;UAYdD,IAAAA,CAAAA,KAAAA,KAAe,KAAA,YAAA,GAAoB,KAAnCA,WAAAA,IACAA,IAAAA,CAAAA,IAAAA,KAAc,KAAA,WAAA,GAAmB,KAFnC,U,EAGE;YACI,KAAJ,c,EAAyB,KAAA,IAAA,CAAA,KAAA,EAAiB,KAAjB,aAAA;aACzB,S,GAAA,K;;aACA,O;;;OAjBc,C;;;OAsBf,KAAD,c,IAAwB4G,QAAAA,CAAAA,OAAAA,EAAkB1G,QAAAA,CAA1C,oBAAwB0G,C,CAtBR,C;;WAyBhB,c,CAAA,S,GAAgChG,kBAAAA,CAAmB,KAAnBA,YAAAA,EAAsC,KAAtE,WAAgCA,C,CAzBhB,C;;WA4BhB,Q,CAAA,K,CAAoB,KAApB,c,EAAyC,KAAzC,a,EAA6D,KAA7D,e;;;;CAnQEkF,CAAmBjN,SAAnBiN,C;ACxBN;;;;;;;AAsBA,IAAMe,UAAAA,GAAN,EAAA;;;;;;;;IAQMC,WAAAA,GAAAA,UAAAA,UAAAA,EAAAA;;;uBACJ,I,EAAkB;sCAAA,C;;yHAAA,I;;UAGhB,K,GAAA,I;UACA,S,GAAA,K;UACA,Y,GAAA,K;UACA,U,GAAA,K;UACA,e,GAAA,C;UACA,e,GAAA,C;;;;;;;;;;;;;;;;;;;;;;0BAkBI9E,U,EAAY+E,Q,EAAUC,S,EAAW;UACjC,KAAJ,Y,EAAuB,OAAA,IAAA;UAEjBhH,IAAAA,GAAO,KAAb,K;UACM1E,OAAAA,GAAU0E,IAAAA,CAAhB,Q;UACMiH,SAAAA,GAAYjH,IAAAA,CAAlB,SAAkBA,E;UACZC,IAAAA,GAAOD,IAAAA,CAAb,OAAaA,E;UACPE,QAAAA,GAAWD,IAAAA,CAAjB,S;UACMqC,cAAAA,GAAiBN,UAAAA,CAAvB,S;UACMkF,aAAAA,GAAgBlF,UAAAA,CAAtB,Q;UACMmF,WAAAA,GAAcnF,UAAAA,CAApB,M;;UACM/F,YAAAA,GAAegE,IAAAA,CAAAA,MAAAA,CAAAA,OAAAA,CAArB,IAAqBA,C;;UACfsC,eAAAA,GAAkByE,SAAAA,IAAa9M,QAAAA,CAArC,I;UACI+H,WAAAA,GAAAA,KAAJ,C;UACImF,UAAAA,GAAAA,KAAJ,C;UACI3E,gBAAAA,GAAAA,KAAJ,C;UACI9D,UAAAA,GAAAA,KAAJ,C;UACI0I,aAAAA,GAAAA,KAAJ,C;UACI3E,SAAAA,GAAAA,KAAJ,C;UACI4E,UAAAA,GAAAA,KAAJ,C;UACIC,UAAAA,GAAAA,KAAJ,C,CApBqC,C;;UAuBjC,OAAA,QAAA,KAAJ,Q,EAAkC;sBAClB/J,mBAAAA,CAAAA,WAAAA,EAAAA,QAAAA,EAAd,IAAcA,C;AADhB,O,MAEO;qBACQwE,UAAAA,CAAAA,QAAAA,CAAb,QAAaA,C;;;YAET,CAAJ,U,EAAiB,OAAA,IAAA;sBACHmF,WAAAA,CAAAA,OAAAA,CAAd,UAAcA,C;OA7BqB,C;;;UAiCjCnH,IAAAA,CAAAA,aAAAA,MAAwB,KAAxBA,SAAAA,IAA0CA,IAAAA,CAA9C,WAA8CA,E,EAAoB;oBACpD4C,YAAAA,CAAZ,OAAYA,C;qBACCF,SAAAA,CAAb,C;qBACaA,SAAAA,CAAb,C;OApCmC,C;;;UAwCjC1C,IAAAA,CAAJ,aAAIA,E,EAAsB;aACxB,O,CAAA,I,CAAA,I,EAAwB;AAAE7B,UAAAA,SAAAA,EAAWyC,kBAAAA,CAAAA,UAAAA,EAArC,UAAqCA;AAAb,S;OAzCW,C;;;UA6CjC,KAAJ,S,EAAoB;sBACJ,KAAd,e;sBACc,KAAd,e;aACA,I,CAAA,I,EAAgB;AAAEzC,UAAAA,SAAAA,EAAWyC,kBAAAA,CAAAA,UAAAA,EAA7B,UAA6BA;AAAb,S;OAhDmB,C;;;UAoDjCZ,IAAAA,CAAJ,WAAIA,E,EAAoB;sBACRA,IAAAA,CAAAA,QAAAA,CAAd,e;sBACcA,IAAAA,CAAAA,QAAAA,CAAd,e;;aACA,Q,CAAA,I,CAAA,I,EAAyB;AAAE7B,UAAAA,SAAAA,EAAWyC,kBAAAA,CAAAA,UAAAA,EAAtC,UAAsCA;AAAb,S;OAvDU,C;;;WA2DrC,W,CAAA,c,GA3DqC,C;;;UA8DjCZ,IAAAA,CAAJ,K,EAAgBA,IAAAA,CAAAA,KAAAA,CAAAA,OAAAA,GA9DqB,C;;WAiErC,W,CAAA,M,CAAA,K,CAAA,I,EAAA,I,EAjEqC,C;;;UAoEjCC,IAAAA,CAAAA,aAAAA,CAAJ,eAAIA,C,EAAqC;aACvC,K,CAAA,e,EAA4B;gBAAA,IAAA;oBAAA,IAAA;qBAAA,YAAA;kBAAA,UAAA;mBAKjBgC;AALiB,S;OArEO,C;;;UA+EjCD,UAAAA,CAAAA,aAAAA,CAAJ,kBAAIA,C,EAA8C;mBAChD,K,CAAA,kB,EAAqC;gBAAA,IAAA;oBAAA,IAAA;qBAAA,YAAA;kBAAA,UAAA;mBAK1BC;AAL0B,S;OAhFF,C;;;kBA0FrC,O,EAAqB/B,QAAAA,CAArB,S;kBACA,O,EAAqBA,QAAAA,CAArB,gB;kBACA,O,EAAqBA,QAAAA,CAArB,e,EA5FqC,C;;eA+FrC,O,EAAkBoC,cAAAA,CAAlB,S;eACA,O,EAAkB2E,SAAAA,GAAY3E,cAAAA,CAAZ2E,gBAAAA,GAA8C3E,cAAAA,CAAhE,e,EAhGqC,C;;WAmGrC,M,CAAA,M,CAAA,Y,EAAA,C;;kBACA,W,EAAA,I,EAAA,W,EApGqC,C;;WAuGrC,O,GAAeN,UAAAA,CAAf,G,CAvGqC,C;;yBA0GlB1G,OAAAA,CAAnB,U,CA1GqC,C;;;UA8GjCiH,eAAAA,KAAJ,gB,EAA0C;wBACxC,W,CAAA,O;qBACaI,aAAAA,CAAAA,eAAAA,EAAAA,gBAAAA,EAAb,IAAaA,C;;YACT,CAAJ,S,EAAgB;sBACFC,YAAAA,CAAZ,OAAYA,C;uBACCF,SAAAA,CAAb,C;uBACaA,SAAAA,CAAb,C;;;gBAEF,K,CAAA,a,IAA+B9B,kBAAAA,CAC7B0G,UAAAA,GAAa3I,UAAAA,CADgBiC,IAAAA,EAE7B2G,UAAAA,GAAa5I,UAAAA,CAFf,GAA+BiC,C;OAtHI,C;;;WA6HrC,M,CAAA,e,CAAA,O;;gBACUZ,IAAAA,CAAV,M,EAAuBiH,SAAAA,GAAY3E,cAAAA,CAAZ2E,aAAAA,GAA2C3E,cAAAA,CAAlE,Y,EA9HqC,C;;cAiIrC,K,CAAA,O,GAAwB2E,SAAAA,GAAAA,OAAAA,GAAxB,Q,CAjIqC,C;;sBAoIrBtE,aAAAA,CAAAA,eAAAA,EAAAA,aAAAA,EAAhB,IAAgBA,C,CApIqB,C;;WAuIrC,kB;;WACA,gB,GAxIqC,C;;;WA2IrC,K,GAAaL,cAAAA,CAAAA,WAAAA,GAA6B,IAAA,QAAA,CAA7BA,IAA6B,CAA7BA,GAAb,I,CA3IqC,C;;WA8IrC,S,GAAA,I;WACA,U,GAAA,e;WACA,e,GAAuB+E,aAAAA,CAAvB,I;WACA,e,GAAuBA,aAAAA,CAAvB,G,CAjJqC,C;;UAoJjCpH,IAAAA,CAAAA,aAAAA,CAAJ,SAAIA,C,EAA+B;aACjC,K,CAAA,S,EAAsB;gBAAA,IAAA;oBAAA,IAAA;qBAAA,YAAA;kBAAA,UAAA;mBAKXgC;AALW,S;OArJa,C;;;UA+JjCD,UAAAA,CAAAA,aAAAA,CAAJ,YAAIA,C,EAAwC;mBAC1C,K,CAAA,Y,EAA+B;gBAAA,IAAA;oBAAA,IAAA;qBAAA,YAAA;kBAAA,UAAA;mBAKpBC;AALoB,S;;;aASjC,I;;;;;;;;;;;;;;;;;yBAeGuF,K,EAAOC,a,EAAe;UACrB,KAAA,YAAA,IAAqB,CAAC,KAA1B,S,EAA0C,OAAA,IAAA;UAEpCzH,IAAAA,GAAO,KAAb,K;UACM1E,OAAAA,GAAU0E,IAAAA,CAAhB,Q;UACMC,IAAAA,GAAOD,IAAAA,CAAb,OAAaA,E;UACP0H,WAAAA,GAAczH,IAAAA,CAApB,Q;UACIyC,SAAAA,GAAAA,KAAJ,C;;UAEI,KAAA,UAAA,KAAJ,W,EAAqC;YAC/B,CAAJ,a,EAAoB;cAClB,K,EAAW;wBACGE,YAAAA,CAAZ,OAAYA,C;uBACZ,S,GAAuBhC,kBAAAA,CACrB8B,SAAAA,CAAAA,CAAAA,GAAc,KADO9B,eAAAA,EAErB8B,SAAAA,CAAAA,CAAAA,GAAc,KAFhB,eAAuB9B,C;AAFzB,W,MAMO;uBACL,S,GAAuBA,kBAAAA,CAAmBZ,IAAAA,CAAnBY,KAAAA,EAA+BZ,IAAAA,CAAtD,IAAuBY,C;;;0BAEzB,U;;;oBAEF,W,CAAA,O;kBACA,O,EAAA,a;;;WAGF,S,GAAA,K;WACA,U,GAAA,I;WACA,e,GAAA,C;WACA,e,GAAA,C;aAEA,I;;;;;;;;;;;;8BAUQ;UACJ,KAAJ,Y,EAAuB,OAAA,IAAA;WACvB,I,CAAA,I;WACA,K,GAAA,I;WACA,Y,GAAA,I;aACA,I;;;;CAjQEkG,CAAoBjO,SAApBiO,C;AC9BN;;;;;;;AAeA,IAAMD,YAAAA,GAAN,EAAA;;;;;;;;;;;IAWMc,WAAAA,GAAAA,UAAAA,UAAAA,EAAAA;;;uBACJ,I,EAAkB;;;yHAAA,I;;UAEhB,K,GAAA,I;UACA,S,GAAA,K;UACA,Y,GAAA,K;UACA,qB,GAAA,K;UACA,e,GAAA,C;UACA,e,GAAA,C;;;;;;;;;;;;;;;;;;;4BAeM;UACF,KAAA,YAAA,IAAqB,KAAzB,S,EAAyC,OAAA,IAAA;UAEnC3H,IAAAA,GAAO,KAAb,K;UACMC,IAAAA,GAAOD,IAAAA,CAAb,OAAaA,E,CAJP,C;;WAON,S,GAAA,I,CAPM,C;;eAUGA,IAAAA,CAAT,Q,EAAwBC,IAAAA,CAAAA,SAAAA,CAAxB,kB,EAVM,C;;WAaN,K,CAAA,qB,EAAA,I,EAbM,C;;;WAgBN,O,CAAA,K,CAAA,K;;aAEA,I;;;;;;;;;;;;;;;;;;;yBAiBGuH,K,EAAOC,a,EAAe;UACrB,KAAA,YAAA,IAAqB,CAAC,KAA1B,S,EAA0C,OAAA,IAAA;UAEpCzH,IAAAA,GAAO,KAAb,K;UACM1E,OAAAA,GAAU0E,IAAAA,CAAhB,Q;UACMC,IAAAA,GAAOD,IAAAA,CAAb,OAAaA,E;UACPgH,SAAAA,GAAY/G,IAAAA,CAAlB,Q;UACIyC,SAAAA,GAAAA,KAAJ,C,CAPyB,C;;WAUzB,M,GAVyB,C;;;;UAcrBpH,OAAAA,CAAAA,UAAAA,KAAJ,S,EAAsC;YAChC,CAAJ,a,EAAoB;cAClB,K,EAAW;wBACGsH,YAAAA,CAAZ,OAAYA,C;yBACZ,S,GAAuBhC,kBAAAA,CACrB8B,SAAAA,CAAAA,CAAAA,GAAc,KADO9B,eAAAA,EAErB8B,SAAAA,CAAAA,CAAAA,GAAc,KAFhB,eAAuB9B,C;AAFzB,W,MAMO;yBACL,S,GAAuBA,kBAAAA,CAAmBZ,IAAAA,CAAnBY,KAAAA,EAA+BZ,IAAAA,CAAtD,IAAuBY,C;;;0BAEzB,Y;;;kBAEF,W,CAAA,O;kBACA,O,EAAA,a;OA5BuB,C;;;UAgCrB,CAAJ,K,EAAYX,IAAAA,CAAAA,KAAAA,CAAAA,mBAAAA,EAAAA,IAAAA;aAEZ,I;;;;;;;;;;;;8BAUQ;UACJ,KAAJ,Y,EAAuB,OAAA,IAAA;WACvB,I,CAAA,I;WACA,K,GAAA,I;WACA,Y,GAAA,I;aACA,I;;;;;;;;;;;;;;;;6BAcO;UACH,KAAJ,Y,EAAuB;UACjBD,IAAAA,GAAO,KAAb,K;WACA,S,GAAA,K;WACA,qB,GAAA,K;WACA,e,GAAA,C;WACA,e,GAAA,C;kBACYA,IAAAA,CAAZ,Q,EAA2BA,IAAAA,CAAAA,OAAAA,GAAAA,SAAAA,CAA3B,kB;;;;CAhIE2H,CAAoB9O,SAApB8O,C;AC1BN;;;;;;;;;;;;;;;AAgBe,SAAA,gBAAA,CAAA,OAAA,EAAA,MAAA,EAA2C;MAClDC,OAAAA,GAAN,E;;OACK,IAAL,I,IAAA,M,EAA2B;YACzB,I,IAAgBpM,QAAAA,CAAAA,OAAAA,EAAkBC,YAAAA,CAAlC,IAAkCA,CAAlBD,C;;;SAElB,O;;ACrBF;;;;;;;;;;;;;;IAwBMqM,cAAAA,GAAAA,UAAAA,UAAAA,EAAAA;;;0BACJ,I,EAAkB;;;+HAAA,I;;QAEVzF,QAAAA,GAAWpC,IAAAA,CAAjB,S;QACM1E,OAAAA,GAAU0E,IAAAA,CAAhB,Q;;QACME,QAAAA,GAAWF,IAAAA,CAAAA,OAAAA,GAAjB,S;;UAEA,K,GAAA,I;UACA,Y,GAAA,K,CAPgB,C;;UAUhB,S,GAAiB,CAAjB,Q;UACA,S,GAAA,K;UACA,U,GAAA,K,CAZgB,C;;UAehB,M,GAAc,IAAd,KAAc,E,CAfE,C;;UAkBhB,W,GAAmB,KAAA,CAAA,WAAA,CAAA,IAAA,CAAnB,KAAmB,C;UACnB,W,GAAmB,KAAA,CAAA,WAAA,CAAA,IAAA,CAAnB,KAAmB,C,CAnBH,C;;YAsBhB,K,CAAA,O,GAAwBoC,QAAAA,GAAAA,OAAAA,GAAxB,M,CAtBgB,C;;aAyBhB,O,EAAkBA,QAAAA,GAAWlC,QAAAA,CAAXkC,gBAAAA,GAAuClC,QAAAA,CAAzD,e,EAzBgB,C;;cA4BNF,IAAAA,CAAV,M,EAAuBoC,QAAAA,GAAWlC,QAAAA,CAAXkC,aAAAA,GAAoClC,QAAAA,CAA3D,Y;;;;;;;;;;;;;;;;;;;;;yBAiBG6F,O,EAASC,Q,EAAU;UAClB,KAAJ,Y,EAAuB,OAAA,IAAA;UAEjBhG,IAAAA,GAAO,KAAb,K;UACM1E,OAAAA,GAAU0E,IAAAA,CAAhB,Q;UACM1G,KAAAA,GAAQ,KAAd,M;UACML,QAAAA,GAAW,OAAA,QAAA,KAAA,UAAA,GAAA,QAAA,GAAjB,I;UACMgH,IAAAA,GAAOD,IAAAA,CAAb,OAAaA,E;UACPE,QAAAA,GAAWD,IAAAA,CAAjB,S,CARsB,C;;UAWlB,CAAC,KAAD,UAAA,IAAoB,CAAC,KAAzB,S,EAAyC;oBAC3BhH,QAAAA,CAAAA,KAAAA,EAAZ,IAAYA,C;eACZ,I;OAboB,C;;;;UAkBlB,KAAA,UAAA,IAAmB,CAAvB,O,EAAiC;oBACnBK,KAAAA,CAAAA,GAAAA,CAAZ,QAAYA,C;eACZ,I;OApBoB,C;;;;;UA0BlB,CAAC,KAAL,U,EAAsB;cACpB,K,CAAA,I,EAAA,I;oBACA,O,EAAqB4G,QAAAA,CAArB,e;iBACA,O,EAAkBA,QAAAA,CAAlB,gB;YACI,CAAC,KAAL,S,EAAqB5E,OAAAA,CAAAA,KAAAA,CAAAA,OAAAA,GAAAA,OAAAA;OA9BD,C;;;kBAkCVhC,KAAAA,CAAAA,GAAAA,CAAZ,QAAYA,C,CAlCU,C;;WAqCtB,S,GAAiB,KAAA,UAAA,GAAjB,I;WACA,S,GAAiB,KAAA,SAAA,GAAjB,K,CAtCsB,C;;WAyCtB,e,CAAA,I,EAAA,O,EAAoC,KAApC,W;;aAEA,I;;;;;;;;;;;;;;yBAYGyM,O,EAASC,Q,EAAU;UAClB,KAAJ,Y,EAAuB,OAAA,IAAA;UAEjBhG,IAAAA,GAAO,KAAb,K;UACM1E,OAAAA,GAAU0E,IAAAA,CAAhB,Q;UACM1G,KAAAA,GAAQ,KAAd,M;UACML,QAAAA,GAAW,OAAA,QAAA,KAAA,UAAA,GAAA,QAAA,GAAjB,I;UACMgH,IAAAA,GAAOD,IAAAA,CAAb,OAAaA,E;UACPE,QAAAA,GAAWD,IAAAA,CAAjB,S,CARsB,C;;UAWlB,CAAC,KAAD,SAAA,IAAmB,KAAvB,S,EAAuC;oBACzBhH,QAAAA,CAAAA,KAAAA,EAAZ,IAAYA,C;eACZ,I;OAboB,C;;;;UAkBlB,KAAA,SAAA,IAAkB,CAAtB,O,EAAgC;oBAClBK,KAAAA,CAAAA,GAAAA,CAAZ,QAAYA,C;eACZ,I;OApBoB,C;;;;;UA0BlB,CAAC,KAAL,S,EAAqB;cACnB,K,CAAA,I,EAAA,I;iBACA,O,EAAkB4G,QAAAA,CAAlB,e;oBACA,O,EAAqBA,QAAAA,CAArB,gB;OA7BoB,C;;;kBAiCV5G,KAAAA,CAAAA,GAAAA,CAAZ,QAAYA,C,CAjCU,C;;WAoCtB,S,GAAiB,KAAA,SAAA,GAAjB,I;WACA,S,GAAiB,KAAA,UAAA,GAAjB,K,CArCsB,C;;WAwCtB,e,CAAA,K,EAAA,O,EAAqC,KAArC,W;;aAEA,I;;;;;;;;;;;;8BAUQ;UACJ,KAAJ,Y,EAAuB,OAAA,IAAA;UAEjB0G,IAAAA,GAAO,KAAb,K;UACM1E,OAAAA,GAAU0E,IAAAA,CAAhB,Q;UACMC,IAAAA,GAAOD,IAAAA,CAAb,OAAaA,E;UACP1G,KAAAA,GAAQ,KAAd,M;UACM4G,QAAAA,GAAWD,IAAAA,CAAjB,S,CAPQ,C;;WAUR,c,CAAA,E,EAVQ,C;;;YAaR,K,CAAA,I,EAAA,I,EAAA,O,GAbQ,C;;kBAgBR,O,EAAqBC,QAAAA,CAArB,gB;kBACA,O,EAAqBA,QAAAA,CAArB,e,EAjBQ,C;;WAoBR,K,GAAA,I;WACA,S,GAAiB,KAAA,UAAA,GAAjB,K;WACA,Y,GAAoB,KAAA,SAAA,GAApB,I;aAEA,I;;;;;;;;;;;;;;;;;;;oCAiBc4H,S,EAAW/B,O,EAASC,Q,EAAU;UACxC,KAAJ,Y,EAAuB;UAEjBhG,IAAAA,GAAO,KAAb,K;;UACME,QAAAA,GAAWF,IAAAA,CAAAA,OAAAA,GAAjB,S;;UACM2G,YAAAA,GAAemB,SAAAA,GAAY5H,QAAAA,CAAZ4H,aAAAA,GAAqC5H,QAAAA,CAA1D,Y;UACM6H,QAAAA,GAAWC,QAAAA,CAASF,SAAAA,GAAY5H,QAAAA,CAAZ4H,YAAAA,GAAoC5H,QAAAA,CAA7C8H,YAAAA,CAAAA,IAAjB,C;UACMC,MAAAA,GAAS,CAACH,SAAAA,GAAY5H,QAAAA,CAAZ4H,UAAAA,GAAkC5H,QAAAA,CAAnC,UAAA,KAAf,M;UACMgI,SAAAA,GAAYnC,OAAAA,IAAWgC,QAAAA,IAA7B,C;UACIN,aAAAA,GAAAA,KAAJ,C,CAT4C,C;;UAYxC,CAAJ,Y,EAAmB;oBACLzB,QAAZ,E;;OAb0C,C;;;2BAkBvBhG,IAAAA,CAArB,G,EAlB4C,C;;UAqB5C,S,EAAe;YACTA,IAAAA,CAAAA,aAAAA,CAAJ,WAAIA,E,EAAkC;eACpC,a,CAAA,I,CAAA,Y;AADF,S,MAEO;oBACKA,IAAAA,CAAV,M,EAAA,Y;;;oBAEUgG,QAAZ,E;;OA3B0C,C;;;wBAiC1ChG,IAAAA,CADF,G,EAEE,YAAM;wBACYmI,gBAAAA,CAAiBnI,IAAAA,CAAjBmI,MAAAA,EAAhB,YAAgBA,C;AAHpB,O,EAKE,YAAM;aACJ,a,CAAA,K,CAAA,a,EAAA,Y,EAAsD;oBAAA,QAAA;kBAAA,MAAA;;AAAA,S;AAN1D,O;;;;;;;;;;;;mCAsBaxB,Y,EAAc;UACvB,KAAJ,Y,EAAuB;UACjB3G,IAAAA,GAAO,KAAb,K;2BACqBA,IAAAA,CAArB,G;;WACA,a,CAAA,I,CAAA,Y;;;;;;;;;;;kCASY;UACR,KAAJ,S,EAAoB;WACpB,U,GAAA,K;;WACA,M,CAAA,K,CAAA,K,EAAyB,KAAzB,K;;;;kCAGY;UACR,CAAC,KAAL,S,EAAqB;UACfA,IAAAA,GAAO,KAAb,K;WACA,S,GAAA,K;mBACA,S,GAAyBY,kBAAAA,CAAAA,CAAAA,EAAzB,CAAyBA,C;;WACzB,O,CAAA,I,CAAA,I,EAAA,Y;;WACA,Q,CAAA,K,CAAA,O,GAAA,M;;WACA,M,CAAA,K,CAAA,K,EAAA,I;;;;CAlREiH,CAAuBhP,SAAvBgP,C;;;;;;;;;AA4RN,IAAMO,YAAAA,GAAN,EAAA;ACpTA;;;;;;AAMA,IAAIvM,EAAAA,GAAJ,CAAA;;;;;;AAMe,SAAA,SAAA,GAAqB;SAC3B,EAAP,E;;ACbF;;;;;;;;;;;;;;;;IA+BMwM,IAAAA,GAAAA,YAAAA;gBACJ,I,EAAA,O,EAAA,Q,EAAqC;;QAC7BnI,QAAAA,GAAWD,IAAAA,CAAjB,S,CADmC,C;;SAInC,G,GAAWqI,SAAX,E,CAJmC,C;;SAOnC,O,GAAerI,IAAAA,CAAf,G,CAPmC,C;;SAUnC,Y,GAAA,K,CAVmC,C;;SAanC,K,GAAA,C;SACA,I,GAAA,C,CAdmC,C;;SAiBnC,Q,GAAA,O;SACA,M,GAAc3E,OAAAA,CAAAA,QAAAA,CAAd,CAAcA,C,CAlBqB,C;;;QAsB/BA,OAAAA,CAAAA,UAAAA,KAAuB2E,IAAAA,CAA3B,Q,EAA0C;WACxC,Q,CAAA,W,CAAA,O;KAvBiC,C;;;aA2BnC,O,EAAkBC,QAAAA,CAAlB,S,EA3BmC,C;;QA8B/B,OAAA,QAAA,KAAJ,S,EAAmC;iBACtB1E,QAAAA,CAAAA,OAAAA,EAAAA,SAAAA,CAAAA,KAAX,M;KA/BiC,C;;;;SAoCnC,S,GAAA,Q,CApCmC,C;;YAuCnC,K,CAAA,I,GAAA,G;YACA,K,CAAA,G,GAAA,G;YACA,K,CAAA,a,IAA+BoF,kBAAAA,CAAAA,CAAAA,EAA/B,CAA+BA,C,CAzCI,C;;SA4CnC,Q,GAAgB,IAAA,WAAA,CAAhB,OAAgB,C;SAChB,a,GAAqB,IAAA,WAAA,CAAgB,KAArC,MAAqB,C,CA7Cc,C;;SAgDnC,W,GAAmB,IAAA,cAAA,CAAnB,IAAmB,C,CAhDgB,C;;SAmDnC,O,GAAe,IAAA,UAAA,CAAf,IAAe,C,CAnDoB,C;;SAsDnC,Q,GAAgB,IAAA,WAAA,CAAhB,IAAgB,C,CAtDmB,C;;SAyDnC,Q,GAAgB,IAAA,WAAA,CAAhB,IAAgB,C,CAzDmB,C;;SA4DnC,K,GAAaV,QAAAA,CAAAA,WAAAA,GAAuB,IAAA,QAAA,CAAvBA,IAAuB,CAAvBA,GAAb,I,CA5DmC,C;;SA+DnC,kB;;SACA,gB;;;;;;;;;;;;;;;;;;8BAeQ;aACD/I,aAAAA,CAAc,KAArB,OAAOA,C;;;;;;;;;;;;iCAUI;aACJ,KAAP,Q;;;;;;;;;;;;+BAUS;aACF,KAAP,M;;;;;;;;;;;;gCAUU;aACH,KAAP,O;;;;;;;;;;;;;;gCAYU;aACH;cACC,KADD,WAAA;eAEE,KAFF,YAAA;aAGA,KAHA,UAAA;gBAIG,KAAKoR;AAJR,O;;;;;;;;;;;;;;kCAiBK;aACL;cACC,KADD,KAAA;aAEA,KAAKC;AAFL,O;;;;;;;;;;;;+BAaE;aACF,KAAP,S;;;;;;;;;;;;gCAUU;aACH,CAAC,CAAC,KAAF,WAAA,IAAsB,CAAC,KAAA,WAAA,CAA9B,S;;;;;;;;;;;;gCAUU;aACH,CAAC,EAAE,KAAA,WAAA,IAAoB,KAAA,WAAA,CAA9B,UAAQ,C;;;;;;;;;;;;+BAUC;aACF,CAAC,EAAE,KAAA,WAAA,IAAoB,KAAA,WAAA,CAA9B,SAAQ,C;;;;;;;;;;;;oCAUM;aACP,CAAC,EAAE,KAAA,OAAA,IAAgB,KAAA,OAAA,CAA1B,SAAQ,C;;;;;;;;;;;;iCAUG;aACJ,CAAC,EAAE,KAAA,KAAA,IAAc,KAAA,KAAA,CAAxB,SAAQ,C;;;;;;;;;;;;kCAUI;aACL,CAAC,EAAE,KAAA,QAAA,IAAiB,KAAA,QAAA,CAA3B,SAAQ,C;;;;;;;;;;;;kCAUI;aACL,KAAP,Y;;;;;;;;;;;;;;;;yCAcmB;UACf,KAAA,YAAA,IAAqB,KAAA,WAAA,CAAzB,S,EAAqD;UAE/ClN,OAAAA,GAAU,KAAhB,Q;UACMuD,IAAAA,GAAOvD,OAAAA,CAAb,qBAAaA,E,CAJM,C;;WAOnB,M,GAAcuD,IAAAA,CAAd,K;WACA,O,GAAeA,IAAAA,CAAf,M,CARmB,C;;WAWnB,W,GAAmBzB,IAAAA,CAAAA,GAAAA,CAAAA,CAAAA,EAAY0B,eAAAA,CAAAA,OAAAA,EAA/B,aAA+BA,CAAZ1B,C;WACnB,Y,GAAoBA,IAAAA,CAAAA,GAAAA,CAAAA,CAAAA,EAAY0B,eAAAA,CAAAA,OAAAA,EAAhC,cAAgCA,CAAZ1B,C;WACpB,U,GAAkBA,IAAAA,CAAAA,GAAAA,CAAAA,CAAAA,EAAY0B,eAAAA,CAAAA,OAAAA,EAA9B,YAA8BA,CAAZ1B,C;WAClB,a,GAAqBA,IAAAA,CAAAA,GAAAA,CAAAA,CAAAA,EAAY0B,eAAAA,CAAAA,OAAAA,EAAjC,eAAiCA,CAAZ1B,C;;;;;;;;;;;uCASJ;UACb,KAAJ,Y,EAAuB;UAEjB6H,IAAAA,GAAQ,KAAA,SAAA,GAAd,E;;UACMwD,OAAAA,GAAU,KAAA,OAAA,GAAA,SAAA,CAAhB,Q;;UACIjO,IAAAA,GAAAA,KAAJ,C;;WAEA,I,IAAA,O,EAAsB;aACpB,I,IAAaiO,OAAAA,CAAAA,IAAAA,CAAAA,CAAAA,IAAAA,EAAoB,KAAjC,QAAaA,C;;;;;;;;;;;;;6BAWRC,a,EAAe;UAClB,KAAJ,Y,EAAuB;UAEjBpN,OAAAA,GAAU,KAAhB,Q;UACM2E,IAAAA,GAAO,KAAb,OAAa,E;UACPC,QAAAA,GAAWD,IAAAA,CAAjB,S;;UACM3C,KAAAA,GAAQ2C,IAAAA,CAAAA,MAAAA,CAAAA,OAAAA,CAAd,IAAcA,C,CANQ,C;;;WAStB,Q,CAAA,O;;WACA,Q,CAAA,O;;WACA,O,CAAA,O;;WACA,W,CAAA,O;;WACA,Q,CAAA,O;;WACA,a,CAAA,O;;WACA,K,IAAc,KAAA,KAAA,CAAd,OAAc,E,CAfQ,C;;cAkBtB,e,CAAA,O;;WACA,M,CAAA,e,CAAA,O,EAnBsB,C;;;kBAsBtB,O,EAAqBC,QAAAA,CAArB,S,EAtBsB,C;;cAyBd,CAAR,C,IAAcD,IAAAA,CAAAA,MAAAA,CAAAA,MAAAA,CAAAA,KAAAA,EAAd,CAAcA,C,CAzBQ,C;;uBA4BL3E,OAAAA,CAAAA,UAAAA,CAAAA,WAAAA,CAAjB,OAAiBA,C,CA5BK,C;;WA+BtB,S,GAAA,K;WACA,Y,GAAA,I;;;;CApUE+M,E;AC/BN;;;;;;;;;;;;;;;;IAgBMM,MAAAA,GAAAA,UAAAA,UAAAA,EAAAA;;;oBACU;;;;;UAEZ,M,GAAA,E;UACA,U,GAAA,E;UACA,U,GAAA,E;UACA,S,GAAA,E;UACA,S,GAAA,E;UACA,U,GAAA,E;UACA,O,GAAA,C,CARY,C;;UAWZ,O,GAAe;aAAA,IAAA;gBAAA,KAAA;iBAAA,KAAA;aAAA,KAAA;cAKL;AALK,K,CAXH,C;;UAoBZ,iB,GAAyB,KAAA,CAAA,iBAAA,CAAA,IAAA,CAAzB,KAAyB,C;UACzB,iB,GAAyB,KAAA,CAAA,iBAAA,CAAA,IAAA,CAAzB,KAAyB,C;;;;;;;;;;;;;;;;;;;;;8BAiBjBC,K,EAAO/D,K,EAAOC,M,EAAQ+D,K,EAAOjO,O,EAAS;UACxCkO,MAAAA,GAAS,KAAf,O;UACMC,QAAAA,GAAW,CAAC,EAAEnO,OAAAA,IAAWA,OAAAA,CAA/B,QAAkB,C;UACZoO,YAAAA,GAAe,CAAC,EAAEpO,OAAAA,IAAWA,OAAAA,CAAnC,UAAsB,C;UAChBqO,UAAAA,GAAa,CAAC,EAAErO,OAAAA,IAAWA,OAAAA,CAAjC,UAAoB,C;UACdsO,WAAAA,GAAc,CAAC,EAAEtO,OAAAA,IAAWA,OAAAA,CAAlC,WAAqB,C;UACfuO,QAAAA,GAAW,CAAC,EAAEvO,OAAAA,IAAWA,OAAAA,CAA/B,QAAkB,C;UACZwO,SAAAA,GAAY,KAAlB,U;UACIlQ,CAAAA,GAAAA,KAAJ,C,CAR8C,C;;aAW9C,K,GAAe2P,KAAAA,IAAS,KAAxB,M;aACA,K,GAAeG,YAAAA,GAAAA,CAAAA,GAAmBG,QAAAA,GAAW/L,IAAAA,CAAAA,KAAAA,CAAX+L,KAAW/L,CAAX+L,GAAlC,K;aACA,M,GAAgB,CAAA,YAAA,GAAA,CAAA,GAAoBA,QAAAA,GAAW/L,IAAAA,CAAAA,KAAAA,CAAX+L,MAAW/L,CAAX+L,GAApC,M;aACA,Q,GAAA,Y;aACA,S,GAAmB,CAAnB,Y,CAf8C,C;;aAkB9C,K,CAAA,M,GAAA,C;gBACA,M,GAAA,C,CAnB8C,C;;UAsB1C,CAACP,KAAAA,CAAL,M,EAAmB,OAAA,MAAA,CAtB2B,C;;WAyBzC1P,CAAAA,GAAL,C,EAAYA,CAAAA,GAAI0P,KAAAA,CAAhB,M,EAA8B1P,CAA9B,E,EAAmC;aACjC,Q,CAAc0P,KAAAA,CAAd,CAAcA,C,EAAd,Y,EAAA,Q,EAAA,Q,EAA0DK,UAAAA,IAA1D,W;OA1B4C,C;;;UA8B9C,U,EAAgB;aACT/P,CAAAA,GAAL,C,EAAYA,CAAAA,GAAI4P,MAAAA,CAAAA,KAAAA,CAAhB,M,EAAqC5P,CAAAA,GAAIA,CAAAA,GAAzC,C,EAAgD;iBAC9C,K,CAAA,C,IAAkB4P,MAAAA,CAAAA,KAAAA,IAAgBA,MAAAA,CAAAA,KAAAA,CAAAA,CAAAA,IAAkBM,SAAAA,CAApD,CAAoDA,CAAlCN,C;;OAhCwB,C;;;UAqC9C,W,EAAiB;aACV5P,CAAAA,GAAL,C,EAAYA,CAAAA,GAAI4P,MAAAA,CAAAA,KAAAA,CAAhB,M,EAAqC5P,CAAAA,GAAIA,CAAAA,GAAzC,C,EAAgD;iBAC9C,K,CAAA,C,IAAkB4P,MAAAA,CAAAA,MAAAA,IAAiBA,MAAAA,CAAAA,KAAAA,CAAAA,CAAAA,IAAkBM,SAAAA,CAArD,CAAqDA,CAAnCN,C;;OAvCwB,C;;;gBA4C9C,M,GAAA,C;WACA,U,CAAA,M,GAAA,C;WACA,S,CAAA,M,GAAA,C;WACA,O,GAAA,C;aAEA,M;;;;;;;;;;;;;;;;;6BAeOpD,I,EAAM2D,G,EAAKxE,K,EAAOC,M,EAAQ;UAC3BwE,MAAAA,GAAS,EAAE,KAAjB,O;UACMC,SAAAA,GAAY,KAAlB,U;gBAEA,M,IAAoB7D,IAAAA,IAApB,C;gBACU,EAAE,KAAZ,O,IAA4B2D,GAAAA,IAA5B,C;gBACU,EAAE,KAAZ,O,IAA4BxE,KAAAA,IAA5B,C;gBACU,EAAE,KAAZ,O,IAA4BC,MAAAA,IAA5B,C;aAEA,M;;;;;;;;;;;;;;;;6BAcOjJ,E,EAAI6H,M,EAAQ;UACb8F,QAAAA,GAAW9F,MAAAA,IAAU,KAA3B,S;UACM6F,SAAAA,GAAY,KAAlB,U;eAEA,I,GAAgBA,SAAAA,CAAAA,EAAAA,CAAAA,IAAhB,C;eACA,G,GAAeA,SAAAA,CAAU,EAAVA,EAAAA,CAAAA,IAAf,C;eACA,K,GAAiBA,SAAAA,CAAU,EAAVA,EAAAA,CAAAA,IAAjB,C;eACA,M,GAAkBA,SAAAA,CAAU,EAAVA,EAAAA,CAAAA,IAAlB,C;aAEA,Q;;;;;;;;;;;;;;oCAYc5E,C,EAAGC,C,EAAG;aACb,EACLD,CAAAA,CAAAA,IAAAA,GAASA,CAAAA,CAATA,KAAAA,IAAoBC,CAAAA,CAApBD,IAAAA,IACAC,CAAAA,CAAAA,IAAAA,GAASA,CAAAA,CAATA,KAAAA,IAAoBD,CAAAA,CADpBA,IAAAA,IAEAA,CAAAA,CAAAA,GAAAA,GAAQA,CAAAA,CAARA,MAAAA,IAAoBC,CAAAA,CAFpBD,GAAAA,IAGAC,CAAAA,CAAAA,GAAAA,GAAQA,CAAAA,CAARA,MAAAA,IAAoBD,CAAAA,CAJtB,GAAO,C;;;;;;;;;;;;;;sCAiBSA,C,EAAGC,C,EAAG;aAEpBD,CAAAA,CAAAA,IAAAA,IAAUC,CAAAA,CAAVD,IAAAA,IACAA,CAAAA,CAAAA,GAAAA,IAASC,CAAAA,CADTD,GAAAA,IAEAA,CAAAA,CAAAA,IAAAA,GAASA,CAAAA,CAATA,KAAAA,IAAoBC,CAAAA,CAAAA,IAAAA,GAASA,CAAAA,CAF7BD,KAAAA,IAGAA,CAAAA,CAAAA,GAAAA,GAAQA,CAAAA,CAARA,MAAAA,IAAoBC,CAAAA,CAAAA,GAAAA,GAAQA,CAAAA,CAJ9B,M;;;;CAtKE+D,CAAe9P,SAAf8P,C;;;;;;;;;;;;;;;AA2LNA,MAAAA,CAAAA,SAAAA,CAAAA,QAAAA,GAA8B,YAAM;MAC5Bc,MAAAA,GAAN,K;MACMC,QAAAA,GAAN,E;SACO,UAAA,IAAA,EAAA,YAAA,EAAA,QAAA,EAAA,QAAA,EAAA,SAAA,EAA4D;QAC3DZ,MAAAA,GAAS,KAAf,O;QACMa,SAAAA,GAAY,KAAlB,U;QACMC,QAAAA,GAAW,KAAjB,S;QACI/K,IAAAA,GAAAA,KAAJ,C;QACIyK,MAAAA,GAAAA,KAAJ,C;QACIO,cAAAA,GAAAA,KAAJ,C;QACIC,kBAAAA,GAAAA,KAAJ,C;QACI5Q,CAAAA,GAAAA,KAAJ,C;QACI6Q,EAAAA,GAAAA,KAAJ,C,CATiE,C;;aAYjE,M,GAAA,C,CAZiE,C;;aAejE,I,GAAA,I;aACA,G,GAAA,I;aACA,K,GAAiB/J,IAAAA,CAAAA,MAAAA,GAAcA,IAAAA,CAAdA,WAAAA,GAAiCA,IAAAA,CAAlD,Y;aACA,M,GAAkBA,IAAAA,CAAAA,OAAAA,GAAeA,IAAAA,CAAfA,UAAAA,GAAiCA,IAAAA,CAAnD,a,CAlBiE,C;;QAqBjE,Q,EAAc;eACZ,K,GAAiB5C,IAAAA,CAAAA,KAAAA,CAAWsM,QAAAA,CAA5B,KAAiBtM,C;eACjB,M,GAAkBA,IAAAA,CAAAA,KAAAA,CAAWsM,QAAAA,CAA7B,MAAkBtM,C;KAvB6C,C;;;SA2B5DlE,CAAAA,GAAL,C,EAAYA,CAAAA,GAAIyQ,SAAAA,CAAhB,M,EAAkCzQ,CAAlC,E,EAAuC;eAC5ByQ,SAAAA,CAAT,CAASA,C;UACL,CAAJ,M,EAAa;aACN,KAAA,QAAA,CAAP,MAAO,C;;UACHD,QAAAA,CAAAA,KAAAA,IAAkB7K,IAAAA,CAAAA,KAAAA,GAAlB6K,MAAAA,IAAyCA,QAAAA,CAAAA,MAAAA,IAAmB7K,IAAAA,CAAAA,MAAAA,GAAhE,M,EAAsF;iBACpF,I,GAAgBA,IAAAA,CAAhB,I;iBACA,G,GAAeA,IAAAA,CAAf,G;;;KAjC6D,C;;;QAuC7D6K,QAAAA,CAAAA,IAAAA,KAAJ,I,EAA4B;;;eAG1B,I,GAAgB,CAAA,YAAA,GAAA,CAAA,GAAoBZ,MAAAA,CAApC,K;eACA,G,GAAe,CAAA,YAAA,GAAgBA,MAAAA,CAAhB,MAAA,GAAf,C,CAJ0B,C;;;UAQtB,CAAJ,Q,EAAe;6BACb,I;;KAhD6D,C;;;QAqD7D,CAAA,YAAA,IAAiBY,QAAAA,CAAAA,GAAAA,GAAeA,QAAAA,CAAfA,MAAAA,GAAiCZ,MAAAA,CAAtD,M,EAAqE;;UAE/DY,QAAAA,CAAAA,IAAAA,GAAJ,C,EAAuB;iBACrB,I,CAAc,KAAA,QAAA,CAAA,CAAA,EAAiBZ,MAAAA,CAAjB,MAAA,EAAgCY,QAAAA,CAAhC,IAAA,EAAd,QAAc,C;OAHmD,C;;;UAO/DA,QAAAA,CAAAA,IAAAA,GAAgBA,QAAAA,CAAhBA,KAAAA,GAAiCZ,MAAAA,CAArC,K,EAAmD;iBACjD,I,CACE,KAAA,QAAA,CACEY,QAAAA,CAAAA,IAAAA,GAAgBA,QAAAA,CADlB,KAAA,EAEEZ,MAAAA,CAFF,MAAA,EAGEA,MAAAA,CAAAA,KAAAA,GAAeY,QAAAA,CAAfZ,IAAAA,GAA+BY,QAAAA,CAHjC,KAAA,EADF,QACE,C;OAT+D,C;;;aAmBnE,M,GAAgBA,QAAAA,CAAAA,GAAAA,GAAeA,QAAAA,CAA/B,M;KAxE+D,C;;;QA4E7DV,YAAAA,IAAgBU,QAAAA,CAAAA,IAAAA,GAAgBA,QAAAA,CAAhBA,KAAAA,GAAiCZ,MAAAA,CAArD,K,EAAmE;;UAE7DY,QAAAA,CAAAA,GAAAA,GAAJ,C,EAAsB;iBACpB,I,CAAc,KAAA,QAAA,CAAcZ,MAAAA,CAAd,KAAA,EAAA,CAAA,EAAA,QAAA,EAAyCY,QAAAA,CAAvD,GAAc,C;OAHiD,C;;;UAO7DA,QAAAA,CAAAA,GAAAA,GAAeA,QAAAA,CAAfA,MAAAA,GAAiCZ,MAAAA,CAArC,M,EAAoD;iBAClD,I,CACE,KAAA,QAAA,CACEA,MAAAA,CADF,KAAA,EAEEY,QAAAA,CAAAA,GAAAA,GAAeA,QAAAA,CAFjB,MAAA,EAAA,QAAA,EAIEZ,MAAAA,CAAAA,MAAAA,GAAgBY,QAAAA,CAAhBZ,GAAAA,GAA+BY,QAAAA,CALnC,MACE,C;OAT6D,C;;;aAmBjE,K,GAAeA,QAAAA,CAAAA,IAAAA,GAAgBA,QAAAA,CAA/B,K;KA/F+D,C;;;;;SAqG5DxQ,CAAAA,GAAI6P,QAAAA,GAAAA,CAAAA,GAAee,kBAAAA,GAAqBH,SAAAA,CAArBG,MAAAA,GAAxB,C,EAAmE5Q,CAAAA,GAAIyQ,SAAAA,CAAvE,M,EAAyFzQ,CAAzF,E,EAA8F;eACnFyQ,SAAAA,CAAT,CAASA,C;UACL,CAAJ,M,EAAa;aACN,KAAA,QAAA,CAAP,MAAO,C;uBACU,KAAA,UAAA,CAAA,IAAA,EAAjB,QAAiB,C;;WACZI,EAAAA,GAAL,C,EAAaA,EAAAA,GAAKF,cAAAA,CAAlB,M,EAAyCE,EAAzC,E,EAA+C;iBACpCF,cAAAA,CAAT,EAASA,C;eACF,KAAA,QAAA,CAAP,MAAO,C,CAFsC,C;;;;YAO3ChL,IAAAA,CAAAA,KAAAA,GAAAA,IAAAA,IACAA,IAAAA,CAAAA,MAAAA,GADAA,IAAAA,KAEE,CAAA,YAAA,IAAiBA,IAAAA,CAAAA,GAAAA,GAAWiK,MAAAA,CAA7B,MAAC,IACCE,YAAAA,IAAgBnK,IAAAA,CAAAA,IAAAA,GAAYiK,MAAAA,CAJjC,KACEjK,C,EAIA;mBACA,I,CAAA,M;;;KAtH2D,C;;;QA4H7D+K,QAAAA,CAAJ,M,EAAqB;WACnB,W,CAAA,Q,EAAA,I,CACEZ,YAAAA,GAAe,KAAfA,iBAAAA,GAAwC,KAD1C,iB;KA7H+D,C;;;QAmIjE,Y,EAAkB;aAChB,K,GAAe5L,IAAAA,CAAAA,GAAAA,CAAS0L,MAAAA,CAAT1L,KAAAA,EAAuBsM,QAAAA,CAAAA,IAAAA,GAAgBA,QAAAA,CAAtD,KAAetM,C;AADjB,K,MAEO;aACL,M,GAAgBA,IAAAA,CAAAA,GAAAA,CAAS0L,MAAAA,CAAT1L,MAAAA,EAAwBsM,QAAAA,CAAAA,GAAAA,GAAeA,QAAAA,CAAvD,MAAgBtM,C;KAtI+C,C;;;;WA2IjE,K,CAAA,I,CAAkBsM,QAAAA,CAAlB,I,EAAiCA,QAAAA,CAAjC,G;QACA,S,EAAe,KAAA,UAAA,CAAA,IAAA,CAAqBA,QAAAA,CAArB,KAAA,EAAqCA,QAAAA,CAArC,MAAA,EA5IkD,C;;SA+IjE,U,GAAA,Q;SACA,S,GAAA,S;AAhJF,G;AAHFf,CAA8B,EAA9BA;;;;;;;;;;;;;AAiKAA,MAAAA,CAAAA,SAAAA,CAAAA,UAAAA,GAAgC,YAAM;MAC9BqB,OAAAA,GAAN,E;SACO,UAAA,IAAA,EAAA,IAAA,EAAqB;;YAE1B,M,GAAA,C,CAF0B,C;;;QAMtB,CAAC,KAAA,eAAA,CAAA,IAAA,EAAL,IAAK,C,EAAkC;cACrC,I,CAAa,KAAA,QAAA,CAAcnL,IAAAA,CAAd,IAAA,EAAyBA,IAAAA,CAAzB,GAAA,EAAmCA,IAAAA,CAAnC,KAAA,EAA+CA,IAAAA,CAA5D,MAAa,C;aACb,O;KARwB,C;;;QAYtBA,IAAAA,CAAAA,IAAAA,GAAYoL,IAAAA,CAAhB,I,EAA2B;cACzB,I,CAAa,KAAA,QAAA,CAAcpL,IAAAA,CAAd,IAAA,EAAyBA,IAAAA,CAAzB,GAAA,EAAmCoL,IAAAA,CAAAA,IAAAA,GAAYpL,IAAAA,CAA/C,IAAA,EAA0DA,IAAAA,CAAvE,MAAa,C;KAbW,C;;;QAiBtBA,IAAAA,CAAAA,IAAAA,GAAYA,IAAAA,CAAZA,KAAAA,GAAyBoL,IAAAA,CAAAA,IAAAA,GAAYA,IAAAA,CAAzC,K,EAAqD;cACnD,I,CACE,KAAA,QAAA,CACEA,IAAAA,CAAAA,IAAAA,GAAYA,IAAAA,CADd,KAAA,EAEEpL,IAAAA,CAFF,GAAA,EAGEA,IAAAA,CAAAA,IAAAA,GAAYA,IAAAA,CAAZA,KAAAA,IAA0BoL,IAAAA,CAAAA,IAAAA,GAAYA,IAAAA,CAHxC,KAGEpL,CAHF,EAIEA,IAAAA,CALJ,MACE,C;KAnBsB,C;;;QA6BtBA,IAAAA,CAAAA,GAAAA,GAAWoL,IAAAA,CAAf,G,EAAyB;cACvB,I,CAAa,KAAA,QAAA,CAAcpL,IAAAA,CAAd,IAAA,EAAyBA,IAAAA,CAAzB,GAAA,EAAmCA,IAAAA,CAAnC,KAAA,EAA+CoL,IAAAA,CAAAA,GAAAA,GAAWpL,IAAAA,CAAvE,GAAa,C;KA9BW,C;;;QAkCtBA,IAAAA,CAAAA,GAAAA,GAAWA,IAAAA,CAAXA,MAAAA,GAAyBoL,IAAAA,CAAAA,GAAAA,GAAWA,IAAAA,CAAxC,M,EAAqD;cACnD,I,CACE,KAAA,QAAA,CACEpL,IAAAA,CADF,IAAA,EAEEoL,IAAAA,CAAAA,GAAAA,GAAWA,IAAAA,CAFb,MAAA,EAGEpL,IAAAA,CAHF,KAAA,EAIEA,IAAAA,CAAAA,GAAAA,GAAWA,IAAAA,CAAXA,MAAAA,IAA0BoL,IAAAA,CAAAA,GAAAA,GAAWA,IAAAA,CALzC,MAKIpL,CAJF,C;;;WASJ,O;AA7CF,G;AAFF8J,CAAgC,EAAhCA;;;;;;;;;;;;;AA6DAA,MAAAA,CAAAA,SAAAA,CAAAA,WAAAA,GAAiC,YAAM;MAC/BuB,KAAAA,GAAN,E;MACMC,KAAAA,GAAN,E;SACO,UAAA,OAAA,EAAkB;QACnBjR,CAAAA,GAAIkR,OAAAA,CAAR,M;QACIL,EAAAA,GAAAA,KAAJ,C;;WAEO7Q,CAAP,E,EAAY;WACLkR,OAAAA,CAAL,M;UACI,CAACA,OAAAA,CAAL,CAAKA,C,EAAY;;WACjB,Q,CAAcA,OAAAA,CAAd,CAAcA,C,EAAd,K;;aACOL,EAAP,E,EAAa;YACP,CAACK,OAAAA,CAAD,EAACA,CAAD,IAAgBlR,CAAAA,KAApB,E,EAA8B;;YAC1B,KAAA,iBAAA,CAAA,KAAA,EAA8B,KAAA,QAAA,CAAckR,OAAAA,CAAd,EAAcA,CAAd,EAAlC,KAAkC,CAA9B,C,EAAkE;kBACpE,C,IAAA,C;;;;;;WAMN,O;AAjBF,G;AAHFzB,CAAiC,EAAjCA;;;;;;;;;;;;AAiCAA,MAAAA,CAAAA,SAAAA,CAAAA,iBAAAA,GAAuC,YAAM;MACrCuB,KAAAA,GAAN,E;MACMC,KAAAA,GAAN,E;SACO,UAAA,GAAA,EAAA,GAAA,EAAmB;SACxB,Q,CAAA,G,EAAA,K;;SACA,Q,CAAA,G,EAAA,K,EAFwB,C;;;WAIjBD,KAAAA,CAAAA,GAAAA,GAAYC,KAAAA,CAAZD,GAAAA,GAAwB,CAAxBA,CAAAA,GAAAA;UACA,G,GAAYC,KAAAA,CAAZ,G,GAAA,C,GAAA;UACA,I,GAAaA,KAAAA,CAAb,I,GAA0B,CAA1B,C,GAAA;UACA,I,GAAaA,KAAAA,CAAb,I,GAAA,C,GAPiB,C,CAAA,CAAA;AAA1B,G;AAHFxB,CAAuC,EAAvCA;;;;;;;;;;;;AAuBAA,MAAAA,CAAAA,SAAAA,CAAAA,iBAAAA,GAAuC,YAAM;MACrCuB,KAAAA,GAAN,E;MACMC,KAAAA,GAAN,E;SACO,UAAA,GAAA,EAAA,GAAA,EAAmB;SACxB,Q,CAAA,G,EAAA,K;;SACA,Q,CAAA,G,EAAA,K,EAFwB,C;;;WAIjBD,KAAAA,CAAAA,IAAAA,GAAaC,KAAAA,CAAbD,IAAAA,GAA0B,CAA1BA,CAAAA,GAAAA;UACA,I,GAAaC,KAAAA,CAAb,I,GAAA,C,GAAA;UACA,G,GAAYA,KAAAA,CAAZ,G,GAAwB,CAAxB,C,GAAA;UACA,G,GAAYA,KAAAA,CAAZ,G,GAAA,C,GAPiB,C,CAAA,CAAA;AAA1B,G;AAHFxB,CAAuC,EAAvCA;ACjeA;;;;;;;AAMA,IAAM0B,kBAAAA,GAAN,yBAAA;AACA,IAAMC,YAAAA,GAAN,mBAAA;;;;;;;;AAQe,SAAA,UAAA,CAAA,GAAA,EAAyB;MAChCC,IAAAA,GAAOhL,MAAAA,CAAAA,SAAAA,CAAAA,QAAAA,CAAAA,IAAAA,CAAb,GAAaA,C;SACNgL,IAAAA,KAAAA,kBAAAA,IAA+BA,IAAAA,KAAtC,Y;;ACjBF;;;;;;;;;;;;;;AAce,SAAA,SAAA,CAAA,MAAA,EAAyB;SAC/BC,UAAAA,CAAAA,MAAAA,CAAAA,GAAqBxG,KAAAA,CAAAA,SAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAArBwG,MAAqBxG,CAArBwG,GAA0DxG,KAAAA,CAAAA,SAAAA,CAAAA,MAAAA,CAAjE,MAAiEA,C;;ACfnE;;;;;;;AAiDA,IAAMyG,MAAAA,GAAS,IAAf,MAAe,EAAf;;AACA,SAAA,IAAA,GAAiB,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAiDXC,IAAAA,GAAAA,UAAAA,UAAAA,EAAAA;;;gBACJ,O,EAAA,O,EAA8B;;;2GAAA,O,EAAA,O;;QAEtBC,IAAAA,GAAN,K;QACIzK,QAAAA,GAAAA,KAAJ,C;QACI0I,KAAAA,GAAAA,KAAJ,C;QACIgC,cAAAA,GAAAA,KAAJ,C,CAL4B,C;;cAQlB,KAAA,CAAA,QAAA,GAAgB,OAAA,OAAA,KAAA,QAAA,GAA8B1Q,QAAAA,CAAAA,aAAAA,CAA9B,OAA8BA,CAA9B,GAA1B,O,CAR4B,C;;;QAYxB,CAACA,QAAAA,CAAAA,IAAAA,CAAAA,QAAAA,CAAL,OAAKA,C,EAAiC;YAC9B,IAAA,KAAA,CAAN,mDAAM,C;KAboB,C;;;eAiBjB,KAAA,CAAA,SAAA,GAAiB2Q,aAAAA,CAAcH,IAAAA,CAAdG,cAAAA,EAA5B,OAA4BA,C,CAjBA,C;;QAoBxB,OAAO3K,QAAAA,CAAP,QAAA,KAAJ,U,EAA6C;eAC3C,Q,GAAoB,CAAC,CAACA,QAAAA,CAAtB,Q;KArB0B,C;;;UAyB5B,G,GAAWoI,SAAX,E;kBACc,KAAA,CAAd,G,IAAA,I,CA1B4B,C;;UA6B5B,Y,GAAA,K,CA7B4B,C;;UAgC5B,O,GAAe;UAAA,CAAA;aAAA,EAAA;aAAA,EAAA;gBAAA,KAAA;iBAAA,KAAA;aAAA,CAAA;cAOL;AAPK,K,CAhCa,C;;UA2C5B,Q,GAAgB,IAAhB,OAAgB,E,CA3CY,C;;aA8C5B,O,EAAkBpI,QAAAA,CAAlB,c,EA9C4B,C;;UAiD5B,M,GAAA,E;YACQA,QAAAA,CAAR,K;;QACI,OAAA,KAAA,KAAJ,Q,EAA+B;gBACrB5E,OAAAA,CAAR,Q,EAAA,O,CAAkC,UAAA,WAAA,EAAe;YAC3CsN,KAAAA,KAAAA,GAAAA,IAAiB3L,cAAAA,CAAAA,WAAAA,EAArB,KAAqBA,C,EAAoC;eACvD,M,CAAA,I,CAAiB,IAAA,IAAA,CAAA,IAAA,EAAjB,WAAiB,C;;AAFrB,O;AADF,K,MAMO,IAAI+G,KAAAA,CAAAA,OAAAA,CAAAA,KAAAA,KAAwBwG,UAAAA,CAA5B,KAA4BA,CAA5B,EAA+C;YACpD,M,GAAc,SAAA,CAAA,KAAA,CAAA,CAAA,GAAA,CAAmB,UAAA,WAAA,EAAA;eAAe,IAAA,IAAA,CAAA,IAAA,EAAf,WAAe,C;AAAhD,OAAc,C;KA1DY,C;;;;qBA+DXtK,QAAAA,CAAjB,c;;QACI,OAAA,cAAA,KAAJ,Q,EAAwC;uBACrB0K,cAAAA,KAAAA,IAAAA,GAAAA,CAAAA,GAA8B,CAA/C,C;;;QAEEA,cAAAA,IAAJ,C,EAAyB;aACvB,gB,CAAA,Q,EAEGD,IAAAA,CAAAA,cAAAA,GAAsB,QAAA,CAAS,YAAM;aACpC,Y,GAAA,M;AADqB,OAAA,EAFzB,cAEyB,C;KAtEC,C;;;QA6ExBzK,QAAAA,CAAJ,Y,EAA2B;YACzB,M,CAAA,I;;;;;;;;;;;;;;;;;;;;;;;uBAkBDpH,K,EAAOC,Q,EAAU;WAClB,Q,CAAA,E,CAAA,K,EAAA,Q;;aACA,I;;;;;;;;;;;;;;yBAYGD,K,EAAOC,Q,EAAU;WACpB,Q,CAAA,I,CAAA,K,EAAA,Q;;aACA,I;;;;;;;;;;;;;;wBAYED,K,EAAOC,Q,EAAU;WACnB,Q,CAAA,G,CAAA,K,EAAA,Q;;aACA,I;;;;;;;;;;;;iCAUW;aACJ,KAAP,Q;;;;;;;;;;;;;;;;6BAcO+R,O,EAAS;;;UAGZ,KAAA,YAAA,IAAsB,CAAA,OAAA,IAAYA,OAAAA,KAAtC,C,EAAsD;eAC7C,KAAA,MAAA,CAAA,KAAA,CAAP,CAAO,C;;;UAGHzM,GAAAA,GAAN,E;UACM8I,WAAAA,GAAc4D,SAAAA,CAApB,OAAoBA,C;UAChB/K,IAAAA,GAAAA,KAAJ,C;UACI9G,CAAAA,GAAAA,KAAJ,C,CAVgB,C;;WAaXA,CAAAA,GAAL,C,EAAYA,CAAAA,GAAIiO,WAAAA,CAAhB,M,EAAoCjO,CAApC,E,EAAyC;eAChC,KAAA,QAAA,CAAciO,WAAAA,CAArB,CAAqBA,CAAd,C;gBACC9I,GAAAA,CAAAA,IAAAA,CAAR,IAAQA,C;;;aAGV,G;;;;;;;;;;;;;iCAWWuK,K,EAAO;UACd,KAAJ,Y,EAAuB,OAAA,IAAA;UAEjBkC,OAAAA,GAAU,KAAA,QAAA,CAAhB,KAAgB,C;UACZ5R,CAAAA,GAAAA,KAAJ,C;;WAEKA,CAAAA,GAAL,C,EAAYA,CAAAA,GAAI4R,OAAAA,CAAhB,M,EAAgC5R,CAAhC,E,EAAqC;gBACnC,C,EAAA,kB;;;aAGF,I;;;;;;;;;;;;;oCAWc0P,K,EAAO;UACjB,KAAJ,Y,EAAuB,OAAA,IAAA;UAEjBzB,WAAAA,GAAc,KAAA,QAAA,CAApB,KAAoB,C;UAChBjO,CAAAA,GAAAA,KAAJ,C;;WAEKA,CAAAA,GAAL,C,EAAYA,CAAAA,GAAIiO,WAAAA,CAAhB,M,EAAoCjO,CAApC,E,EAAyC;oBACvC,C,EAAA,gB;;;aAGF,I;;;;;;;;;;;;;;;;kCAcY;UACR,KAAJ,Y,EAAuB,OAAA,IAAA;UAEjB8N,SAAAA,GAAY,KAAlB,Q;UACM4B,KAAAA,GAAQ,KAAd,M;UACIoC,QAAAA,GAAAA,KAAJ,C;UACI1P,OAAAA,GAAAA,KAAJ,C;UACIpC,CAAAA,GAAAA,KAAJ,C,CAPY,C;;UAUR0P,KAAAA,CAAJ,M,EAAkB;aACX1P,CAAAA,GAAL,C,EAAYA,CAAAA,GAAI0P,KAAAA,CAAhB,M,EAA8B1P,CAA9B,E,EAAmC;oBACvB0P,KAAAA,CAAAA,CAAAA,CAAAA,CAAV,Q;;cACItN,OAAAA,CAAAA,UAAAA,KAAJ,S,EAAsC;uBACzB0P,QAAAA,IAAY9Q,QAAAA,CAAvB,sBAAuBA,E;qBACvB,W,CAAA,O;;;;YAIJ,Q,EAAc8M,SAAAA,CAAAA,WAAAA,CAAAA,QAAAA;OAnBJ,C;;;WAuBZ,K,CAAA,gB;;aAEA,I;;;;;;;;;;;;;;2BAYKjB,O,EAASC,Q,EAAU;UACpB,KAAJ,Y,EAAuB,OAAA,IAAA;UAEjB2E,IAAAA,GAAN,I;UACMrP,OAAAA,GAAU,KAAhB,Q;;UACMwN,MAAAA,GAAS,KAAf,aAAe,E;;UACTmC,QAAAA,GAAWnC,MAAAA,CAAjB,E;UACMoC,WAAAA,GAAcpC,MAAAA,CAAAA,KAAAA,CAApB,M;UACIqC,OAAAA,GAAJ,W;UACMlS,QAAAA,GAAW,OAAA,OAAA,KAAA,UAAA,GAAA,OAAA,GAAjB,Q;UACMmS,kBAAAA,GAAqB,OAAA,QAAA,KAA3B,U;UACMC,aAAAA,GAAgBD,kBAAAA,GAAqBtC,MAAAA,CAAAA,KAAAA,CAAAA,KAAAA,CAArBsC,CAAqBtC,CAArBsC,GAAtB,I;UACIE,WAAAA,GAAAA,KAAJ,C;UACItL,IAAAA,GAAAA,KAAJ,C;UACI9G,CAAAA,GAAAA,KAAJ,C,CAdwB,C;;;;;eAoBxB,S,GAAqB;YACf,EAAA,OAAA,GAAJ,C,EAAmB;YACbqS,gBAAAA,GAAmBZ,IAAAA,CAAAA,OAAAA,CAAAA,EAAAA,KAAzB,Q;8BACsB1R,QAAAA,CAAAA,gBAAAA,EAAtB,aAAsBA,C;;YAClB,CAAA,gBAAA,IAAqB0R,IAAAA,CAAAA,aAAAA,CAAzB,cAAyBA,C,EAAoC;eAC3D,K,CAAA,c,EAA2B7B,MAAAA,CAAAA,KAAAA,CAAAA,KAAAA,CAA3B,CAA2BA,C;;OAzBP,C;;;;;;;UAmCrBA,MAAAA,CAAAA,SAAAA,IAAoB,OAAOA,MAAAA,CAAP,MAAA,KAArB,QAACA,IACAA,MAAAA,CAAAA,QAAAA,IAAmB,OAAOA,MAAAA,CAAP,KAAA,KAFtB,Q,EAGE;sBACctN,QAAAA,CAAAA,OAAAA,EAAAA,YAAAA,CAAAA,KAAd,Y;;;UAEEsN,MAAAA,CAAJ,S,EAAsB;YAChB,OAAOA,MAAAA,CAAP,MAAA,KAAJ,Q,EAAuC;kBACrC,K,CAAA,M,GAAA,CACKwC,WAAAA,GAAcxC,MAAAA,CAAAA,MAAAA,GAAgB,KAAhBA,UAAAA,GAAkC,KAAhDwC,aAAAA,GAAqExC,MAAAA,CAD1E,MAAA,IAAA,I;AADF,S,MAGO;kBACL,K,CAAA,M,GAAuBA,MAAAA,CAAvB,M;;;;UAGAA,MAAAA,CAAJ,Q,EAAqB;YACf,OAAOA,MAAAA,CAAP,KAAA,KAAJ,Q,EAAsC;kBACpC,K,CAAA,K,GAAA,CACKwC,WAAAA,GAAcxC,MAAAA,CAAAA,KAAAA,GAAe,KAAfA,WAAAA,GAAkC,KAAhDwC,YAAAA,GAAoExC,MAAAA,CADzE,KAAA,IAAA,I;AADF,S,MAGO;kBACL,K,CAAA,K,GAAsBA,MAAAA,CAAtB,K;;OArDoB,C;;;;;UA4DpB,KAAA,aAAA,CAAJ,gBAAI,C,EAAsC;aACxC,K,CAAA,gB,EAA6BA,MAAAA,CAAAA,KAAAA,CAAAA,KAAAA,CAA7B,CAA6BA,C;OA7DP,C;;;UAiEpB,CAAJ,W,EAAkB;;eAEhB,I;OAnEsB,C;;;WAuEnB5P,CAAAA,GAAL,C,EAAYA,CAAAA,GAAZ,W,EAA6BA,CAA7B,E,EAAkC;eACzB4P,MAAAA,CAAAA,KAAAA,CAAP,CAAOA,C;YACH,CAAJ,I,EAAW,SAFqB,C;;aAKhC,K,GAAaA,MAAAA,CAAAA,KAAAA,CAAa5P,CAAAA,GAA1B,CAAa4P,C;aACb,I,GAAYA,MAAAA,CAAAA,KAAAA,CAAa5P,CAAAA,GAAAA,CAAAA,GAAzB,CAAY4P,C,CANoB,C;;aAShC,U,KAAoB0C,SAApB,E,GAAkCxL,IAAAA,CAAAA,OAAAA,CAAAA,KAAAA,CAAmB+F,OAAAA,KAAnB/F,IAAAA,EAAlC,SAAkCA,C;;;aAGpC,I;;;;;;;;;;;;;;;;;;;;;;;;;;;wBAyBEyL,Q,EAAU7Q,O,EAAS;UACjB,KAAA,YAAA,IAAqB,CAAzB,Q,EAAoC,OAAA,EAAA;UAE9B8Q,QAAAA,GAAWX,SAAAA,CAAjB,QAAiBA,C;UACb,CAACW,QAAAA,CAAL,M,EAAsB,OAAA,QAAA;UAEhB1Q,IAAAA,GAAOJ,OAAAA,IAAb,C;UACMkO,MAAAA,GAAS9N,IAAAA,CAAAA,MAAAA,GAAcA,IAAAA,CAAdA,MAAAA,GAA4BA,IAAAA,CAAAA,MAAAA,KAA3C,S;UACM4N,KAAAA,GAAQ,KAAd,M;UACI+C,WAAAA,GAAJ,K;UACI3L,IAAAA,GAAAA,KAAJ,C;UACI9G,CAAAA,GAAAA,KAAJ,C,CAXqB,C;;WAchBA,CAAAA,GAAL,C,EAAYA,CAAAA,GAAIwS,QAAAA,CAAhB,M,EAAiCxS,CAAjC,E,EAAsC;eAC7B,IAAA,IAAA,CAAA,IAAA,EAAewS,QAAAA,CAAf,CAAeA,CAAf,EAA4B1Q,IAAAA,CAAnC,QAAO,C;iBACP,C,IAAA,I,CAFoC,C;;;;;;YAShCgF,IAAAA,CAAJ,S,EAAoB;wBAClB,I;eACA,O,CAAA,kB,GAAA,I;;OAzBiB,C;;;kBA8BrB,K,EAAA,Q,EAA6BhF,IAAAA,CAA7B,K,EA9BqB,C;;UAiCjB,KAAA,aAAA,CAAJ,QAAI,C,EAA8B;aAChC,K,CAAA,Q,EAAqB0Q,QAAAA,CAAAA,KAAAA,CAArB,CAAqBA,C;OAlCF,C;;;UAsCjBC,WAAAA,IAAJ,M,EAA2B;aACzB,M,CAAY7C,MAAAA,KAAZ,S,EAAkC,OAAA,MAAA,KAAA,UAAA,GAAA,MAAA,GAAlC,S;;;aAGF,Q;;;;;;;;;;;;;;;;2BAcKF,K,EAAOhO,O,EAAS;UACjB,KAAJ,Y,EAAuB,OAAA,IAAA;UAEjBI,IAAAA,GAAOJ,OAAAA,IAAb,C;UACMkO,MAAAA,GAAS9N,IAAAA,CAAAA,MAAAA,GAAcA,IAAAA,CAAdA,MAAAA,GAA4BA,IAAAA,CAAAA,MAAAA,KAA3C,S;UACI2Q,WAAAA,GAAJ,K;UACMC,QAAAA,GAAW,KAAjB,QAAiB,E;UACXzE,WAAAA,GAAc,KAAA,QAAA,CAApB,KAAoB,C;UACd0E,OAAAA,GAAN,E;UACI7L,IAAAA,GAAAA,KAAJ,C;UACI9G,CAAAA,GAAAA,KAAJ,C,CAVqB,C;;WAahBA,CAAAA,GAAL,C,EAAYA,CAAAA,GAAIiO,WAAAA,CAAhB,M,EAAoCjO,CAApC,E,EAAyC;eAChCiO,WAAAA,CAAP,CAAOA,C;gBACP,I,CAAayE,QAAAA,CAAAA,OAAAA,CAAb,IAAaA,C;YACT5L,IAAAA,CAAJ,S,EAAoB2L,WAAAA,GAAAA,IAAAA;;aACpB,Q,CAAc3Q,IAAAA,CAAd,c;OAjBmB,C;;;UAqBjB,KAAA,aAAA,CAAJ,WAAI,C,EAAiC;aACnC,K,CAAA,W,EAAwBmM,WAAAA,CAAAA,KAAAA,CAAxB,CAAwBA,C,EAAxB,O;OAtBmB,C;;;UA0BjBwE,WAAAA,IAAJ,M,EAA2B;aACzB,M,CAAY7C,MAAAA,KAAZ,S,EAAkC,OAAA,MAAA,KAAA,UAAA,GAAA,MAAA,GAAlC,S;;;aAGF,W;;;;;;;;;;;;;;;;;yBAeGF,K,EAAOhO,O,EAAS;UACf,KAAJ,Y,EAAuB,OAAA,IAAA;;WACvB,mB,CAAA,K,EAAA,I,EAAA,O;;aACA,I;;;;;;;;;;;;;;;;;yBAeGgO,K,EAAOhO,O,EAAS;UACf,KAAJ,Y,EAAuB,OAAA,IAAA;;WACvB,mB,CAAA,K,EAAA,K,EAAA,O;;aACA,I;;;;;;;;;;;;;;;;;;;;;;;;2BAsBKsG,S,EAAWtG,O,EAAS;UACrB,KAAA,YAAA,IAAqB,CAAC,KAAA,MAAA,CAA1B,M,EAA8C,OAAA,IAAA;UAExCkR,WAAAA,GAAN,E;UACMC,WAAAA,GAAN,E;UACMC,iBAAAA,GAAoB,OAAA,SAAA,KAA1B,Q;UACMC,aAAAA,GAAgB,OAAA,SAAA,KAAtB,U;UACMjR,IAAAA,GAAOJ,OAAAA,IAAb,C;UACMsN,SAAAA,GAAYlN,IAAAA,CAAAA,OAAAA,KAAlB,I;UACM8N,MAAAA,GAAS9N,IAAAA,CAAAA,MAAAA,GAAcA,IAAAA,CAAdA,MAAAA,GAA4BA,IAAAA,CAAAA,MAAAA,KAA3C,S;UACMgL,QAAAA,GAAW,OAAOhL,IAAAA,CAAP,QAAA,KAAA,UAAA,GAAsCA,IAAAA,CAAtC,QAAA,GAAjB,I;UACIkR,gBAAAA,GAAmB,CAAvB,C;UACIV,SAAAA,GAAJ,I;UACIxL,IAAAA,GAAAA,KAAJ,C;UACI9G,CAAAA,GAAAA,KAAJ,C,CAdyB,C;;UAiBzB,Q,EAAc;oBACA,SAAA,SAAA,GAAW;YACrB,gB,IAAsB8M,QAAAA,CAAS8F,WAAAA,CAAAA,KAAAA,CAAT9F,CAAS8F,CAAT9F,EAA+B+F,WAAAA,CAAAA,KAAAA,CAArD,CAAqDA,CAA/B/F,C;AADxB,S;OAlBuB,C;;;UAwBrBiG,aAAAA,IAAJ,iB,EAAwC;aACjC/S,CAAAA,GAAL,C,EAAYA,CAAAA,GAAI,KAAA,MAAA,CAAhB,M,EAAoCA,CAApC,E,EAAyC;iBAChC,KAAA,MAAA,CAAP,CAAO,C;;cACH+S,aAAAA,GAAgB/K,SAAAA,CAAhB+K,IAAgB/K,CAAhB+K,GAAkChP,cAAAA,CAAe+C,IAAAA,CAAf/C,QAAAA,EAAtC,SAAsCA,C,EAA0C;wBAC9E,I,CAAA,I;AADF,W,MAEO;wBACL,I,CAAA,I;;;OA9BmB,C;;;UAoCrB6O,WAAAA,CAAJ,M,EAAwB;aACtB,I,CAAA,W,EAAuB;mBAAA,SAAA;oBAAA,SAAA;kBAGb;AAHa,S;AADzB,O,MAMO;;OA1CkB,C;;;UA+CrBC,WAAAA,CAAJ,M,EAAwB;aACtB,I,CAAA,W,EAAuB;mBAAA,SAAA;oBAAA,SAAA;kBAGb;AAHa,S;AADzB,O,MAMO;;OArDkB,C;;;UA0DrBD,WAAAA,CAAAA,MAAAA,IAAsBC,WAAAA,CAA1B,M,EAA8C;;YAExC,KAAA,aAAA,CAAJ,WAAI,C,EAAiC;eACnC,K,CAAA,W,EAAwBD,WAAAA,CAAAA,KAAAA,CAAxB,CAAwBA,C,EAAsBC,WAAAA,CAAAA,KAAAA,CAA9C,CAA8CA,C;SAHJ,C;;;YAO5C,M,EAAY;eACV,M,CAAYjD,MAAAA,KAAZ,S,EAAkC,OAAA,MAAA,KAAA,UAAA,GAAA,MAAA,GAAlC,S;;;;aAIJ,I;;;;;;;;;;;;;;;;;;;;yBAkBG9I,I,EAAM+G,Q,EAAUnM,O,EAAS;UACxB,KAAA,YAAA,IAAqB,KAAA,MAAA,CAAA,MAAA,GAAzB,C,EAAiD,OAAA,IAAA;UAE3CgO,KAAAA,GAAQ,KAAd,M;UACM5N,IAAAA,GAAOJ,OAAAA,IAAb,C;UACMkO,MAAAA,GAAS9N,IAAAA,CAAAA,MAAAA,GAAcA,IAAAA,CAAdA,MAAAA,GAA4BA,IAAAA,CAAAA,MAAAA,KAA3C,S;UACMmR,MAAAA,GAASnR,IAAAA,CAAAA,MAAAA,KAAf,M;UACMiD,MAAAA,GAASkO,MAAAA,GAAAA,MAAAA,GAAf,M;;UACMC,QAAAA,GAAW,KAAA,QAAA,CAAjB,IAAiB,C;;UACXC,MAAAA,GAAS,KAAA,QAAA,CAAf,QAAe,C;;UACXC,SAAAA,GAAAA,KAAJ,C;UACIC,OAAAA,GAAAA,KAAJ,C,CAX4B,C;;UAcxBH,QAAAA,IAAAA,MAAAA,IAAsBA,QAAAA,KAA1B,M,EAA+C;;oBAEjCxD,KAAAA,CAAAA,OAAAA,CAAZ,QAAYA,C;kBACFA,KAAAA,CAAAA,OAAAA,CAAV,MAAUA,C,CAHmC,C;;YAM7C,M,EAAY;oBACV,K,EAAA,S,EAAA,O;AADF,S,MAEO;oBACL,K,EAAA,S,EAAA,O;SAT2C,C;;;YAazC,KAAA,aAAA,CAAJ,SAAI,C,EAA+B;eACjC,K,CAAA,S,EAAsB;kBAAA,QAAA;uBAAA,SAAA;qBAAA,OAAA;;AAAA,W;SAdqB,C;;;YAuB7C,M,EAAY;eACV,M,CAAYE,MAAAA,KAAZ,S,EAAkC,OAAA,MAAA,KAAA,UAAA,GAAA,MAAA,GAAlC,S;;;;aAIJ,I;;;;;;;;;;;;;;;;;;;yBAiBG9I,I,EAAMC,I,EAAM8G,Q,EAAUnM,O,EAAS;UAC9B,KAAA,YAAA,IAAqBqF,IAAAA,CAArB,YAAA,IAA0C,SAA9C,I,EAA6D,OAAA,IAAA,CAD3B,C;;aAI3B,KAAA,QAAA,CAAP,IAAO,C;UACH,CAAJ,I,EAAW,OAAA,IAAA;UAELjF,IAAAA,GAAOJ,OAAAA,IAAb,C;UACMoM,SAAAA,GAAYhM,IAAAA,CAAAA,QAAAA,IAAiBd,QAAAA,CAAnC,I;UACMsS,YAAAA,GAAexR,IAAAA,CAAAA,YAAAA,GAAoBA,IAAAA,CAApBA,YAAAA,GAAwCA,IAAAA,CAAAA,YAAAA,KAA7D,S;UACMyR,cAAAA,GAAiBzR,IAAAA,CAAAA,cAAAA,GACnBA,IAAAA,CADmBA,cAAAA,GAEnBA,IAAAA,CAAAA,cAAAA,KAFJ,S,CAVkC,C;;WAelC,Q,CAAA,K,CAAA,I,EAAA,Q,EAAA,S,EAfkC,C;;;;UAmB9BgF,IAAAA,CAAAA,QAAAA,CAAAA,SAAAA,IAA2BA,IAAAA,CAA/B,S,EAA+C;YAC7C,Y,EAAkB;eAChB,M,CACEwM,YAAAA,KADF,S,EAEE,OAAA,YAAA,KAAA,UAAA,GAAA,YAAA,GAFF,S;;;YAKF,c,EAAoB;eAClB,M,CACEC,cAAAA,KADF,S,EAEE,OAAA,cAAA,KAAA,UAAA,GAAA,cAAA,GAFF,S;;;;aAOJ,I;;;;;;;;;;;;;4BAWMC,c,EAAgB;UAClB,KAAJ,Y,EAAuB,OAAA,IAAA;UAEjB1F,SAAAA,GAAY,KAAlB,Q;;UACM4B,KAAAA,GAAQ,KAAA,MAAA,CAAA,KAAA,CAAd,CAAc,C;;UACV1P,CAAAA,GAAAA,KAAJ,C,CALsB,C;;UAQlB,KAAJ,c,EAAyB;eACvB,mB,CAAA,Q,EAAqC,KAArC,c;OAToB,C;;;WAajBA,CAAAA,GAAL,C,EAAYA,CAAAA,GAAI0P,KAAAA,CAAhB,M,EAA8B1P,CAA9B,E,EAAmC;cACjC,C,EAAA,Q,CAAA,c;OAdoB,C;;;kBAkBtB,S,EAAuB,KAAA,SAAA,CAAvB,c;gBACA,K,CAAA,M,GAAA,E;gBACA,K,CAAA,K,GAAA,E,CApBsB,C;;WAuBtB,K,CAAA,Y;;WACA,Q,CAAA,O,GAxBsB,C;;;oBA2BR,KAAd,G,IAAA,S,CA3BsB,C;;WA8BtB,Y,GAAA,I;aAEA,I;;;;;;;;;;;;;;;;;;;;;6BAmBOwK,M,EAAQ;;UAEX,KAAA,YAAA,IAAsB,CAAA,MAAA,IAAWA,MAAAA,KAArC,C,EAAoD;eAClD,I;OAHa,C;;;;;UASX,OAAA,MAAA,KAAJ,Q,EAAgC;eACvB,KAAA,MAAA,CAAYA,MAAAA,GAAS,CAATA,CAAAA,GAAAA,MAAAA,GAAuB,KAAA,MAAA,CAAA,MAAA,GAAnC,MAAA,KAAP,I;OAVa,C;;;;UAeXA,MAAAA,YAAJ,I,EAA4B;eACnBA,MAAAA,CAAAA,OAAAA,KAAmB,KAAnBA,GAAAA,GAAAA,MAAAA,GAAP,I;OAhBa,C;;;;;;;WAuBV,IAAIxK,CAAAA,GAAT,C,EAAgBA,CAAAA,GAAI,KAAA,MAAA,CAApB,M,EAAwCA,CAAxC,E,EAA6C;YACvC,KAAA,MAAA,CAAA,CAAA,EAAA,QAAA,KAAJ,M,EAAwC;iBAC/B,KAAA,MAAA,CAAP,CAAO,C;;;;aAIX,I;;;;;;;;;;;;oCAUc;UACR4P,MAAAA,GAAS,KAAf,O;UACM5I,QAAAA,GAAW,KAAA,SAAA,CAAjB,M;UACI2E,KAAAA,GAAAA,KAAJ,C;UACIC,MAAAA,GAAAA,KAAJ,C;UACI6H,SAAAA,GAAAA,KAAJ,C;UACIzT,CAAAA,GAAAA,KAAJ,C,CANc,C;;QASZ4P,MAAAA,CAAF,E,CATc,C;;aAYd,K,CAAA,M,GAAA,C;;WACK5P,CAAAA,GAAL,C,EAAYA,CAAAA,GAAI,KAAA,MAAA,CAAhB,M,EAAoCA,CAApC,E,EAAyC;YACnC,KAAA,MAAA,CAAA,CAAA,EAAJ,S,EAA8B4P,MAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAkB,KAAA,MAAA,CAAlBA,CAAkB,CAAlBA;OAdlB,C;;;WAkBd,kB,GAlBc,C;;;cAqBN,KAAA,MAAA,GAAc,KAAd,WAAA,GAAiC,KAAzC,Y;eACS,KAAA,OAAA,GAAe,KAAf,UAAA,GAAiC,KAA1C,a,CAtBc,C;;UAyBV,OAAA,QAAA,KAAJ,U,EAAoC;oBACtB5I,QAAAA,CAAS4I,MAAAA,CAAT5I,KAAAA,EAAAA,KAAAA,EAAZ,MAAYA,C;AADd,O,MAEO;oBACOuK,MAAAA,CAAAA,SAAAA,CAAiB3B,MAAAA,CAAjB2B,KAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAA8C3B,MAAAA,CAA9C2B,KAAAA,EAAZ,QAAYA,C;OA5BA,C;;;aAgCd,K,GAAekC,SAAAA,CAAf,K;aACA,Q,GAAkBC,OAAAA,CAAQD,SAAAA,CAA1B,QAAkBC,C;aAClB,S,GAAmBA,OAAAA,CAAQD,SAAAA,CAA3B,SAAmBC,C;aACnB,K,GAAeD,SAAAA,CAAf,K;aACA,M,GAAgBA,SAAAA,CAAhB,M;aAEA,M;;;;;;;;;;;;;4BAWM;;;UACF,KAAJ,Y,EAAuB;;uBACvB,Q,EAAA,I,CAAA,K,CAAA,Q,EAAA,S;;;;;;;;;;;;;kCAWY7T,K,EAAO;UACbE,SAAAA,GAAY,KAAA,QAAA,CAAA,OAAA,CAAlB,KAAkB,C;aACX,CAAC,EAAEA,SAAAA,IAAaA,SAAAA,CAAvB,MAAQ,C;;;;;;;;;;;0CASY;UACdsC,OAAAA,GAAU,KAAhB,Q;UACMuD,IAAAA,GAAOvD,OAAAA,CAAb,qBAAaA,E;WACb,M,GAAcuD,IAAAA,CAAd,K;WACA,O,GAAeA,IAAAA,CAAf,M;WACA,K,GAAaA,IAAAA,CAAb,I;WACA,I,GAAYA,IAAAA,CAAZ,G;;;;;;;;;;;;;;;mCAaa6G,I,EAAMmH,K,EAAOxD,G,EAAKyD,M,EAAQ;UACjCxR,OAAAA,GAAU,KAAhB,Q;UACA,I,EAAU,KAAA,WAAA,GAAmBwD,eAAAA,CAAAA,OAAAA,EAAnB,mBAAmBA,CAAnB;UACV,K,EAAW,KAAA,YAAA,GAAoBA,eAAAA,CAAAA,OAAAA,EAApB,oBAAoBA,CAApB;UACX,G,EAAS,KAAA,UAAA,GAAkBA,eAAAA,CAAAA,OAAAA,EAAlB,kBAAkBA,CAAlB;UACT,M,EAAY,KAAA,aAAA,GAAqBA,eAAAA,CAAAA,OAAAA,EAArB,qBAAqBA,CAArB;;;;;;;;;;;yCASO;WACnB,mB;;WACA,c,CAAA,C,EAAA,C,EAAA,C,EAAA,C;;;;;;;;;;;;;;;;;wCAekB8J,K,EAAOd,S,EAAWlN,O,EAAS;UACvCqF,IAAAA,GAAN,I;UACMkH,WAAAA,GAAc,KAAA,QAAA,CAApB,KAAoB,C;UACdnM,IAAAA,GAAOJ,OAAAA,IAAb,C;UACMsN,SAAAA,GAAYlN,IAAAA,CAAAA,OAAAA,KAAlB,I;UACM/B,QAAAA,GAAW+B,IAAAA,CAAjB,Q;UACM8N,MAAAA,GAAS9N,IAAAA,CAAAA,MAAAA,GAAcA,IAAAA,CAAdA,MAAAA,GAA4BA,IAAAA,CAAAA,MAAAA,KAA3C,S;UACImQ,OAAAA,GAAUhE,WAAAA,CAAd,M;UACM4F,UAAAA,GAAajF,SAAAA,GAAAA,cAAAA,GAAnB,c;UACMkF,QAAAA,GAAWlF,SAAAA,GAAAA,YAAAA,GAAjB,Y;UACMmF,MAAAA,GAASnF,SAAAA,GAAAA,MAAAA,GAAf,M;UACI6D,WAAAA,GAAJ,K;UACMuB,cAAAA,GAAN,E;UACMC,WAAAA,GAAN,E;UACInN,IAAAA,GAAAA,KAAJ,C;UACI9G,CAAAA,GAAAA,KAAJ,C,CAf6C,C;;UAkBzC,CAAJ,O,EAAc;YACR,OAAA,QAAA,KAAJ,U,EAAoCD,QAAAA,CAAAA,WAAAA,CAAAA;;OAnBO,C;;;UAwBzC,KAAA,aAAA,CAAJ,UAAI,C,EAAgC;aAClC,K,CAAA,U,EAAuBkO,WAAAA,CAAAA,KAAAA,CAAvB,CAAuBA,C;OAzBoB,C;;;WA6BxCjO,CAAAA,GAAL,C,EAAYA,CAAAA,GAAIiO,WAAAA,CAAhB,M,EAAoCjO,CAApC,E,EAAyC;eAChCiO,WAAAA,CAAP,CAAOA,C,CADgC,C;;;YAKlCW,SAAAA,IAAa,CAAC9H,IAAAA,CAAf,SAAC8H,IAAkC,CAAA,SAAA,IAAc9H,IAAAA,CAArD,S,EAAsE;wBACpE,I;SANqC,C;;;;YAWnC8H,SAAAA,IAAa,CAAC9H,IAAAA,CAAlB,S,EAAkC;eAChC,O,CAAA,kB,GAAA,I;SAZqC,C;;;;YAiBnC8H,SAAAA,IAAa9H,IAAAA,CAAAA,WAAAA,CAAjB,S,EAA6C;sBAC3C,I,CAAA,I;SAlBqC,C;;;aAsBvC,W,CAAA,M,EAAA,S,EAAoC,UAAA,WAAA,EAAA,IAAA,EAAuB;;;cAGrD,CAAJ,W,EAAkBkN,cAAAA,CAAAA,IAAAA,CAAAA,IAAAA,EAHuC,C;;;cAOrD,EAAA,OAAA,GAAJ,C,EAAmB;gBACb,OAAA,QAAA,KAAJ,U,EAAoCjU,QAAAA,CAASiU,cAAAA,CAAAA,KAAAA,CAATjU,CAASiU,CAATjU,CAAAA;gBAChCgH,IAAAA,CAAAA,aAAAA,CAAJ,QAAIA,C,EAA8BA,IAAAA,CAAAA,KAAAA,CAAAA,QAAAA,EAAqBiN,cAAAA,CAAAA,KAAAA,CAArBjN,CAAqBiN,CAArBjN;;AATtC,S;OAnD2C,C;;;UAkEzCkN,WAAAA,CAAJ,M,EAAwB,KAAA,YAAA,CAAA,WAAA,EAlEqB,C;;UAqEzCxB,WAAAA,IAAJ,M,EAA2B;aACzB,M,CAAY7C,MAAAA,KAAZ,S,EAAkC,OAAA,MAAA,KAAA,UAAA,GAAA,MAAA,GAAlC,S;;;;;CA99BA4B,CAAa7R,SAAb6R,C;;;;;;;;;;;AA2+BNA,IAAAA,CAAAA,IAAAA,GAAAA,IAAAA;;;;;AAKAA,IAAAA,CAAAA,UAAAA,GAAAA,UAAAA;;;;;AAKAA,IAAAA,CAAAA,cAAAA,GAAAA,cAAAA;;;;;AAKAA,IAAAA,CAAAA,WAAAA,GAAAA,WAAAA;;;;;AAKAA,IAAAA,CAAAA,WAAAA,GAAAA,WAAAA;;;;;AAKAA,IAAAA,CAAAA,WAAAA,GAAAA,WAAAA;;;;;AAKAA,IAAAA,CAAAA,QAAAA,GAAAA,QAAAA;;;;;AAKAA,IAAAA,CAAAA,OAAAA,GAAAA,OAAAA;;;;;;;;AAQAA,IAAAA,CAAAA,cAAAA,GAAsB;;SAAA,GAAA;;gBAAA,GAAA;cAAA,MAAA;;gBAAA,GAAA;cAAA,MAAA;;iBAaL;aAAA,GAAA;eAEF;AAFE,GAbK;gBAiBN;aAAA,GAAA;eAED;AAFC,GAjBM;;UAuBZ;cAAA,KAAA;gBAAA,KAAA;gBAAA,KAAA;iBAAA,KAAA;cAKI;AALJ,GAvBY;kBAAA,GAAA;gBAAA,IAAA;kBAAA,GAAA;gBAAA,MAAA;;YAAA,IAAA;;eAAA,KAAA;iBAAA,IAAA;sBAyCA;cAAA,CAAA;WAAA,CAAA;YAGV;AAHU,GAzCA;YAAA,IAAA;YAAA,IAAA;oBAAA,GAAA;qBAiDD;eAAA,EAAA;YAET;AAFS,GAjDC;uBAAA,GAAA;qBAAA,MAAA;sBAuDA;iBACL;AADK,GAvDA;;kBAAA,OAAA;aAAA,YAAA;oBAAA,kBAAA;mBAAA,mBAAA;wBAAA,wBAAA;qBAAA,qBAAA;sBAkEA;AAlEA,CAAtBA;;;;;;;;;;;;;;;;;;;;AAuFAA,IAAAA,CAAAA,SAAAA,CAAAA,IAAAA,GAAwB,YAAM;MACxB0C,YAAAA,GAAAA,KAAJ,C;MACIC,YAAAA,GAAAA,KAAJ,C;MACIC,SAAAA,GAAAA,KAAJ,C;MACIC,QAAAA,GAAAA,KAAJ,C;;WAEA,a,CAAA,I,EAA6B;WACpB,IAAA,CAAA,IAAA,GAAA,KAAA,CAAA,GAAA,EAAA,GAAA,CAGA,UAAA,GAAA,EAAA;aAAOC,GAAAA,CAAAA,KAAAA,CAAP,GAAOA,C;AAHd,KAAO,C;;;WAMT,W,CAAA,K,EAA4B;QACpBnP,GAAAA,GAAN,E;;SACK,IAAInF,CAAAA,GAAT,C,EAAgBA,CAAAA,GAAI0P,KAAAA,CAApB,M,EAAkC1P,CAAlC,E,EAAuC;UACjC0P,KAAAA,CAAAA,CAAAA,CAAAA,CAAJ,G,IAAA,C;;;WAEF,G;;;WAGF,c,CAAA,K,EAAA,K,EAAsC;QAC9BlL,MAAAA,GAAS6P,QAAAA,CAASE,KAAAA,CAAxB,GAAeF,C;QACT5P,MAAAA,GAAS4P,QAAAA,CAASG,KAAAA,CAAxB,GAAeH,C;WACRF,YAAAA,GAAe1P,MAAAA,GAAf0P,MAAAA,GAAiC3P,MAAAA,GAAxC,M;;;WAGF,e,CAAA,C,EAAA,C,EAA+B;QACzBoE,MAAAA,GAAJ,C;QACI6L,YAAAA,GAAAA,KAAJ,C;QACIC,aAAAA,GAAAA,KAAJ,C;QACIC,IAAAA,GAAAA,KAAJ,C;QACIC,IAAAA,GAAAA,KAAJ,C,CAL6B,C;;SAQxB,IAAI5U,CAAAA,GAAT,C,EAAgBA,CAAAA,GAAIkU,YAAAA,CAApB,M,EAAyClU,CAAzC,E,EAA8C;;qBAE7BkU,YAAAA,CAAAA,CAAAA,CAAAA,CAAf,CAAeA,C;sBACCA,YAAAA,CAAAA,CAAAA,CAAAA,CAAhB,CAAgBA,C,CAH4B,C;;;aAOrC,CAACzI,CAAAA,CAAAA,SAAAA,GAAAA,CAAAA,GAAkBA,CAAAA,CAAnB,gBAAmBA,EAAnB,EAAA,SAAA,CAAP,YAAO,C;aACA,CAACC,CAAAA,CAAAA,SAAAA,GAAAA,CAAAA,GAAkBA,CAAAA,CAAnB,gBAAmBA,EAAnB,EAAA,SAAA,CAAP,YAAO,C,CARqC,C;;;UAYxCgJ,aAAAA,KAAAA,MAAAA,IAA6B,CAAA,aAAA,IAAjC,Y,EAAkE;iBACvDE,IAAAA,GAAAA,IAAAA,GAAc,CAAdA,CAAAA,GAAmBA,IAAAA,GAAAA,IAAAA,GAAAA,CAAAA,GAA5B,C;AADF,O,MAEO;iBACID,IAAAA,GAAAA,IAAAA,GAAc,CAAdA,CAAAA,GAAmBA,IAAAA,GAAAA,IAAAA,GAAAA,CAAAA,GAA5B,C;OAf0C,C;;;UAmB5C,M,EAAY,OAAA,MAAA;KA3Be,C;;;;QAgCzB,CAAJ,M,EAAa;UACP,CAAJ,Q,EAAeN,QAAAA,GAAWQ,WAAAA,CAAXR,SAAWQ,CAAXR;eACNS,cAAAA,CAAAA,CAAAA,EAAT,CAASA,C;;;WAEX,M;;;WAGF,c,CAAA,C,EAAA,C,EAA8B;QACxBlM,MAAAA,GAASsL,YAAAA,CAAAA,CAAAA,EAAb,CAAaA,C,CADe,C;;QAGxBC,YAAAA,IAAJ,M,EAA4BvL,MAAAA,GAAS,CAATA,MAAAA,CAHA,C;;QAK5B,M,EAAY,OAAA,MAAA,CALgB,C;;;QAQxB,CAAJ,Q,EAAeyL,QAAAA,GAAWQ,WAAAA,CAAXR,SAAWQ,CAAXR;WACRS,cAAAA,CAAAA,CAAAA,EAAP,CAAOA,C;;;SAGF,UAAA,QAAA,EAAA,OAAA,EAA4B;QAC7B,KAAA,YAAA,IAAqB,KAAA,MAAA,CAAA,MAAA,GAAzB,C,EAAiD,OAAA,IAAA;QAE3CpF,KAAAA,GAAQ,KAAd,M;QACM5N,IAAAA,GAAOJ,OAAAA,IAAb,C;QACMkO,MAAAA,GAAS9N,IAAAA,CAAAA,MAAAA,GAAcA,IAAAA,CAAdA,MAAAA,GAA4BA,IAAAA,CAAAA,MAAAA,KAA3C,S;QACI9B,CAAAA,GAAAA,KAAJ,C,CANiC,C;;mBASjC,Q;mBACe,CAAC,CAAC8B,IAAAA,CAAjB,U;gBACY4N,KAAAA,CAAAA,KAAAA,CAAZ,CAAYA,C;eACZ,I,CAZiC,C;;QAe7B,OAAA,YAAA,KAAJ,U,EAAwC;YACtC,I,CAAA,c;;;SAIG,IAAI,OAAA,YAAA,KAAJ,QAAA,EAAsC;uBAC1BqF,aAAAA,CAAf,QAAeA,C;cACf,I,CAAA,e;OAFG,C;;AAAA,WAMA,IAAIjK,KAAAA,CAAAA,OAAAA,CAAJ,YAAIA,CAAJ,EAAiC;cAChCoJ,YAAAA,CAAAA,MAAAA,KAAwBxE,KAAAA,CAA5B,M,EAA0C;kBAClC,IAAA,KAAA,CAAA,MAAA,SAAA,GAAN,sDAAM,C;;;eAEH1P,CAAAA,GAAL,C,EAAYA,CAAAA,GAAI0P,KAAAA,CAAhB,M,EAA8B1P,CAA9B,E,EAAmC;gBAC7B,CAACkU,YAAAA,CAAAA,QAAAA,CAAsBxE,KAAAA,CAA3B,CAA2BA,CAAtBwE,C,EAAiC;oBAC9B,IAAA,KAAA,CAAA,MAAA,SAAA,GAAN,sDAAM,C;;;kBAER,C,IAAWA,YAAAA,CAAX,CAAWA,C;;;cAEb,Y,EAAkBxE,KAAAA,CAAAA,OAAAA;SAVf,C;AAAA,aAaA;;mBAEH,I;WAzC+B,C;;;QA6C7B,KAAA,aAAA,CAAJ,SAAI,C,EAA+B;WACjC,K,CAAA,S,EAAsBA,KAAAA,CAAAA,KAAAA,CAAtB,CAAsBA,C,EAAtB,S;KA9C+B,C;;;QAkDjC,M,EAAY;WACV,M,CAAYE,MAAAA,KAAZ,S,EAAkC,OAAA,MAAA,KAAA,UAAA,GAAA,MAAA,GAAlC,S;;;WAGF,I;AAtDF,G;AA9EF4B,CAAwB,EAAxBA;;;;;;;;;;;;;;;;;;;AAwJA,SAAA,aAAA,CAAA,eAAA,EAAA,YAAA,EAAsD;;MAEhDrM,GAAAA,GAAM6P,YAAAA,CAAAA,EAAAA,EAAV,eAAUA,C,CAF0C,C;;MAKpD,Y,EAAkB;UACVA,YAAAA,CAAAA,GAAAA,EAAN,YAAMA,C;GAN4C,C;;;;MAWpD,a,GAAoB,CAACC,YAAAA,IAAD,CAAA,EAAA,aAAA,IAAqC,CAACC,eAAAA,IAAD,CAAA,EAAzD,a;MACA,Y,GAAmB,CAACD,YAAAA,IAAD,CAAA,EAAA,YAAA,IAAoC,CAACC,eAAAA,IAAD,CAAA,EAAvD,Y;SAEA,G;;;;;;;;;;;;;;AAaF,SAAA,YAAA,CAAA,MAAA,EAAA,MAAA,EAAsC;MAC9BC,UAAAA,GAAa9O,MAAAA,CAAAA,IAAAA,CAAnB,MAAmBA,C;MACbhD,MAAAA,GAAS8R,UAAAA,CAAf,M;MACIC,cAAAA,GAAAA,KAAJ,C;MACItU,QAAAA,GAAAA,KAAJ,C;MACId,CAAAA,GAAAA,KAAJ,C;;OAEKA,CAAAA,GAAL,C,EAAYA,CAAAA,GAAZ,M,EAAwBA,CAAxB,E,EAA6B;eAChBmV,UAAAA,CAAX,CAAWA,C;qBACM3N,aAAAA,CAAc6N,MAAAA,CAA/B,QAA+BA,CAAd7N,C,CAFU,C;;;QAMvBA,aAAAA,CAAcgD,MAAAA,CAAdhD,QAAcgD,CAAdhD,CAAAA,IAAJ,c,EAAuD;aACrD,Q,IAAmBwN,YAAAA,CAAaA,YAAAA,CAAAA,EAAAA,EAAiBxK,MAAAA,CAA9BwK,QAA8BxK,CAAjBwK,CAAbA,EAAiDK,MAAAA,CAApE,QAAoEA,CAAjDL,C;;KAPM,C;;;;QAa3B,c,EAAoB;aAClB,Q,IAAmBA,YAAAA,CAAAA,EAAAA,EAAiBK,MAAAA,CAApC,QAAoCA,CAAjBL,C;;KAdM,C;;;;QAoBvBlK,KAAAA,CAAAA,OAAAA,CAAcuK,MAAAA,CAAlB,QAAkBA,CAAdvK,C,EAAiC;aACnC,Q,IAAmBuK,MAAAA,CAAAA,QAAAA,CAAAA,CAAAA,KAAAA,CAAnB,CAAmBA,C;;KArBM,C;;;;WA2B3B,Q,IAAmBA,MAAAA,CAAnB,QAAmBA,C;;;SAGrB,M;;;ICp6CmBC,SAAAA,GAAAA,UAAAA,UAAAA,EAAAA;;;qBAMnB,K,EAAoB;;;qHAAA,K;;UAGlB,I,GAAY,IAAA,IAAA,CAASI,KAAAA,CAAT,IAAA,EAAqBA,KAAAA,CAAjC,cAAY,C;UACZ,S,GAAiB,KAAA,CAAA,SAAA,CAAA,IAAA,CAAjB,KAAiB,C;UACjB,Q,GAAgB,KAAA,CAAA,QAAA,CAAA,IAAA,CAAhB,KAAgB,C;UAChB,a,GAAqB,KAAA,CAAA,aAAA,CAAA,IAAA,CAArB,KAAqB,C;;;;;;8BAGZ3B,M,EAAQ4B,M,EAAQC,M,EAAQC,M,EAAQC,M,EAAQ;UAC7C;YACElN,MAAAA,GAAAA,KAAJ,C;;gBAEA,M;eACE,Y;qBACW,KAAA,IAAA,CAAT,UAAS,E;;;eAEX,U;qBACW,KAAA,IAAA,CAAA,QAAA,CAAT,MAAS,C;;;eAEX,c;qBACW,KAAA,IAAA,CAAA,YAAA,CAAT,MAAS,C;;;eAEX,iB;qBACW,KAAA,IAAA,CAAA,eAAA,CAAT,MAAS,C;;;eAEX,a;qBACW,KAAA,IAAA,CAAT,WAAS,E;;;eAEX,Q;qBACW,KAAA,IAAA,CAAA,MAAA,CAAA,MAAA,EAAT,MAAS,C;;;eAEX,K;qBACW,KAAA,IAAA,CAAA,GAAA,CAAA,MAAA,EAAT,MAAS,C;;;eAEX,Q;qBACW,KAAA,IAAA,CAAA,MAAA,CAAA,MAAA,EAAT,MAAS,C;;;eAEX,M;qBACW,KAAA,IAAA,CAAA,IAAA,CAAA,MAAA,EAAT,MAAS,C;;;eAEX,M;qBACW,KAAA,IAAA,CAAA,IAAA,CAAA,MAAA,EAAT,MAAS,C;;;eAEX,Q;qBACW,KAAA,IAAA,CAAA,MAAA,CAAA,MAAA,EAAT,MAAS,C;;;eAEX,M;qBACW,KAAA,IAAA,CAAA,IAAA,CAAA,MAAA,EAAT,MAAS,C;;;eAEX,M;qBACW,KAAA,IAAA,CAAA,IAAA,CAAA,MAAA,EAAA,MAAA,EAAT,MAAS,C;;;eAEX,M;qBACW,KAAA,IAAA,CAAA,IAAA,CAAA,MAAA,EAAA,MAAA,EAAA,MAAA,EAAT,MAAS,C;;;eAEX,I;qBACW,KAAA,IAAA,CAAA,EAAA,CAAA,MAAA,EAAT,MAAS,C;;;eAEX,M;qBACW,KAAA,IAAA,CAAA,IAAA,CAAA,MAAA,EAAT,MAAS,C;;;eAEX,K;qBACW,KAAA,IAAA,CAAA,GAAA,CAAA,MAAA,EAAT,MAAS,C;;;eAEX,S;qBACW,KAAA,IAAA,CAAA,OAAA,CAAT,MAAS,C;;;;qBAGT,I;oBACA,K,CAAA,kCAAA,M;oBACA,K,CAAA,4D;;;;eAIJ,M;AAjEF,O,CAkEE,OAAA,KAAA,EAAc;gBACd,K,CAAA,qDAAA,K;;;;;6BAIMhJ,K,EAAO+V,M,EAAQC,M,EAAQ7V,Q,EAAU;;;UACnCgW,UAAAA,GAAa,CAAA,aAAA,EAAA,aAAA,EAAA,WAAA,EAAA,KAAA,EAAA,QAAA,EAAA,WAAA,EAAA,SAAA,EAAA,WAAA,EAAA,SAAA,EAAA,QAAA,EAAA,MAAA,EAAA,MAAA,EAAA,MAAA,EAAA,YAAA,EAAA,SAAA,EAAA,eAAA,EAAA,UAAA,EAAA,WAAA,EAAA,UAAA,EAAA,YAAA,EAAA,SAAA,EAAA,kBAAA,EAAA,gBAAA,EAAnB,SAAmB,C;;UA2BfnW,KAAAA,KAAAA,SAAAA,IAAuBA,KAAAA,KAAvBA,IAAAA,IAAyCmW,UAAAA,CAAAA,OAAAA,CAAAA,KAAAA,MAA8B,CAA3E,C,EAA+E;gBAC7E,K,CAAA,+CAAA,K;AADF,O,MAEO;YACD;eACF,I,CAAA,E,CAAA,K,EAAoB,UAAA,MAAA,EAAA,MAAA,EAAoB;gBACtC,Q,EAAc;uBACZ,M,EAAA,M;;;mBAGF,I,CAAA,W;AALF,W;AADF,S,CAQE,OAAA,KAAA,EAAc;kBACd,K,CAAA,oDAAA,K;;;;;;kCAKShC,M,EAAQjN,I,EAAM;UACvB;YACE8B,MAAAA,GAAAA,KAAJ,C;;gBAEA,M;eACE,S;qBACW9B,IAAAA,CAAT,OAASA,E;;;eAEX,Y;qBACWA,IAAAA,CAAT,UAASA,E;;;eAEX,U;qBACWA,IAAAA,CAAT,QAASA,E;;;eAEX,W;qBACWA,IAAAA,CAAT,SAASA,E;;;eAEX,W;qBACWA,IAAAA,CAAT,SAASA,E;;;eAEX,a;qBACWA,IAAAA,CAAT,WAASA,E;;;eAEX,U;qBACWA,IAAAA,CAAT,QAASA,E;;;eAEX,W;qBACWA,IAAAA,CAAT,SAASA,E;;;eAEX,W;qBACWA,IAAAA,CAAT,SAASA,E;;;eAEX,U;qBACWA,IAAAA,CAAT,QAASA,E;;;eAEX,e;qBACWA,IAAAA,CAAT,aAASA,E;;;eAEX,Y;qBACWA,IAAAA,CAAT,UAASA,E;;;eAEX,a;qBACWA,IAAAA,CAAT,WAASA,E;;;eAEX,a;qBACWA,IAAAA,CAAT,WAASA,E;;;;qBAGT,I;oBACA,K,CAAA,sCAAA,M;oBACA,K,CAAA,gE;;;;eAIJ,M;AArDF,O,CAsDE,OAAA,KAAA,EAAc;gBACd,K,CAAA,yDAAA,K;;;;;CA5LewO,CAAkB3V,SAAlB2V,C;;AAAAA,SAAAA,CACZC,SADYD,GACA;QACXE,SAAAA,CAAAA,IAAAA,CADW,UAAA;kBAEDA,SAAAA,CAAUC;AAFT,CADAH","sourcesContent":["/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\nexport const namespace = 'Muuri';\r\nexport const gridInstances = {};\r\n\r\nexport const eventSynchronize = 'synchronize';\r\nexport const eventLayoutStart = 'layoutStart';\r\nexport const eventLayoutEnd = 'layoutEnd';\r\nexport const eventAdd = 'add';\r\nexport const eventRemove = 'remove';\r\nexport const eventShowStart = 'showStart';\r\nexport const eventShowEnd = 'showEnd';\r\nexport const eventHideStart = 'hideStart';\r\nexport const eventHideEnd = 'hideEnd';\r\nexport const eventFilter = 'filter';\r\nexport const eventSort = 'sort';\r\nexport const eventMove = 'move';\r\nexport const eventSend = 'send';\r\nexport const eventBeforeSend = 'beforeSend';\r\nexport const eventReceive = 'receive';\r\nexport const eventBeforeReceive = 'beforeReceive';\r\nexport const eventDragInit = 'dragInit';\r\nexport const eventDragStart = 'dragStart';\r\nexport const eventDragMove = 'dragMove';\r\nexport const eventDragScroll = 'dragScroll';\r\nexport const eventDragEnd = 'dragEnd';\r\nexport const eventDragReleaseStart = 'dragReleaseStart';\r\nexport const eventDragReleaseEnd = 'dragReleaseEnd';\r\nexport const eventDestroy = 'destroy';\r\n","/**\r\n * Muuri Emitter\r\n * Copyright (c) 2018-present, Niklas Rämö <inramo@gmail.com>\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/src/Emitter/LICENSE.md\r\n */\r\nimport { Component } from 'react';\r\n\r\n/**\r\n * Event emitter constructor.\r\n *\r\n * @class\r\n */\r\nclass Emitter extends Component {\r\n  constructor() {\r\n    super();\r\n    this._events = {};\r\n    this._queue = [];\r\n    this._counter = 0;\r\n    this._isDestroyed = false;\r\n  }\r\n\r\n  /**\r\n   * Public prototype methods\r\n   * ************************\r\n   */\r\n\r\n  /**\r\n   * Bind an event listener.\r\n   *\r\n   * @public\r\n   * @memberof Emitter.prototype\r\n   * @param {String} event\r\n   * @param {Function} listener\r\n   * @returns {Emitter}\r\n   */\r\n  on(event, listener) {\r\n    if (this._isDestroyed) return this;\r\n\r\n    // Get listeners queue and create it if it does not exist.\r\n    let listeners = this._events[event];\r\n    if (!listeners) listeners = this._events[event] = [];\r\n\r\n    // Add the listener to the queue.\r\n    listeners.push(listener);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Bind an event listener that is triggered only once.\r\n   *\r\n   * @public\r\n   * @memberof Emitter.prototype\r\n   * @param {String} event\r\n   * @param {Function} listener\r\n   * @returns {Emitter}\r\n   */\r\n  once(event, listener) {\r\n    if (this._isDestroyed) return this;\r\n\r\n    const callback = function() {\r\n      this.off(event, callback);\r\n      listener(...arguments);\r\n    }.bind(this);\r\n\r\n    return this.on(event, callback);\r\n  }\r\n\r\n  /**\r\n   * Unbind all event listeners that match the provided listener function.\r\n   *\r\n   * @public\r\n   * @memberof Emitter.prototype\r\n   * @param {String} event\r\n   * @param {Function} [listener]\r\n   * @returns {Emitter}\r\n   */\r\n  off(event, listener) {\r\n    if (this._isDestroyed) return this;\r\n\r\n    // Get listeners and return immediately if none is found.\r\n    const listeners = this._events[event];\r\n    if (!listeners || !listeners.length) return this;\r\n\r\n    // If no specific listener is provided remove all listeners.\r\n    if (!listener) {\r\n      listeners.length = 0;\r\n      return this;\r\n    }\r\n\r\n    // Remove all matching listeners.\r\n    let i = listeners.length;\r\n    while (i--) {\r\n      if (listener === listeners[i]) listeners.splice(i, 1);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Emit all listeners in a specified event with the provided arguments.\r\n   *\r\n   * @public\r\n   * @memberof Emitter.prototype\r\n   * @param {String} event\r\n   * @param {*} [arg1]\r\n   * @param {*} [arg2]\r\n   * @param {*} [arg3]\r\n   * @returns {Emitter}\r\n   */\r\n  emit(event, arg1, arg2, arg3) {\r\n    if (this._isDestroyed) return this;\r\n\r\n    // Get event listeners and quit early if there's no listeners.\r\n    const listeners = this._events[event];\r\n    if (!listeners || !listeners.length) return this;\r\n\r\n    const queue = this._queue;\r\n    let qLength = queue.length;\r\n    const aLength = arguments.length - 1;\r\n    let i;\r\n\r\n    // Add the current listeners to the callback queue before we process them.\r\n    // This is necessary to guarantee that all of the listeners are called in\r\n    // correct order even if new event listeners are removed/added during\r\n    // processing and/or events are emitted during processing.\r\n    for (i = 0; i < listeners.length; i++) {\r\n      queue.push(listeners[i]);\r\n    }\r\n\r\n    // Increment queue counter. This is needed for the scenarios where emit is\r\n    // triggered while the queue is already processing. We need to keep track of\r\n    // how many \"queue processors\" there are active so that we can safely reset\r\n    // the queue in the end when the last queue processor is finished.\r\n    ++this._counter;\r\n\r\n    // Process the queue (the specific part of it for this emit).\r\n    for (i = qLength, qLength = queue.length; i < qLength; i++) {\r\n      // prettier-ignore\r\n      aLength === 0 ? queue[i]() : // eslint-disable-line\r\n      aLength === 1 ? queue[i](arg1) : // eslint-disable-line\r\n      aLength === 2 ? queue[i](arg1, arg2) : // eslint-disable-line\r\n                      queue[i](arg1, arg2, arg3); // eslint-disable-line\r\n\r\n      // Stop processing if the emitter is destroyed.\r\n      if (this._isDestroyed) return this;\r\n    }\r\n\r\n    // Decrement queue process counter.\r\n    --this._counter;\r\n\r\n    // Reset the queue if there are no more queue processes running.\r\n    if (!this._counter) queue.length = 0;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Destroy emitter instance. Basically just removes all bound listeners.\r\n   *\r\n   * @public\r\n   * @memberof Emitter.prototype\r\n   * @returns {Emitter}\r\n   */\r\n  destroy() {\r\n    if (this._isDestroyed) return this;\r\n\r\n    const events = this._events;\r\n    let event;\r\n\r\n    // Flag as destroyed.\r\n    this._isDestroyed = true;\r\n\r\n    // Reset queue (if queue is currently processing this will also stop that).\r\n    this._queue.length = this._counter = 0;\r\n\r\n    // Remove all listeners.\r\n    for (event in events) {\r\n      if (events[event]) {\r\n        events[event].length = 0;\r\n        events[event] = undefined;\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n}\r\n\r\nexport default Emitter;\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\n// Set up the default export values.\r\nexport let isTransformSupported = false;\r\nexport let transformStyle = 'transform';\r\nexport let transformProp = 'transform';\r\n\r\n// Find the supported transform prop and style names.\r\nconst style = 'transform';\r\nconst styleCap = 'Transform';\r\n['', 'Webkit', 'Moz', 'O', 'ms'].forEach(function(prefix) {\r\n  if (isTransformSupported) return;\r\n  const propName = prefix ? prefix + styleCap : style;\r\n  if (document.documentElement.style[propName] !== undefined) {\r\n    prefix = prefix.toLowerCase();\r\n    transformStyle = prefix ? '-' + prefix + '-' + style : style;\r\n    transformProp = propName;\r\n    isTransformSupported = true;\r\n  }\r\n});\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\nimport { transformStyle } from './supportedTransform.js';\r\n\r\nconst stylesCache = typeof WeakMap === 'function' ? new WeakMap() : null;\r\n\r\n/**\r\n * Returns the computed value of an element's style property as a string.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {String} style\r\n * @returns {String}\r\n */\r\nexport default function getStyle(element, style) {\r\n  let styles = stylesCache && stylesCache.get(element);\r\n  if (!styles) {\r\n    styles = window.getComputedStyle(element, null);\r\n    stylesCache && stylesCache.set(element, styles);\r\n  }\r\n  return styles.getPropertyValue(style === 'transform' ? transformStyle : style);\r\n}\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\nconst styleNameRegEx = /([A-Z])/g;\r\n\r\n/**\r\n * Transforms a camel case style property to kebab case style property.\r\n *\r\n * @param {String} string\r\n * @returns {String}\r\n */\r\nexport default function getStyleName(string) {\r\n  return string.replace(styleNameRegEx, '-$1').toLowerCase();\r\n}\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\nimport { transformProp } from './supportedTransform.js';\r\n\r\n/**\r\n * Set inline styles to an element.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {Object} styles\r\n */\r\nexport default function setStyles(element, styles) {\r\n  for (const prop in styles) {\r\n    element.style[prop === 'transform' ? transformProp : prop] = styles[prop];\r\n  }\r\n}\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\nimport { Component } from 'react';\r\n\r\nimport getStyle from '../utils/getStyle.js';\r\nimport getStyleName from '../utils/getStyleName.js';\r\nimport setStyles from '../utils/setStyles.js';\r\nimport { transformProp } from '../utils/supportedTransform.js';\r\n\r\n/**\r\n * Item animation handler powered by Web Animations API.\r\n *\r\n * @class\r\n * @param {HTMLElement} element\r\n */\r\nclass ItemAnimate extends Component {\r\n  constructor(element) {\r\n    super(element);\r\n    this._element = element;\r\n    this._animation = null;\r\n    this._callback = null;\r\n    this._props = [];\r\n    this._values = [];\r\n    this._keyframes = [];\r\n    this._options = {};\r\n    this._isDestroyed = false;\r\n    this._onFinish = this._onFinish.bind(this);\r\n  }\r\n\r\n  /**\r\n   * Public prototype methods\r\n   * ************************\r\n   */\r\n\r\n  /**\r\n   * Start instance's animation. Automatically stops current animation if it is\r\n   * running.\r\n   *\r\n   * @public\r\n   * @memberof ItemAnimate.prototype\r\n   * @param {Object} propsFrom\r\n   * @param {Object} propsTo\r\n   * @param {Object} [options]\r\n   * @param {Number} [options.duration=300]\r\n   * @param {String} [options.easing='ease']\r\n   * @param {Function} [options.onFinish]\r\n   */\r\n  start(propsFrom, propsTo, options) {\r\n    if (this._isDestroyed) return;\r\n\r\n    let animation = this._animation;\r\n    const currentProps = this._props;\r\n    const currentValues = this._values;\r\n    const opts = options || 0;\r\n    let cancelAnimation = false;\r\n\r\n    // If we have an existing animation running, let's check if it needs to be\r\n    // cancelled or if it can continue running.\r\n    if (animation) {\r\n      let propCount = 0;\r\n      let propIndex;\r\n\r\n      // Check if the requested animation target props and values match with the\r\n      // current props and values.\r\n      for (const propName in propsTo) {\r\n        ++propCount;\r\n        propIndex = currentProps.indexOf(propName);\r\n        if (propIndex === -1 || propsTo[propName] !== currentValues[propIndex]) {\r\n          cancelAnimation = true;\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Check if the target props count matches current props count. This is\r\n      // needed for the edge case scenario where target props contain the same\r\n      // styles as current props, but the current props have some additional\r\n      // props.\r\n      if (!cancelAnimation && propCount !== currentProps.length) {\r\n        cancelAnimation = true;\r\n      }\r\n    }\r\n\r\n    // Cancel animation (if required).\r\n    if (cancelAnimation) animation.cancel();\r\n\r\n    // Store animation callback.\r\n    this._callback = typeof opts.onFinish === 'function' ? opts.onFinish : null;\r\n\r\n    // If we have a running animation that does not need to be cancelled, let's\r\n    // call it a day here and let it run.\r\n    if (animation && !cancelAnimation) return;\r\n\r\n    // Store target props and values to instance.\r\n    currentProps.length = currentValues.length = 0;\r\n    for (const propName in propsTo) {\r\n      currentProps.push(propName);\r\n      currentValues.push(propsTo[propName]);\r\n    }\r\n\r\n    // Set up keyframes.\r\n    const animKeyframes = this._keyframes;\r\n    animKeyframes[0] = propsFrom;\r\n    animKeyframes[1] = propsTo;\r\n\r\n    // Set up options.\r\n    const animOptions = this._options;\r\n    animOptions.duration = opts.duration || 300;\r\n    animOptions.easing = opts.easing || 'ease';\r\n\r\n    // Start the animation\r\n    const element = this._element;\r\n    animation = element.animate(animKeyframes, animOptions);\r\n    animation.onfinish = this._onFinish;\r\n    this._animation = animation;\r\n\r\n    // Set the end styles. This makes sure that the element stays at the end\r\n    // values after animation is finished.\r\n    setStyles(element, propsTo);\r\n  }\r\n\r\n  /**\r\n   * Stop instance's current animation if running.\r\n   *\r\n   * @public\r\n   * @memberof ItemAnimate.prototype\r\n   * @param {Object} [styles]\r\n   */\r\n  stop(styles) {\r\n    if (this._isDestroyed || !this._animation) return;\r\n\r\n    const element = this._element;\r\n    const currentProps = this._props;\r\n    const currentValues = this._values;\r\n    let propName;\r\n    let propValue;\r\n    let i;\r\n\r\n    // Calculate (if not provided) and set styles.\r\n    if (!styles) {\r\n      for (i = 0; i < currentProps.length; i++) {\r\n        propName = currentProps[i];\r\n        propValue = getStyle(element, getStyleName(propName));\r\n        element.style[propName === 'transform' ? transformProp : propName] = propValue;\r\n      }\r\n    } else {\r\n      setStyles(element, styles);\r\n    }\r\n\r\n    //  Cancel animation.\r\n    this._animation.cancel();\r\n    this._animation = this._callback = null;\r\n\r\n    // Reset current props and values.\r\n    currentProps.length = currentValues.length = 0;\r\n  }\r\n\r\n  /**\r\n   * Check if the item is being animated currently.\r\n   *\r\n   * @public\r\n   * @memberof ItemAnimate.prototype\r\n   * @return {Boolean}\r\n   */\r\n  isAnimating() {\r\n    return !!this._animation;\r\n  }\r\n\r\n  /**\r\n   * Destroy the instance and stop current animation if it is running.\r\n   *\r\n   * @public\r\n   * @memberof ItemAnimate.prototype\r\n   */\r\n  destroy() {\r\n    if (this._isDestroyed) return;\r\n    this.stop();\r\n    this._element = this._options = this._keyframes = null;\r\n    this._isDestroyed = true;\r\n  }\r\n\r\n  /**\r\n   * Private prototype methods\r\n   * *************************\r\n   */\r\n\r\n  /**\r\n   * Animation end handler.\r\n   *\r\n   * @private\r\n   * @memberof ItemAnimate.prototype\r\n   */\r\n  _onFinish() {\r\n    const callback = this._callback;\r\n    this._animation = this._callback = null;\r\n    this._props.length = this._values.length = 0;\r\n    callback && callback();\r\n  }\r\n}\r\n\r\nexport default ItemAnimate;\r\n","/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n(function(window, document, exportName, undefined) {\n  'use strict';\n\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = document.createElement('div');\n\nvar TYPE_FUNCTION = 'function';\n\nvar round = Math.round;\nvar abs = Math.abs;\nvar now = Date.now;\n\n/**\n * set a timeout with a given scope\n * @param {Function} fn\n * @param {Number} timeout\n * @param {Object} context\n * @returns {number}\n */\nfunction setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n}\n\n/**\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\nfunction invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n        each(arg, context[fn], context);\n        return true;\n    }\n    return false;\n}\n\n/**\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n        return;\n    }\n\n    if (obj.forEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n        i = 0;\n        while (i < obj.length) {\n            iterator.call(context, obj[i], i, obj);\n            i++;\n        }\n    } else {\n        for (i in obj) {\n            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n        }\n    }\n}\n\n/**\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nfunction deprecate(method, name, message) {\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n    return function() {\n        var e = new Error('get-stack-trace');\n        var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '')\n            .replace(/^\\s+at\\s+/gm, '')\n            .replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n\n        var log = window.console && (window.console.warn || window.console.log);\n        if (log) {\n            log.call(window.console, deprecationMessage, stack);\n        }\n        return method.apply(this, arguments);\n    };\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nvar assign;\nif (typeof Object.assign !== 'function') {\n    assign = function assign(target) {\n        if (target === undefined || target === null) {\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        var output = Object(target);\n        for (var index = 1; index < arguments.length; index++) {\n            var source = arguments[index];\n            if (source !== undefined && source !== null) {\n                for (var nextKey in source) {\n                    if (source.hasOwnProperty(nextKey)) {\n                        output[nextKey] = source[nextKey];\n                    }\n                }\n            }\n        }\n        return output;\n    };\n} else {\n    assign = Object.assign;\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\nvar extend = deprecate(function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n    while (i < keys.length) {\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\n            dest[keys[i]] = src[keys[i]];\n        }\n        i++;\n    }\n    return dest;\n}, 'extend', 'Use `assign`.');\n\n/**\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\nvar merge = deprecate(function merge(dest, src) {\n    return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\n/**\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\nfunction inherit(child, base, properties) {\n    var baseP = base.prototype,\n        childP;\n\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n        assign(childP, properties);\n    }\n}\n\n/**\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n    return function boundFn() {\n        return fn.apply(context, arguments);\n    };\n}\n\n/**\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\nfunction boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n        return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n    return val;\n}\n\n/**\n * use the val2 when val1 is undefined\n * @param {*} val1\n * @param {*} val2\n * @returns {*}\n */\nfunction ifUndefined(val1, val2) {\n    return (val1 === undefined) ? val2 : val1;\n}\n\n/**\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction addEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.addEventListener(type, handler, false);\n    });\n}\n\n/**\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction removeEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.removeEventListener(type, handler, false);\n    });\n}\n\n/**\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n    while (node) {\n        if (node == parent) {\n            return true;\n        }\n        node = node.parentNode;\n    }\n    return false;\n}\n\n/**\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n    return str.indexOf(find) > -1;\n}\n\n/**\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n    return str.trim().split(/\\s+/g);\n}\n\n/**\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n        return src.indexOf(find);\n    } else {\n        var i = 0;\n        while (i < src.length) {\n            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\n                return i;\n            }\n            i++;\n        }\n        return -1;\n    }\n}\n\n/**\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\nfunction uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n        var val = key ? src[i][key] : src[i];\n        if (inArray(values, val) < 0) {\n            results.push(src[i]);\n        }\n        values[i] = val;\n        i++;\n    }\n\n    if (sort) {\n        if (!key) {\n            results = results.sort();\n        } else {\n            results = results.sort(function sortUniqueArray(a, b) {\n                return a[key] > b[key];\n            });\n        }\n    }\n\n    return results;\n}\n\n/**\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\nfunction prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n\n    var i = 0;\n    while (i < VENDOR_PREFIXES.length) {\n        prefix = VENDOR_PREFIXES[i];\n        prop = (prefix) ? prefix + camelProp : property;\n\n        if (prop in obj) {\n            return prop;\n        }\n        i++;\n    }\n    return undefined;\n}\n\n/**\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n    return _uniqueId++;\n}\n\n/**\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return (doc.defaultView || doc.parentWindow || window);\n}\n\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\nvar SUPPORT_TOUCH = ('ontouchstart' in window);\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\n\nvar COMPUTE_INTERVAL = 25;\n\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\n\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\n\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\nfunction Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function(ev) {\n        if (boolOrFn(manager.options.enable, [manager])) {\n            self.handler(ev);\n        }\n    };\n\n    this.init();\n\n}\n\nInput.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function() { },\n\n    /**\n     * bind the events\n     */\n    init: function() {\n        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function() {\n        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n};\n\n/**\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\nfunction createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n        Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n        Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n        Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n        Type = MouseInput;\n    } else {\n        Type = TouchMouseInput;\n    }\n    return new (Type)(manager, inputHandler);\n}\n\n/**\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\nfunction inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n\n    if (isFirst) {\n        manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit('hammer.input', input);\n\n    manager.recognize(input);\n    manager.session.prevInput = input;\n}\n\n/**\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\nfunction computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n        session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength > 1 && !session.firstMultiple) {\n        session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n        session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\n\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\n        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\n\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n        target = input.srcEvent.target;\n    }\n    input.target = target;\n}\n\nfunction computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n        prevDelta = session.prevDelta = {\n            x: prevInput.deltaX || 0,\n            y: prevInput.deltaY || 0\n        };\n\n        offset = session.offsetDelta = {\n            x: center.x,\n            y: center.y\n        };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\nfunction computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n        deltaTime = input.timeStamp - last.timeStamp,\n        velocity, velocityX, velocityY, direction;\n\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n        var deltaX = input.deltaX - last.deltaX;\n        var deltaY = input.deltaY - last.deltaY;\n\n        var v = getVelocity(deltaTime, deltaX, deltaY);\n        velocityX = v.x;\n        velocityY = v.y;\n        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n        direction = getDirection(deltaX, deltaY);\n\n        session.lastInterval = input;\n    } else {\n        // use latest velocity info if it doesn't overtake a minimum period\n        velocity = last.velocity;\n        velocityX = last.velocityX;\n        velocityY = last.velocityY;\n        direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n}\n\n/**\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\nfunction simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n        pointers[i] = {\n            clientX: round(input.pointers[i].clientX),\n            clientY: round(input.pointers[i].clientY)\n        };\n        i++;\n    }\n\n    return {\n        timeStamp: now(),\n        pointers: pointers,\n        center: getCenter(pointers),\n        deltaX: input.deltaX,\n        deltaY: input.deltaY\n    };\n}\n\n/**\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\nfunction getCenter(pointers) {\n    var pointersLength = pointers.length;\n\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n        return {\n            x: round(pointers[0].clientX),\n            y: round(pointers[0].clientY)\n        };\n    }\n\n    var x = 0, y = 0, i = 0;\n    while (i < pointersLength) {\n        x += pointers[i].clientX;\n        y += pointers[i].clientY;\n        i++;\n    }\n\n    return {\n        x: round(x / pointersLength),\n        y: round(y / pointersLength)\n    };\n}\n\n/**\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n    return {\n        x: x / deltaTime || 0,\n        y: y / deltaTime || 0\n    };\n}\n\n/**\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\nfunction getDirection(x, y) {\n    if (x === y) {\n        return DIRECTION_NONE;\n    }\n\n    if (abs(x) >= abs(y)) {\n        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\n/**\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\nfunction getDistance(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n\n    return Math.sqrt((x * x) + (y * y));\n}\n\n/**\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\nfunction getAngle(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\nfunction getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\nfunction getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\nvar MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n};\n\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n/**\n * Mouse events input\n * @constructor\n * @extends Input\n */\nfunction MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n}\n\ninherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n        var eventType = MOUSE_INPUT_MAP[ev.type];\n\n        // on start we want to have the left mouse button down\n        if (eventType & INPUT_START && ev.button === 0) {\n            this.pressed = true;\n        }\n\n        if (eventType & INPUT_MOVE && ev.which !== 1) {\n            eventType = INPUT_END;\n        }\n\n        // mouse must be down\n        if (!this.pressed) {\n            return;\n        }\n\n        if (eventType & INPUT_END) {\n            this.pressed = false;\n        }\n\n        this.callback(this.manager, eventType, {\n            pointers: [ev],\n            changedPointers: [ev],\n            pointerType: INPUT_TYPE_MOUSE,\n            srcEvent: ev\n        });\n    }\n});\n\nvar POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n};\n\n// in IE10 the pointer types is defined as an enum\nvar IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n};\n\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n// IE10 has prefixed support, and case-sensitive\nif (window.MSPointerEvent && !window.PointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n\n/**\n * Pointer events input\n * @constructor\n * @extends Input\n */\nfunction PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n\n    Input.apply(this, arguments);\n\n    this.store = (this.manager.session.pointerEvents = []);\n}\n\ninherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n        var store = this.store;\n        var removePointer = false;\n\n        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n        var isTouch = (pointerType == INPUT_TYPE_TOUCH);\n\n        // get index of the event in the store\n        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n        // start and mouse must be down\n        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n            if (storeIndex < 0) {\n                store.push(ev);\n                storeIndex = store.length - 1;\n            }\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n            removePointer = true;\n        }\n\n        // it not found, so the pointer hasn't been down (so it's probably a hover)\n        if (storeIndex < 0) {\n            return;\n        }\n\n        // update the event in the store\n        store[storeIndex] = ev;\n\n        this.callback(this.manager, eventType, {\n            pointers: store,\n            changedPointers: [ev],\n            pointerType: pointerType,\n            srcEvent: ev\n        });\n\n        if (removePointer) {\n            // remove from the store\n            store.splice(storeIndex, 1);\n        }\n    }\n});\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Touch events input\n * @constructor\n * @extends Input\n */\nfunction SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n\n    Input.apply(this, arguments);\n}\n\ninherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n        // should we handle the touch events?\n        if (type === INPUT_START) {\n            this.started = true;\n        }\n\n        if (!this.started) {\n            return;\n        }\n\n        var touches = normalizeSingleTouches.call(this, ev, type);\n\n        // when done, reset the started state\n        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n            this.started = false;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n        all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n\n    return [all, changed];\n}\n\nvar TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\nfunction TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n\n    Input.apply(this, arguments);\n}\n\ninherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n        var type = TOUCH_INPUT_MAP[ev.type];\n        var touches = getTouches.call(this, ev, type);\n        if (!touches) {\n            return;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds;\n\n    // when there is only one touch, the process can be simplified\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n        targetIds[allTouches[0].identifier] = true;\n        return [allTouches, allTouches];\n    }\n\n    var i,\n        targetTouches,\n        changedTouches = toArray(ev.changedTouches),\n        changedTargetTouches = [],\n        target = this.target;\n\n    // get target touches from touches\n    targetTouches = allTouches.filter(function(touch) {\n        return hasParent(touch.target, target);\n    });\n\n    // collect touches\n    if (type === INPUT_START) {\n        i = 0;\n        while (i < targetTouches.length) {\n            targetIds[targetTouches[i].identifier] = true;\n            i++;\n        }\n    }\n\n    // filter changed touches to only contain touches that exist in the collected target ids\n    i = 0;\n    while (i < changedTouches.length) {\n        if (targetIds[changedTouches[i].identifier]) {\n            changedTargetTouches.push(changedTouches[i]);\n        }\n\n        // cleanup removed touches\n        if (type & (INPUT_END | INPUT_CANCEL)) {\n            delete targetIds[changedTouches[i].identifier];\n        }\n        i++;\n    }\n\n    if (!changedTargetTouches.length) {\n        return;\n    }\n\n    return [\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n        changedTargetTouches\n    ];\n}\n\n/**\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\n\nfunction TouchMouseInput() {\n    Input.apply(this, arguments);\n\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n\n    this.primaryTouch = null;\n    this.lastTouches = [];\n}\n\ninherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\n            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\n\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n            return;\n        }\n\n        // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n        if (isTouch) {\n            recordTouches.call(this, inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n            return;\n        }\n\n        this.callback(manager, inputEvent, inputData);\n    },\n\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n        this.touch.destroy();\n        this.mouse.destroy();\n    }\n});\n\nfunction recordTouches(eventType, eventData) {\n    if (eventType & INPUT_START) {\n        this.primaryTouch = eventData.changedPointers[0].identifier;\n        setLastTouch.call(this, eventData);\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        setLastTouch.call(this, eventData);\n    }\n}\n\nfunction setLastTouch(eventData) {\n    var touch = eventData.changedPointers[0];\n\n    if (touch.identifier === this.primaryTouch) {\n        var lastTouch = {x: touch.clientX, y: touch.clientY};\n        this.lastTouches.push(lastTouch);\n        var lts = this.lastTouches;\n        var removeLastTouch = function() {\n            var i = lts.indexOf(lastTouch);\n            if (i > -1) {\n                lts.splice(i, 1);\n            }\n        };\n        setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    }\n}\n\nfunction isSyntheticEvent(eventData) {\n    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;\n    for (var i = 0; i < this.lastTouches.length; i++) {\n        var t = this.lastTouches[i];\n        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);\n        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n// magical touchAction value\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\n\n/**\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\nfunction TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n}\n\nTouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function(value) {\n        // find out the touch-action by the event handlers\n        if (value == TOUCH_ACTION_COMPUTE) {\n            value = this.compute();\n        }\n\n        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n        }\n        this.actions = value.toLowerCase().trim();\n    },\n\n    /**\n     * just re-set the touchAction value\n     */\n    update: function() {\n        this.set(this.manager.options.touchAction);\n    },\n\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function() {\n        var actions = [];\n        each(this.manager.recognizers, function(recognizer) {\n            if (boolOrFn(recognizer.options.enable, [recognizer])) {\n                actions = actions.concat(recognizer.getTouchAction());\n            }\n        });\n        return cleanTouchActions(actions.join(' '));\n    },\n\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function(input) {\n        var srcEvent = input.srcEvent;\n        var direction = input.offsetDirection;\n\n        // if the touch action did prevented once this session\n        if (this.manager.session.prevented) {\n            srcEvent.preventDefault();\n            return;\n        }\n\n        var actions = this.actions;\n        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n        if (hasNone) {\n            //do not prevent defaults if this is a tap gesture\n\n            var isTapPointer = input.pointers.length === 1;\n            var isTapMovement = input.distance < 2;\n            var isTapTouchTime = input.deltaTime < 250;\n\n            if (isTapPointer && isTapMovement && isTapTouchTime) {\n                return;\n            }\n        }\n\n        if (hasPanX && hasPanY) {\n            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n            return;\n        }\n\n        if (hasNone ||\n            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n            (hasPanX && direction & DIRECTION_VERTICAL)) {\n            return this.preventSrc(srcEvent);\n        }\n    },\n\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function(srcEvent) {\n        this.manager.session.prevented = true;\n        srcEvent.preventDefault();\n    }\n};\n\n/**\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\nfunction cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n    // if both pan-x and pan-y are set (different recognizers\n    // for different directions, e.g. horizontal pan but vertical swipe?)\n    // we need none (as otherwise with pan-x pan-y combined none of these\n    // recognizers will work, since the browser would handle all panning\n    if (hasPanX && hasPanY) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    // pan-x OR pan-y\n    if (hasPanX || hasPanY) {\n        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    }\n\n    // manipulation\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n        return TOUCH_ACTION_MANIPULATION;\n    }\n\n    return TOUCH_ACTION_AUTO;\n}\n\nfunction getTouchActionProps() {\n    if (!NATIVE_TOUCH_ACTION) {\n        return false;\n    }\n    var touchMap = {};\n    var cssSupports = window.CSS && window.CSS.supports;\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {\n\n        // If css.supports is not supported but there is native touch-action assume it supports\n        // all values. This is the case for IE 10 and 11.\n        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n    });\n    return touchMap;\n}\n\n/**\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\nfunction Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n\n    this.id = uniqueId();\n\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n\n    this.state = STATE_POSSIBLE;\n\n    this.simultaneous = {};\n    this.requireFail = [];\n}\n\nRecognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // also update the touchAction, in case something changed about the directions/enabled state\n        this.manager && this.manager.touchAction.update();\n        return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n            return this;\n        }\n\n        var simultaneous = this.simultaneous;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (!simultaneous[otherRecognizer.id]) {\n            simultaneous[otherRecognizer.id] = otherRecognizer;\n            otherRecognizer.recognizeWith(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        delete this.simultaneous[otherRecognizer.id];\n        return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n            return this;\n        }\n\n        var requireFail = this.requireFail;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (inArray(requireFail, otherRecognizer) === -1) {\n            requireFail.push(otherRecognizer);\n            otherRecognizer.requireFailure(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        var index = inArray(this.requireFail, otherRecognizer);\n        if (index > -1) {\n            this.requireFail.splice(index, 1);\n        }\n        return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function() {\n        return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function(otherRecognizer) {\n        return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function(input) {\n        var self = this;\n        var state = this.state;\n\n        function emit(event) {\n            self.manager.emit(event, input);\n        }\n\n        // 'panstart' and 'panmove'\n        if (state < STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n\n        emit(self.options.event); // simple 'eventName' events\n\n        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\n            emit(input.additionalEvent);\n        }\n\n        // panend and pancancel\n        if (state >= STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function(input) {\n        if (this.canEmit()) {\n            return this.emit(input);\n        }\n        // it's failing anyway\n        this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function() {\n        var i = 0;\n        while (i < this.requireFail.length) {\n            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        // make a new copy of the inputData\n        // so we can change the inputData without messing up the other recognizers\n        var inputDataClone = assign({}, inputData);\n\n        // is is enabled and allow recognizing?\n        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n            this.reset();\n            this.state = STATE_FAILED;\n            return;\n        }\n\n        // reset when we've reached the end\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n            this.state = STATE_POSSIBLE;\n        }\n\n        this.state = this.process(inputDataClone);\n\n        // the recognizer has recognized a gesture\n        // so trigger an event\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n            this.tryEmit(inputDataClone);\n        }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function(inputData) { }, // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function() { },\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function() { }\n};\n\n/**\n * get a usable string, used as event postfix\n * @param {Const} state\n * @returns {String} state\n */\nfunction stateStr(state) {\n    if (state & STATE_CANCELLED) {\n        return 'cancel';\n    } else if (state & STATE_ENDED) {\n        return 'end';\n    } else if (state & STATE_CHANGED) {\n        return 'move';\n    } else if (state & STATE_BEGAN) {\n        return 'start';\n    }\n    return '';\n}\n\n/**\n * direction cons to string\n * @param {Const} direction\n * @returns {String}\n */\nfunction directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n        return 'down';\n    } else if (direction == DIRECTION_UP) {\n        return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n        return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n        return 'right';\n    }\n    return '';\n}\n\n/**\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n        return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n}\n\n/**\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\nfunction AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n}\n\ninherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n        /**\n         * @type {Number}\n         * @default 1\n         */\n        pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function(input) {\n        var optionPointers = this.options.pointers;\n        return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function(input) {\n        var state = this.state;\n        var eventType = input.eventType;\n\n        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n        var isValid = this.attrTest(input);\n\n        // on cancel input and we've recognized before, return STATE_CANCELLED\n        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n            return state | STATE_CANCELLED;\n        } else if (isRecognized || isValid) {\n            if (eventType & INPUT_END) {\n                return state | STATE_ENDED;\n            } else if (!(state & STATE_BEGAN)) {\n                return STATE_BEGAN;\n            }\n            return state | STATE_CHANGED;\n        }\n        return STATE_FAILED;\n    }\n});\n\n/**\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n\n    this.pX = null;\n    this.pY = null;\n}\n\ninherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n        event: 'pan',\n        threshold: 10,\n        pointers: 1,\n        direction: DIRECTION_ALL\n    },\n\n    getTouchAction: function() {\n        var direction = this.options.direction;\n        var actions = [];\n        if (direction & DIRECTION_HORIZONTAL) {\n            actions.push(TOUCH_ACTION_PAN_Y);\n        }\n        if (direction & DIRECTION_VERTICAL) {\n            actions.push(TOUCH_ACTION_PAN_X);\n        }\n        return actions;\n    },\n\n    directionTest: function(input) {\n        var options = this.options;\n        var hasMoved = true;\n        var distance = input.distance;\n        var direction = input.direction;\n        var x = input.deltaX;\n        var y = input.deltaY;\n\n        // lock to axis?\n        if (!(direction & options.direction)) {\n            if (options.direction & DIRECTION_HORIZONTAL) {\n                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n                hasMoved = x != this.pX;\n                distance = Math.abs(input.deltaX);\n            } else {\n                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n                hasMoved = y != this.pY;\n                distance = Math.abs(input.deltaY);\n            }\n        }\n        input.direction = direction;\n        return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n\n    attrTest: function(input) {\n        return AttrRecognizer.prototype.attrTest.call(this, input) &&\n            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n    },\n\n    emit: function(input) {\n\n        this.pX = input.deltaX;\n        this.pY = input.deltaY;\n\n        var direction = directionStr(input.direction);\n\n        if (direction) {\n            input.additionalEvent = this.options.event + direction;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'pinch',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n\n    emit: function(input) {\n        if (input.scale !== 1) {\n            var inOut = input.scale < 1 ? 'in' : 'out';\n            input.additionalEvent = this.options.event + inOut;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\nfunction PressRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    this._timer = null;\n    this._input = null;\n}\n\ninherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n        event: 'press',\n        pointers: 1,\n        time: 251, // minimal time of the pointer to be pressed\n        threshold: 9 // a minimal movement is ok, but keep it low\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_AUTO];\n    },\n\n    process: function(input) {\n        var options = this.options;\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTime = input.deltaTime > options.time;\n\n        this._input = input;\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n            this.reset();\n        } else if (input.eventType & INPUT_START) {\n            this.reset();\n            this._timer = setTimeoutContext(function() {\n                this.state = STATE_RECOGNIZED;\n                this.tryEmit();\n            }, options.time, this);\n        } else if (input.eventType & INPUT_END) {\n            return STATE_RECOGNIZED;\n        }\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function(input) {\n        if (this.state !== STATE_RECOGNIZED) {\n            return;\n        }\n\n        if (input && (input.eventType & INPUT_END)) {\n            this.manager.emit(this.options.event + 'up', input);\n        } else {\n            this._input.timeStamp = now();\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n        event: 'rotate',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n});\n\n/**\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n        event: 'swipe',\n        threshold: 10,\n        velocity: 0.3,\n        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n        pointers: 1\n    },\n\n    getTouchAction: function() {\n        return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n\n    attrTest: function(input) {\n        var direction = this.options.direction;\n        var velocity;\n\n        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n            velocity = input.overallVelocity;\n        } else if (direction & DIRECTION_HORIZONTAL) {\n            velocity = input.overallVelocityX;\n        } else if (direction & DIRECTION_VERTICAL) {\n            velocity = input.overallVelocityY;\n        }\n\n        return this._super.attrTest.call(this, input) &&\n            direction & input.offsetDirection &&\n            input.distance > this.options.threshold &&\n            input.maxPointers == this.options.pointers &&\n            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n\n    emit: function(input) {\n        var direction = directionStr(input.offsetDirection);\n        if (direction) {\n            this.manager.emit(this.options.event + direction, input);\n        }\n\n        this.manager.emit(this.options.event, input);\n    }\n});\n\n/**\n * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\nfunction TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n}\n\ninherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'tap',\n        pointers: 1,\n        taps: 1,\n        interval: 300, // max time between the multi-tap taps\n        time: 250, // max time of the pointer to be down (like finger on the screen)\n        threshold: 9, // a minimal movement is ok, but keep it low\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_MANIPULATION];\n    },\n\n    process: function(input) {\n        var options = this.options;\n\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTouchTime = input.deltaTime < options.time;\n\n        this.reset();\n\n        if ((input.eventType & INPUT_START) && (this.count === 0)) {\n            return this.failTimeout();\n        }\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (validMovement && validTouchTime && validPointers) {\n            if (input.eventType != INPUT_END) {\n                return this.failTimeout();\n            }\n\n            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n            this.pTime = input.timeStamp;\n            this.pCenter = input.center;\n\n            if (!validMultiTap || !validInterval) {\n                this.count = 1;\n            } else {\n                this.count += 1;\n            }\n\n            this._input = input;\n\n            // if tap count matches we have recognized it,\n            // else it has began recognizing...\n            var tapCount = this.count % options.taps;\n            if (tapCount === 0) {\n                // no failing requirements, immediately trigger the tap event\n                // or wait as long as the multitap interval to trigger\n                if (!this.hasRequireFailures()) {\n                    return STATE_RECOGNIZED;\n                } else {\n                    this._timer = setTimeoutContext(function() {\n                        this.state = STATE_RECOGNIZED;\n                        this.tryEmit();\n                    }, options.interval, this);\n                    return STATE_BEGAN;\n                }\n            }\n        }\n        return STATE_FAILED;\n    },\n\n    failTimeout: function() {\n        this._timer = setTimeoutContext(function() {\n            this.state = STATE_FAILED;\n        }, this.options.interval, this);\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function() {\n        if (this.state == STATE_RECOGNIZED) {\n            this._input.tapCount = this.count;\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n}\n\n/**\n * @const {string}\n */\nHammer.VERSION = '2.0.7';\n\n/**\n * default settings\n * @namespace\n */\nHammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n        [RotateRecognizer, {enable: false}],\n        [PinchRecognizer, {enable: false}, ['rotate']],\n        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],\n        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],\n        [TapRecognizer],\n        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],\n        [PressRecognizer]\n    ],\n\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n        /**\n         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userSelect: 'none',\n\n        /**\n         * Disable the Windows Phone grippers when pressing an element.\n         * @type {String}\n         * @default 'none'\n         */\n        touchSelect: 'none',\n\n        /**\n         * Disables the default callout shown when you touch and hold a touch target.\n         * On iOS, when you touch and hold a touch target such as a link, Safari displays\n         * a callout containing information about the link. This property allows you to disable that callout.\n         * @type {String}\n         * @default 'none'\n         */\n        touchCallout: 'none',\n\n        /**\n         * Specifies whether zooming is enabled. Used by IE10>\n         * @type {String}\n         * @default 'none'\n         */\n        contentZooming: 'none',\n\n        /**\n         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userDrag: 'none',\n\n        /**\n         * Overrides the highlight color shown when the user taps a link or a JavaScript\n         * clickable element in iOS. This property obeys the alpha value, if specified.\n         * @type {String}\n         * @default 'rgba(0,0,0,0)'\n         */\n        tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n};\n\nvar STOP = 1;\nvar FORCED_STOP = 2;\n\n/**\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n\n    this.options.inputTarget = this.options.inputTarget || element;\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    toggleCssProps(this, true);\n\n    each(this.options.recognizers, function(item) {\n        var recognizer = this.add(new (item[0])(item[1]));\n        item[2] && recognizer.recognizeWith(item[2]);\n        item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n}\n\nManager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // Options that need a little more setup\n        if (options.touchAction) {\n            this.touchAction.update();\n        }\n        if (options.inputTarget) {\n            // Clean up existing event listeners and reinitialize\n            this.input.destroy();\n            this.input.target = options.inputTarget;\n            this.input.init();\n        }\n        return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function(force) {\n        this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        var session = this.session;\n        if (session.stopped) {\n            return;\n        }\n\n        // run the touch-action polyfill\n        this.touchAction.preventDefaults(inputData);\n\n        var recognizer;\n        var recognizers = this.recognizers;\n\n        // this holds the recognizer that is being recognized.\n        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n        // if no recognizer is detecting a thing, it is set to `null`\n        var curRecognizer = session.curRecognizer;\n\n        // reset when the last recognizer is recognized\n        // or when we're in a new session\n        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n            curRecognizer = session.curRecognizer = null;\n        }\n\n        var i = 0;\n        while (i < recognizers.length) {\n            recognizer = recognizers[i];\n\n            // find out if we are allowed try to recognize the input for this one.\n            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n            //      that is being recognized.\n            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n            //      this can be setup with the `recognizeWith()` method on the recognizer.\n            if (session.stopped !== FORCED_STOP && ( // 1\n                    !curRecognizer || recognizer == curRecognizer || // 2\n                    recognizer.canRecognizeWith(curRecognizer))) { // 3\n                recognizer.recognize(inputData);\n            } else {\n                recognizer.reset();\n            }\n\n            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n            // current active recognizer. but only if we don't already have an active recognizer\n            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n                curRecognizer = session.curRecognizer = recognizer;\n            }\n            i++;\n        }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function(recognizer) {\n        if (recognizer instanceof Recognizer) {\n            return recognizer;\n        }\n\n        var recognizers = this.recognizers;\n        for (var i = 0; i < recognizers.length; i++) {\n            if (recognizers[i].options.event == recognizer) {\n                return recognizers[i];\n            }\n        }\n        return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'add', this)) {\n            return this;\n        }\n\n        // remove existing\n        var existing = this.get(recognizer.options.event);\n        if (existing) {\n            this.remove(existing);\n        }\n\n        this.recognizers.push(recognizer);\n        recognizer.manager = this;\n\n        this.touchAction.update();\n        return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'remove', this)) {\n            return this;\n        }\n\n        recognizer = this.get(recognizer);\n\n        // let's make sure this recognizer exists\n        if (recognizer) {\n            var recognizers = this.recognizers;\n            var index = inArray(recognizers, recognizer);\n\n            if (index !== -1) {\n                recognizers.splice(index, 1);\n                this.touchAction.update();\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n        if (handler === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            handlers[event] = handlers[event] || [];\n            handlers[event].push(handler);\n        });\n        return this;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            if (!handler) {\n                delete handlers[event];\n            } else {\n                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n            }\n        });\n        return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function(event, data) {\n        // we also want to trigger dom events\n        if (this.options.domEvents) {\n            triggerDomEvent(event, data);\n        }\n\n        // no handlers, so skip it all\n        var handlers = this.handlers[event] && this.handlers[event].slice();\n        if (!handlers || !handlers.length) {\n            return;\n        }\n\n        data.type = event;\n        data.preventDefault = function() {\n            data.srcEvent.preventDefault();\n        };\n\n        var i = 0;\n        while (i < handlers.length) {\n            handlers[i](data);\n            i++;\n        }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function() {\n        this.element && toggleCssProps(this, false);\n\n        this.handlers = {};\n        this.session = {};\n        this.input.destroy();\n        this.element = null;\n    }\n};\n\n/**\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\nfunction toggleCssProps(manager, add) {\n    var element = manager.element;\n    if (!element.style) {\n        return;\n    }\n    var prop;\n    each(manager.options.cssProps, function(value, name) {\n        prop = prefixed(element.style, name);\n        if (add) {\n            manager.oldCssProps[prop] = element.style[prop];\n            element.style[prop] = value;\n        } else {\n            element.style[prop] = manager.oldCssProps[prop] || '';\n        }\n    });\n    if (!add) {\n        manager.oldCssProps = {};\n    }\n}\n\n/**\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\nfunction triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n}\n\nassign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n});\n\n// this prevents errors when Hammer is loaded in the presence of an AMD\n//  style loader but by script tag, not by the loader.\nvar freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line\nfreeGlobal.Hammer = Hammer;\n\nif (typeof define === 'function' && define.amd) {\n    define(function() {\n        return Hammer;\n    });\n} else if (typeof module != 'undefined' && module.exports) {\n    module.exports = Hammer;\n} else {\n    window[exportName] = Hammer;\n}\n\n})(window, document, 'Hammer');\n","/**\r\n * Muuri Ticker\r\n * Copyright (c) 2018-present, Niklas Rämö <inramo@gmail.com>\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/src/Ticker/LICENSE.md\r\n */\r\n\r\nimport { Component } from 'react';\r\n\r\nfunction rafFallback(cb) {\r\n  return window.setTimeout(cb, 16);\r\n}\r\n\r\nconst raf = (\r\n  window.requestAnimationFrame ||\r\n  window.webkitRequestAnimationFrame ||\r\n  window.mozRequestAnimationFrame ||\r\n  window.msRequestAnimationFrame ||\r\n  rafFallback\r\n).bind(window);\r\n\r\n/**\r\n * A ticker system for handling DOM reads and writes in an efficient way.\r\n * Contains a read queue and a write queue that are processed on the next\r\n * animation frame when needed.\r\n *\r\n * @class\r\n */\r\nclass Ticker extends Component {\r\n  constructor() {\r\n    super();\r\n    this._nextTick = null;\r\n\r\n    this._queue = [];\r\n    this._reads = {};\r\n    this._writes = {};\r\n\r\n    this._batch = [];\r\n    this._batchReads = {};\r\n    this._batchWrites = {};\r\n\r\n    this._flush = this._flush.bind(this);\r\n  }\r\n\r\n  add(id, readCallback, writeCallback, isImportant) {\r\n    // First, let's check if an item has been added to the queues with the same id\r\n    // and if so -> remove it.\r\n    const currentIndex = this._queue.indexOf(id);\r\n    if (currentIndex > -1) this._queue[currentIndex] = undefined;\r\n\r\n    // Add all important callbacks to the beginning of the queue and other\r\n    // callbacks to the end of the queue.\r\n    isImportant ? this._queue.unshift(id) : this._queue.push(id);\r\n\r\n    // Store callbacks.\r\n    this._reads[id] = readCallback;\r\n    this._writes[id] = writeCallback;\r\n\r\n    // Finally, let's kick-start the next tick if it is not running yet.\r\n    if (!this._nextTick) this._nextTick = raf(this._flush);\r\n  }\r\n\r\n  cancel(id) {\r\n    const currentIndex = this._queue.indexOf(id);\r\n    if (currentIndex > -1) {\r\n      this._queue[currentIndex] = undefined;\r\n      this._reads[id] = undefined;\r\n      this._writes[id] = undefined;\r\n    }\r\n  }\r\n\r\n  _flush() {\r\n    const queue = this._queue;\r\n    const reads = this._reads;\r\n    const writes = this._writes;\r\n    const batch = this._batch;\r\n    const batchReads = this._batchReads;\r\n    const batchWrites = this._batchWrites;\r\n    const length = queue.length;\r\n    let id;\r\n    let i;\r\n\r\n    // Reset ticker.\r\n    this._nextTick = null;\r\n\r\n    // Setup queues and callback placeholders.\r\n    for (i = 0; i < length; i++) {\r\n      id = queue[i];\r\n      if (!id) continue;\r\n\r\n      batch.push(id);\r\n\r\n      batchReads[id] = reads[id];\r\n      reads[id] = undefined;\r\n\r\n      batchWrites[id] = writes[id];\r\n      writes[id] = undefined;\r\n    }\r\n\r\n    // Reset queue.\r\n    queue.length = 0;\r\n\r\n    // Process read callbacks.\r\n    for (i = 0; i < length; i++) {\r\n      id = batch[i];\r\n      if (batchReads[id]) {\r\n        batchReads[id]();\r\n        batchReads[id] = undefined;\r\n      }\r\n    }\r\n\r\n    // Process write callbacks.\r\n    for (i = 0; i < length; i++) {\r\n      id = batch[i];\r\n      if (batchWrites[id]) {\r\n        batchWrites[id]();\r\n        batchWrites[id] = undefined;\r\n      }\r\n    }\r\n\r\n    // Reset batch.\r\n    batch.length = 0;\r\n\r\n    // Restart the ticker if needed.\r\n    if (!this._nextTick && queue.length) {\r\n      this._nextTick = raf(this._flush);\r\n    }\r\n  }\r\n}\r\n\r\nexport default Ticker;\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\nimport Ticker from './Ticker/Ticker.js';\r\n\r\nconst ticker = new Ticker();\r\n\r\nconst layoutTick = 'layout';\r\nconst visibilityTick = 'visibility';\r\nconst moveTick = 'move';\r\nconst scrollTick = 'scroll';\r\n\r\nexport default ticker;\r\n\r\nexport function addLayoutTick(itemId, readCallback, writeCallback) {\r\n  return ticker.add(itemId + layoutTick, readCallback, writeCallback);\r\n};\r\n\r\nexport function cancelLayoutTick(itemId) {\r\n  return ticker.cancel(itemId + layoutTick);\r\n};\r\n\r\nexport function addVisibilityTick(itemId, readCallback, writeCallback) {\r\n  return ticker.add(itemId + visibilityTick, readCallback, writeCallback);\r\n};\r\n\r\nexport function cancelVisibilityTick(itemId) {\r\n  return ticker.cancel(itemId + visibilityTick);\r\n};\r\n\r\nexport function addMoveTick(itemId, readCallback, writeCallback) {\r\n  return ticker.add(itemId + moveTick, readCallback, writeCallback, true);\r\n};\r\n\r\nexport function cancelMoveTick(itemId) {\r\n  return ticker.cancel(itemId + moveTick);\r\n};\r\n\r\nexport function addScrollTick(itemId, readCallback, writeCallback) {\r\n  return ticker.add(itemId + scrollTick, readCallback, writeCallback, true);\r\n};\r\n\r\nexport function cancelScrollTick(itemId) {\r\n  return ticker.cancel(itemId + scrollTick);\r\n};\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\nconst proto = Element.prototype;\r\nconst matches =\r\n  proto.matches ||\r\n  proto.matchesSelector ||\r\n  proto.webkitMatchesSelector ||\r\n  proto.mozMatchesSelector ||\r\n  proto.msMatchesSelector ||\r\n  proto.oMatchesSelector;\r\n\r\n/**\r\n * Check if element matches a CSS selector.\r\n *\r\n * @param {*} val\r\n * @returns {Boolean}\r\n */\r\nexport default function elementMatches(el, selector) {\r\n  return matches.call(el, selector);\r\n}\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\nimport elementMatches from './elementMatches.js';\r\n\r\n/**\r\n * Add class to an element.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {String} className\r\n */\r\nfunction addClassModern(element, className) {\r\n  element.classList.add(className);\r\n}\r\n\r\n/**\r\n * Add class to an element (legacy version, for IE9 support).\r\n *\r\n * @param {HTMLElement} element\r\n * @param {String} className\r\n */\r\nfunction addClassLegacy(element, className) {\r\n  if (!elementMatches(element, `.${className}`)) {\r\n    element.className += ` ${className}`;\r\n  }\r\n}\r\n\r\nexport default ('classList' in Element.prototype ? addClassModern : addClassLegacy);\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\n/**\r\n * Normalize array index. Basically this function makes sure that the provided\r\n * array index is within the bounds of the provided array and also transforms\r\n * negative index to the matching positive index.\r\n *\r\n * @param {Array} array\r\n * @param {Number} index\r\n * @param {Boolean} isMigration\r\n */\r\nexport default function normalizeArrayIndex(array, index, isMigration) {\r\n  const length = array.length;\r\n  const maxIndex = Math.max(0, isMigration ? length : length - 1);\r\n  return index > maxIndex ? maxIndex : index < 0 ? Math.max(maxIndex + index + 1, 0) : index;\r\n}\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\nimport normalizeArrayIndex from './normalizeArrayIndex.js';\r\n\r\n/**\r\n * Move array item to another index.\r\n *\r\n * @param {Array} array\r\n * @param {Number} fromIndex\r\n *   - Index (positive or negative) of the item that will be moved.\r\n * @param {Number} toIndex\r\n *   - Index (positive or negative) where the item should be moved to.\r\n */\r\nexport default function arrayMove(array, fromIndex, toIndex) {\r\n  // Make sure the array has two or more items.\r\n  if (array.length < 2) return;\r\n\r\n  // Normalize the indices.\r\n  const from = normalizeArrayIndex(array, fromIndex);\r\n  const to = normalizeArrayIndex(array, toIndex);\r\n\r\n  // Add target item to the new position.\r\n  if (from !== to) {\r\n    array.splice(to, 0, array.splice(from, 1)[0]);\r\n  }\r\n}\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\nimport normalizeArrayIndex from './normalizeArrayIndex.js';\r\n\r\n/**\r\n * Swap array items.\r\n *\r\n * @param {Array} array\r\n * @param {Number} index\r\n *   - Index (positive or negative) of the item that will be swapped.\r\n * @param {Number} withIndex\r\n *   - Index (positive or negative) of the other item that will be swapped.\r\n */\r\nexport default function arraySwap(array, index, withIndex) {\r\n  // Make sure the array has two or more items.\r\n  if (array.length < 2) return;\r\n\r\n  // Normalize the indices.\r\n  const indexA = normalizeArrayIndex(array, index);\r\n  const indexB = normalizeArrayIndex(array, withIndex);\r\n  let temp;\r\n\r\n  // Swap the items.\r\n  if (indexA !== indexB) {\r\n    temp = array[indexA];\r\n    array[indexA] = array[indexB];\r\n    array[indexB] = temp;\r\n  }\r\n}\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\nconst actionCancel = 'cancel';\r\nconst actionFinish = 'finish';\r\n\r\n/**\r\n * Returns a function, that, as long as it continues to be invoked, will not\r\n * be triggered. The function will be called after it stops being called for\r\n * N milliseconds. The returned function accepts one argument which, when\r\n * being \"finish\", calls the debounce function immediately if it is currently\r\n * waiting to be called, and when being \"cancel\" cancels the currently queued\r\n * function call.\r\n *\r\n * @param {Function} fn\r\n * @param {Number} wait\r\n * @returns {Function}\r\n */\r\nexport default function debounce(fn, wait) {\r\n  let timeout;\r\n\r\n  if (wait > 0) {\r\n    return function(action) {\r\n      if (timeout !== undefined) {\r\n        timeout = window.clearTimeout(timeout);\r\n        if (action === actionFinish) fn();\r\n      }\r\n\r\n      if (action !== actionCancel && action !== actionFinish) {\r\n        timeout = window.setTimeout(function() {\r\n          timeout = undefined;\r\n          fn();\r\n        }, wait);\r\n      }\r\n    };\r\n  }\r\n\r\n  return function(action) {\r\n    if (action !== actionCancel) fn();\r\n  };\r\n}\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\nimport getStyle from './getStyle.js';\r\n\r\n/**\r\n * Returns true if element is transformed, false if not. In practice the\r\n * element's display value must be anything else than \"none\" or \"inline\" as\r\n * well as have a valid transform value applied in order to be counted as a\r\n * transformed element.\r\n *\r\n * Borrowed from Mezr (v0.6.1):\r\n * https://github.com/niklasramo/mezr/blob/0.6.1/mezr.js#L661\r\n *\r\n * @param {HTMLElement} element\r\n * @returns {Boolean}\r\n */\r\nexport default function isTransformed(element) {\r\n  const transform = getStyle(element, 'transform');\r\n  if (!transform || transform === 'none') return false;\r\n\r\n  const display = getStyle(element, 'display');\r\n  if (display === 'inline' || display === 'none') return false;\r\n\r\n  return true;\r\n}\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\nimport getStyle from './getStyle.js';\r\nimport isTransformed from './isTransformed';\r\n\r\n/**\r\n * Returns an absolute positioned element's containing block, which is\r\n * considered to be the closest ancestor element that the target element's\r\n * positioning is relative to. Disclaimer: this only works as intended for\r\n * absolute positioned elements.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {Boolean} [includeSelf=false]\r\n *   - When this is set to true the containing block checking is started from\r\n *     the provided element. Otherwise the checking is started from the\r\n *     provided element's parent element.\r\n * @returns {(Document|Element)}\r\n */\r\nexport default function getContainingBlock(element, includeSelf) {\r\n  // As long as the containing block is an element, static and not\r\n  // transformed, try to get the element's parent element and fallback to\r\n  // document. https://github.com/niklasramo/mezr/blob/0.6.1/mezr.js#L339\r\n  let ret = (includeSelf ? element : element.parentElement) || document;\r\n  while (ret && ret !== document && getStyle(ret, 'position') === 'static' && !isTransformed(ret)) {\r\n    ret = ret.parentElement || document;\r\n  }\r\n  return ret;\r\n}\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\nimport getStyle from './getStyle.js';\r\n\r\n/**\r\n * Returns the computed value of an element's style property transformed into\r\n * a float value.\r\n *\r\n * @param {HTMLElement} el\r\n * @param {String} style\r\n * @returns {Number}\r\n */\r\nexport default function getStyleAsFloat(el, style) {\r\n  return parseFloat(getStyle(el, style)) || 0;\r\n}\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\nimport getContainingBlock from './getContainingBlock.js';\r\nimport getStyleAsFloat from './getStyleAsFloat.js';\r\n\r\nconst offsetA = {};\r\nconst offsetB = {};\r\nconst offsetDiff = {};\r\n\r\n/**\r\n * Returns the element's document offset, which in practice means the vertical\r\n * and horizontal distance between the element's northwest corner and the\r\n * document's northwest corner. Note that this function always returns the same\r\n * object so be sure to read the data from it instead using it as a reference.\r\n *\r\n * @param {(Document|Element|Window)} element\r\n * @param {Object} [offsetData]\r\n *   - Optional data object where the offset data will be inserted to. If not\r\n *     provided a new object will be created for the return data.\r\n * @returns {Object}\r\n */\r\nfunction getOffset(element, offsetData) {\r\n  const ret = offsetData || {};\r\n  let rect;\r\n\r\n  // Set up return data.\r\n  ret.left = 0;\r\n  ret.top = 0;\r\n\r\n  // Document's offsets are always 0.\r\n  if (element === document) return ret;\r\n\r\n  // Add viewport scroll left/top to the respective offsets.\r\n  ret.left = window.pageXOffset || 0;\r\n  ret.top = window.pageYOffset || 0;\r\n\r\n  // Window's offsets are the viewport scroll left/top values.\r\n  if (element.self === window.self) return ret;\r\n\r\n  // Add element's client rects to the offsets.\r\n  rect = element.getBoundingClientRect();\r\n  ret.left += rect.left;\r\n  ret.top += rect.top;\r\n\r\n  // Exclude element's borders from the offset.\r\n  ret.left += getStyleAsFloat(element, 'border-left-width');\r\n  ret.top += getStyleAsFloat(element, 'border-top-width');\r\n\r\n  return ret;\r\n}\r\n\r\n/**\r\n * Calculate the offset difference two elements.\r\n *\r\n * @param {HTMLElement} elemA\r\n * @param {HTMLElement} elemB\r\n * @param {Boolean} [compareContainingBlocks=false]\r\n *   - When this is set to true the containing blocks of the provided elements\r\n *     will be used for calculating the difference. Otherwise the provided\r\n *     elements will be compared directly.\r\n * @returns {Object}\r\n */\r\nexport default function getOffsetDiff(elemA, elemB, compareContainingBlocks) {\r\n  offsetDiff.left = 0;\r\n  offsetDiff.top = 0;\r\n\r\n  // If elements are same let's return early.\r\n  if (elemA === elemB) return offsetDiff;\r\n\r\n  // Compare containing blocks if necessary.\r\n  if (compareContainingBlocks) {\r\n    elemA = getContainingBlock(elemA, true);\r\n    elemB = getContainingBlock(elemB, true);\r\n\r\n    // If containing blocks are identical, let's return early.\r\n    if (elemA === elemB) return offsetDiff;\r\n  }\r\n\r\n  // Finally, let's calculate the offset diff.\r\n  getOffset(elemA, offsetA);\r\n  getOffset(elemB, offsetB);\r\n  offsetDiff.left = offsetB.left - offsetA.left;\r\n  offsetDiff.top = offsetB.top - offsetA.top;\r\n\r\n  return offsetDiff;\r\n}\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\nimport getStyle from './getStyle.js';\r\n\r\nconst translateData = {};\r\n\r\n/**\r\n * Returns the element's computed translateX and translateY values as a floats.\r\n * The returned object is always the same object and updated every time this\r\n * function is called.\r\n *\r\n * @param {HTMLElement} element\r\n * @returns {Object}\r\n */\r\nexport default function getTranslate(element) {\r\n  translateData.x = 0;\r\n  translateData.y = 0;\r\n\r\n  const transform = getStyle(element, 'transform');\r\n  if (!transform) return translateData;\r\n\r\n  const matrixData = transform.replace('matrix(', '').split(',');\r\n  translateData.x = parseFloat(matrixData[4]) || 0;\r\n  translateData.y = parseFloat(matrixData[5]) || 0;\r\n\r\n  return translateData;\r\n}\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\n/**\r\n * Transform translateX and translateY value into CSS transform style\r\n * property's value.\r\n *\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @returns {String}\r\n */\r\nexport default function getTranslateString(x, y) {\r\n  return 'translateX(' + x + 'px) translateY(' + y + 'px)';\r\n}\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\nconst tempArray = [];\r\n\r\n/**\r\n * Insert an item or an array of items to array to a specified index. Mutates\r\n * the array. The index can be negative in which case the items will be added\r\n * to the end of the array.\r\n *\r\n * @param {Array} array\r\n * @param {*} items\r\n * @param {Number} [index=-1]\r\n */\r\nexport default function arrayInsert(array, items, index) {\r\n  let startIndex = typeof index === 'number' ? index : -1;\r\n  if (startIndex < 0) startIndex = array.length - startIndex + 1;\r\n\r\n  array.splice(...tempArray.concat(startIndex, 0, items));\r\n  tempArray.length = 0;\r\n}\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\nconst objectType = '[object Object]';\r\nconst toString = Object.prototype.toString;\r\n\r\n/**\r\n * Check if a value is a plain object.\r\n *\r\n * @param {*} val\r\n * @returns {Boolean}\r\n */\r\nexport default function isPlainObject(val) {\r\n  return typeof val === 'object' && toString.call(val) === objectType;\r\n}\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\nimport elementMatches from './elementMatches.js';\r\n\r\n/**\r\n * Remove class from an element.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {String} className\r\n */\r\nfunction removeClassModern(element, className) {\r\n  element.classList.remove(className);\r\n}\r\n\r\n/**\r\n * Remove class from an element (legacy version, for IE9 support).\r\n *\r\n * @param {HTMLElement} element\r\n * @param {String} className\r\n */\r\nfunction removeClassLegacy(element, className) {\r\n  if (elementMatches(element, '.' + className)) {\r\n    element.className = (' ' + element.className + ' ').replace(' ' + className + ' ', ' ').trim();\r\n  }\r\n}\r\n\r\nexport default ('classList' in Element.prototype ? removeClassModern : removeClassLegacy);\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\nimport { Component } from 'react';\r\nimport Hammer from 'hammerjs';\r\n\r\nimport {\r\n  eventMove,\r\n  eventSend,\r\n  eventBeforeSend,\r\n  eventReceive,\r\n  eventBeforeReceive,\r\n  eventDragInit,\r\n  eventDragStart,\r\n  eventDragMove,\r\n  eventDragScroll,\r\n  eventDragEnd,\r\n  gridInstances,\r\n  namespace\r\n} from '../shared.js';\r\n\r\nimport { addMoveTick, cancelMoveTick, addScrollTick, cancelScrollTick } from '../ticker.js';\r\n\r\nimport addClass from '../utils/addClass.js';\r\nimport arrayMove from '../utils/arrayMove.js';\r\nimport arraySwap from '../utils/arraySwap.js';\r\nimport debounce from '../utils/debounce.js';\r\nimport elementMatches from '../utils/elementMatches.js';\r\nimport getContainingBlock from '../utils/getContainingBlock.js';\r\nimport getOffsetDiff from '../utils/getOffsetDiff.js';\r\nimport getStyle from '../utils/getStyle.js';\r\nimport getTranslate from '../utils/getTranslate.js';\r\nimport getTranslateString from '../utils/getTranslateString.js';\r\nimport arrayInsert from '../utils/arrayInsert.js';\r\nimport isPlainObject from '../utils/isPlainObject.js';\r\nimport isTransformed from '../utils/isTransformed.js';\r\nimport normalizeArrayIndex from '../utils/normalizeArrayIndex.js';\r\nimport removeClass from '../utils/removeClass.js';\r\nimport setStyles from '../utils/setStyles';\r\nimport { isTransformSupported, transformProp } from '../utils/supportedTransform.js';\r\n\r\n// To provide consistently correct dragging experience we need to know if\r\n// transformed elements leak fixed elements or not.\r\nlet hasTransformLeak = checkTransformLeak();\r\n\r\n// Drag start predicate states.\r\nconst startPredicateInactive = 0;\r\nconst startPredicatePending = 1;\r\nconst startPredicateResolved = 2;\r\nconst startPredicateRejected = 3;\r\n\r\n/**\r\n * Bind Hammer touch interaction to an item.\r\n *\r\n * @class\r\n * @param {Item} item\r\n */\r\nclass ItemDrag extends Component {\r\n  constructor(item) {\r\n    super(item);\r\n    if (!Hammer) {\r\n      throw new Error(`[${namespace}] required dependency Hammer is not defined.`);\r\n    }\r\n\r\n    // If we don't have a valid transform leak test result yet, let's run the\r\n    // test on first ItemDrag init. The test needs body element to be ready and\r\n    // here we can be sure that it is ready.\r\n    if (hasTransformLeak === null) {\r\n      hasTransformLeak = checkTransformLeak();\r\n    }\r\n\r\n    const drag = this;\r\n    const element = item._element;\r\n    const grid = item.getGrid();\r\n    const settings = grid._settings;\r\n    let hammer;\r\n\r\n    // Start predicate private data.\r\n    const startPredicate =\r\n      typeof settings.dragStartPredicate === 'function'\r\n        ? settings.dragStartPredicate\r\n        : ItemDrag.defaultStartPredicate;\r\n    let startPredicateState = startPredicateInactive;\r\n    let startPredicateResult;\r\n\r\n    // Protected data.\r\n    this._item = item;\r\n    this._gridId = grid._id;\r\n    this._hammer = hammer = new Hammer.Manager(element);\r\n    this._isDestroyed = false;\r\n    this._isMigrating = false;\r\n\r\n    // Setup item's initial drag data.\r\n    this._reset();\r\n\r\n    // Bind some methods that needs binding.\r\n    this._onScroll = this._onScroll.bind(this);\r\n    this._prepareMove = this._prepareMove.bind(this);\r\n    this._applyMove = this._applyMove.bind(this);\r\n    this._prepareScroll = this._prepareScroll.bind(this);\r\n    this._applyScroll = this._applyScroll.bind(this);\r\n    this._checkOverlap = this._checkOverlap.bind(this);\r\n\r\n    // Create a private drag start resolver that can be used to resolve the drag\r\n    // start predicate asynchronously.\r\n    this._forceResolveStartPredicate = function(event) {\r\n      if (!this._isDestroyed && startPredicateState === startPredicatePending) {\r\n        startPredicateState = startPredicateResolved;\r\n        this._onStart(event);\r\n      }\r\n    };\r\n\r\n    // Create debounce overlap checker function.\r\n    this._checkOverlapDebounce = debounce(this._checkOverlap, settings.dragSortInterval);\r\n\r\n    // Add drag recognizer to hammer.\r\n    hammer.add(\r\n      new Hammer.Pan({\r\n        event: 'drag',\r\n        pointers: 1,\r\n        threshold: 0,\r\n        direction: Hammer.DIRECTION_ALL\r\n      })\r\n    );\r\n\r\n    // Add drag init recognizer to hammer.\r\n    hammer.add(\r\n      new Hammer.Press({\r\n        event: 'draginit',\r\n        pointers: 1,\r\n        threshold: 1000,\r\n        time: 0\r\n      })\r\n    );\r\n\r\n    // Configure the hammer instance.\r\n    if (isPlainObject(settings.dragHammerSettings)) {\r\n      hammer.set(settings.dragHammerSettings);\r\n    }\r\n\r\n    // Bind drag events.\r\n    hammer\r\n      .on('draginit dragstart dragmove', e => {\r\n        // Let's activate drag start predicate state.\r\n        if (startPredicateState === startPredicateInactive) {\r\n          startPredicateState = startPredicatePending;\r\n        }\r\n\r\n        // If predicate is pending try to resolve it.\r\n        if (startPredicateState === startPredicatePending) {\r\n          startPredicateResult = startPredicate(drag._item, e);\r\n          if (startPredicateResult === true) {\r\n            startPredicateState = startPredicateResolved;\r\n            drag._onStart(e);\r\n          } else if (startPredicateResult === false) {\r\n            startPredicateState = startPredicateRejected;\r\n          }\r\n        }\r\n\r\n        // Otherwise if predicate is resolved and drag is active, move the item.\r\n        else if (startPredicateState === startPredicateResolved && drag._isActive) {\r\n          drag._onMove(e);\r\n        }\r\n      })\r\n      .on('dragend dragcancel draginitup', e => {\r\n        // Check if the start predicate was resolved during drag.\r\n        const isResolved = startPredicateState === startPredicateResolved;\r\n\r\n        // Do final predicate check to allow user to unbind stuff for the current\r\n        // drag procedure within the predicate callback. The return value of this\r\n        // check will have no effect to the state of the predicate.\r\n        startPredicate(drag._item, e);\r\n\r\n        // Reset start predicate state.\r\n        startPredicateState = startPredicateInactive;\r\n\r\n        // If predicate is resolved and dragging is active, call the end handler.\r\n        if (isResolved && drag._isActive) drag._onEnd(e);\r\n      });\r\n\r\n    // Prevent native link/image dragging for the item and it's ancestors.\r\n    element.addEventListener('dragstart', preventDefault, false);\r\n  }\r\n\r\n  /**\r\n   * Public prototype methods\r\n   * ************************\r\n   */\r\n\r\n  /**\r\n   * Abort dragging and reset drag data.\r\n   *\r\n   * @public\r\n   * @memberof ItemDrag.prototype\r\n   * @returns {ItemDrag}\r\n   */\r\n  stop() {\r\n    const item = this._item;\r\n    const element = item._element;\r\n    const grid = this._getGrid();\r\n\r\n    if (!this._isActive) return this;\r\n\r\n    // If the item is being dropped into another grid, finish it up and return\r\n    // immediately.\r\n    if (this._isMigrating) {\r\n      this._finishMigration();\r\n      return this;\r\n    }\r\n\r\n    // Cancel queued move and scroll ticks.\r\n    cancelMoveTick(item._id);\r\n    cancelScrollTick(item._id);\r\n\r\n    // Remove scroll listeners.\r\n    this._unbindScrollListeners();\r\n\r\n    // Cancel overlap check.\r\n    this._checkOverlapDebounce('cancel');\r\n\r\n    // Append item element to the container if it's not it's child. Also make\r\n    // sure the translate values are adjusted to account for the DOM shift.\r\n    if (element.parentNode !== grid._element) {\r\n      grid._element.appendChild(element);\r\n      element.style[transformProp] = getTranslateString(this._gridX, this._gridY);\r\n    }\r\n\r\n    // Remove dragging class.\r\n    removeClass(element, grid._settings.itemDraggingClass);\r\n\r\n    // Reset drag data.\r\n    this._reset();\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Destroy instance.\r\n   *\r\n   * @public\r\n   * @memberof ItemDrag.prototype\r\n   * @returns {ItemDrag}\r\n   */\r\n  destroy() {\r\n    if (this._isDestroyed) return this;\r\n    this.stop();\r\n    this._hammer.destroy();\r\n    this._item._element.removeEventListener('dragstart', preventDefault, false);\r\n    this._isDestroyed = true;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Private prototype methods\r\n   * *************************\r\n   */\r\n\r\n  /**\r\n   * Get Grid instance.\r\n   *\r\n   * @private\r\n   * @memberof ItemDrag.prototype\r\n   * @returns {?Grid}\r\n   */\r\n  _getGrid() {\r\n    return gridInstances[this._gridId] || null;\r\n  }\r\n\r\n  /**\r\n   * Setup/reset drag data.\r\n   *\r\n   * @private\r\n   * @memberof ItemDrag.prototype\r\n   */\r\n  _reset() {\r\n    // Is item being dragged?\r\n    this._isActive = false;\r\n\r\n    // The dragged item's container element.\r\n    this._container = null;\r\n\r\n    // The dragged item's containing block.\r\n    this._containingBlock = null;\r\n\r\n    // Hammer event data.\r\n    this._lastEvent = null;\r\n    this._lastScrollEvent = null;\r\n\r\n    // All the elements which need to be listened for scroll events during\r\n    // dragging.\r\n    this._scrollers = [];\r\n\r\n    // The current translateX/translateY position.\r\n    this._left = 0;\r\n    this._top = 0;\r\n\r\n    // Dragged element's current position within the grid.\r\n    this._gridX = 0;\r\n    this._gridY = 0;\r\n\r\n    // Dragged element's current offset from window's northwest corner. Does\r\n    // not account for element's margins.\r\n    this._elementClientX = 0;\r\n    this._elementClientY = 0;\r\n\r\n    // Offset difference between the dragged element's temporary drag\r\n    // container and it's original container.\r\n    this._containerDiffX = 0;\r\n    this._containerDiffY = 0;\r\n  }\r\n\r\n  /**\r\n   * Bind drag scroll handlers to all scrollable ancestor elements of the\r\n   * dragged element and the drag container element.\r\n   *\r\n   * @private\r\n   * @memberof ItemDrag.prototype\r\n   */\r\n  _bindScrollListeners() {\r\n    const gridContainer = this._getGrid()._element;\r\n    const dragContainer = this._container;\r\n    const scrollers = this._scrollers;\r\n    let containerScrollers;\r\n    let i;\r\n\r\n    // Get dragged element's scrolling parents.\r\n    scrollers.length = 0;\r\n    getScrollParents(this._item._element, scrollers);\r\n\r\n    // If drag container is defined and it's not the same element as grid\r\n    // container then we need to add the grid container and it's scroll parents\r\n    // to the elements which are going to be listener for scroll events.\r\n    if (dragContainer !== gridContainer) {\r\n      containerScrollers = [];\r\n      getScrollParents(gridContainer, containerScrollers);\r\n      containerScrollers.push(gridContainer);\r\n      for (i = 0; i < containerScrollers.length; i++) {\r\n        if (!scrollers.includes(containerScrollers[i])) {\r\n          scrollers.push(containerScrollers[i]);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Bind scroll listeners.\r\n    for (i = 0; i < scrollers.length; i++) {\r\n      scrollers[i].addEventListener('scroll', this._onScroll);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Unbind currently bound drag scroll handlers from all scrollable ancestor\r\n   * elements of the dragged element and the drag container element.\r\n   *\r\n   * @private\r\n   * @memberof ItemDrag.prototype\r\n   */\r\n  _unbindScrollListeners() {\r\n    const scrollers = this._scrollers;\r\n    let i;\r\n\r\n    for (i = 0; i < scrollers.length; i++) {\r\n      scrollers[i].removeEventListener('scroll', this._onScroll);\r\n    }\r\n\r\n    scrollers.length = 0;\r\n  }\r\n\r\n  /**\r\n   * Setup default start predicate.\r\n   *\r\n   * @private\r\n   * @memberof ItemDrag.prototype\r\n   * @param {Object} [options]\r\n   * @returns {Object}\r\n   */\r\n  _setupStartPredicate(options) {\r\n    const config = options || this._getGrid()._settings.dragStartPredicate || 0;\r\n    return (this._startPredicateData = {\r\n      distance: Math.abs(config.distance) || 0,\r\n      delay: Math.max(config.delay, 0) || 0,\r\n      handle: typeof config.handle === 'string' ? config.handle : false\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Setup default start predicate handle.\r\n   *\r\n   * @private\r\n   * @memberof ItemDrag.prototype\r\n   * @param {Object} event\r\n   * @returns {?HTMLElement}\r\n   */\r\n  _getStartPredicateHandle(event) {\r\n    const predicate = this._startPredicateData;\r\n    const element = this._item._element;\r\n    let handleElement = element;\r\n\r\n    // No handle, no hassle -> let's use the item element as the handle.\r\n    if (!predicate.handle) return handleElement;\r\n\r\n    // If there is a specific predicate handle defined, let's try to get it.\r\n    handleElement = (event.changedPointers[0] || 0).target;\r\n    while (handleElement && !elementMatches(handleElement, predicate.handle)) {\r\n      handleElement = handleElement !== element ? handleElement.parentElement : null;\r\n    }\r\n    return handleElement || null;\r\n  }\r\n\r\n  /**\r\n   * Unbind currently bound drag scroll handlers from all scrollable ancestor\r\n   * elements of the dragged element and the drag container element.\r\n   *\r\n   * @private\r\n   * @memberof ItemDrag.prototype\r\n   * @param {Object} event\r\n   * @returns {Boolean}\r\n   */\r\n  _resolveStartPredicate(event) {\r\n    const predicate = this._startPredicateData;\r\n    const pointer = event.changedPointers[0];\r\n    const pageX = (pointer && pointer.pageX) || 0;\r\n    const pageY = (pointer && pointer.pageY) || 0;\r\n    let handleRect;\r\n    let handleLeft;\r\n    let handleTop;\r\n    let handleWidth;\r\n    let handleHeight;\r\n\r\n    // If the moved distance is smaller than the threshold distance or there is\r\n    // some delay left, ignore this predicate cycle.\r\n    if (event.distance < predicate.distance || predicate.delay) return;\r\n\r\n    // Get handle rect data.\r\n    handleRect = predicate.handleElement.getBoundingClientRect();\r\n    handleLeft = handleRect.left + (window.pageXOffset || 0);\r\n    handleTop = handleRect.top + (window.pageYOffset || 0);\r\n    handleWidth = handleRect.width;\r\n    handleHeight = handleRect.height;\r\n\r\n    // Reset predicate data.\r\n    this._resetStartPredicate();\r\n\r\n    // If the cursor is still within the handle let's start the drag.\r\n    return (\r\n      handleWidth &&\r\n      handleHeight &&\r\n      pageX >= handleLeft &&\r\n      pageX < handleLeft + handleWidth &&\r\n      pageY >= handleTop &&\r\n      pageY < handleTop + handleHeight\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Finalize start predicate.\r\n   *\r\n   * @private\r\n   * @memberof ItemDrag.prototype\r\n   * @param {Object} event\r\n   */\r\n  _finishStartPredicate(event) {\r\n    const element = this._item._element;\r\n\r\n    // Reset predicate.\r\n    this._resetStartPredicate();\r\n\r\n    // If the gesture can be interpreted as click let's try to open the element's\r\n    // href url (if it is an anchor element).\r\n    if (isClick(event)) openAnchorHref(element);\r\n  }\r\n\r\n  /**\r\n   * Reset for default drag start predicate function.\r\n   *\r\n   * @private\r\n   * @memberof ItemDrag.prototype\r\n   */\r\n  _resetStartPredicate() {\r\n    const predicate = this._startPredicateData;\r\n    if (predicate) {\r\n      if (predicate.delayTimer) {\r\n        predicate.delayTimer = window.clearTimeout(predicate.delayTimer);\r\n      }\r\n      this._startPredicateData = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check (during drag) if an item is overlapping other items and based on\r\n   * the configuration layout the items.\r\n   *\r\n   * @private\r\n   * @memberof ItemDrag.prototype\r\n   */\r\n  _checkOverlap() {\r\n    if (!this._isActive) return;\r\n\r\n    const item = this._item;\r\n    const settings = this._getGrid()._settings;\r\n    let result;\r\n    let currentGrid;\r\n    let currentIndex;\r\n    let targetGrid;\r\n    let targetIndex;\r\n    let sortAction;\r\n    let isMigration;\r\n\r\n    // Get overlap check result.\r\n    if (typeof settings.dragSortPredicate === 'function') {\r\n      result = settings.dragSortPredicate(item, this._lastEvent);\r\n    } else {\r\n      result = ItemDrag.defaultSortPredicate(item, settings.dragSortPredicate);\r\n    }\r\n\r\n    // Let's make sure the result object has a valid index before going further.\r\n    if (!result || typeof result.index !== 'number') return;\r\n\r\n    currentGrid = item.getGrid();\r\n    targetGrid = result.grid || currentGrid;\r\n    isMigration = currentGrid !== targetGrid;\r\n    currentIndex = currentGrid._items.indexOf(item);\r\n    targetIndex = normalizeArrayIndex(targetGrid._items, result.index, isMigration);\r\n    sortAction = result.action === 'swap' ? 'swap' : 'move';\r\n\r\n    // If the item was moved within it's current grid.\r\n    if (!isMigration) {\r\n      // Make sure the target index is not the current index.\r\n      if (currentIndex !== targetIndex) {\r\n        // Do the sort.\r\n        (sortAction === 'swap' ? arraySwap : arrayMove)(\r\n          currentGrid._items,\r\n          currentIndex,\r\n          targetIndex\r\n        );\r\n\r\n        // Emit move event.\r\n        if (currentGrid._hasListeners(eventMove)) {\r\n          currentGrid._emit(eventMove, {\r\n            item,\r\n            fromIndex: currentIndex,\r\n            toIndex: targetIndex,\r\n            action: sortAction\r\n          });\r\n        }\r\n\r\n        // Layout the grid.\r\n        currentGrid.layout();\r\n      }\r\n    }\r\n\r\n    // If the item was moved to another grid.\r\n    else {\r\n      // Emit beforeSend event.\r\n      if (currentGrid._hasListeners(eventBeforeSend)) {\r\n        currentGrid._emit(eventBeforeSend, {\r\n          item,\r\n          fromGrid: currentGrid,\r\n          fromIndex: currentIndex,\r\n          toGrid: targetGrid,\r\n          toIndex: targetIndex\r\n        });\r\n      }\r\n\r\n      // Emit beforeReceive event.\r\n      if (targetGrid._hasListeners(eventBeforeReceive)) {\r\n        targetGrid._emit(eventBeforeReceive, {\r\n          item,\r\n          fromGrid: currentGrid,\r\n          fromIndex: currentIndex,\r\n          toGrid: targetGrid,\r\n          toIndex: targetIndex\r\n        });\r\n      }\r\n\r\n      // Update item's grid id reference.\r\n      item._gridId = targetGrid._id;\r\n\r\n      // Update drag instance's migrating indicator.\r\n      this._isMigrating = item._gridId !== this._gridId;\r\n\r\n      // Move item instance from current grid to target grid.\r\n      currentGrid._items.splice(currentIndex, 1);\r\n      arrayInsert(targetGrid._items, item, targetIndex);\r\n\r\n      // Set sort data as null, which is an indicator for the item comparison\r\n      // function that the sort data of this specific item should be fetched\r\n      // lazily.\r\n      item._sortData = null;\r\n\r\n      // Emit send event.\r\n      if (currentGrid._hasListeners(eventSend)) {\r\n        currentGrid._emit(eventSend, {\r\n          item,\r\n          fromGrid: currentGrid,\r\n          fromIndex: currentIndex,\r\n          toGrid: targetGrid,\r\n          toIndex: targetIndex\r\n        });\r\n      }\r\n\r\n      // Emit receive event.\r\n      if (targetGrid._hasListeners(eventReceive)) {\r\n        targetGrid._emit(eventReceive, {\r\n          item,\r\n          fromGrid: currentGrid,\r\n          fromIndex: currentIndex,\r\n          toGrid: targetGrid,\r\n          toIndex: targetIndex\r\n        });\r\n      }\r\n\r\n      // Layout both grids.\r\n      currentGrid.layout();\r\n      targetGrid.layout();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * If item is dragged into another grid, finish the migration process\r\n   * gracefully.\r\n   *\r\n   * @private\r\n   * @memberof ItemDrag.prototype\r\n   */\r\n  _finishMigration() {\r\n    const item = this._item;\r\n    const release = item._release;\r\n    const element = item._element;\r\n    const isActive = item._isActive;\r\n    const targetGrid = item.getGrid();\r\n    const targetGridElement = targetGrid._element;\r\n    const targetSettings = targetGrid._settings;\r\n    const targetContainer = targetSettings.dragContainer || targetGridElement;\r\n    const currentSettings = this._getGrid()._settings;\r\n    const currentContainer = element.parentNode;\r\n    let translate;\r\n    let offsetDiff;\r\n\r\n    // Destroy current drag. Note that we need to set the migrating flag to\r\n    // false first, because otherwise we create an infinite loop between this\r\n    // and the drag.stop() method.\r\n    this._isMigrating = false;\r\n    this.destroy();\r\n\r\n    // Remove current classnames.\r\n    removeClass(element, currentSettings.itemClass);\r\n    removeClass(element, currentSettings.itemVisibleClass);\r\n    removeClass(element, currentSettings.itemHiddenClass);\r\n\r\n    // Add new classnames.\r\n    addClass(element, targetSettings.itemClass);\r\n    addClass(element, isActive ? targetSettings.itemVisibleClass : targetSettings.itemHiddenClass);\r\n\r\n    // Move the item inside the target container if it's different than the\r\n    // current container.\r\n    if (targetContainer !== currentContainer) {\r\n      targetContainer.appendChild(element);\r\n      offsetDiff = getOffsetDiff(currentContainer, targetContainer, true);\r\n      translate = getTranslate(element);\r\n      translate.x -= offsetDiff.left;\r\n      translate.y -= offsetDiff.top;\r\n    }\r\n\r\n    // Update item's cached dimensions and sort data.\r\n    item._refreshDimensions();\r\n    item._refreshSortData();\r\n\r\n    // Calculate the offset difference between target's drag container (if any)\r\n    // and actual grid container element. We save it later for the release\r\n    // process.\r\n    offsetDiff = getOffsetDiff(targetContainer, targetGridElement, true);\r\n    release._containerDiffX = offsetDiff.left;\r\n    release._containerDiffY = offsetDiff.top;\r\n\r\n    // Recreate item's drag handler.\r\n    item._drag = targetSettings.dragEnabled ? new ItemDrag(item) : null;\r\n\r\n    // Adjust the position of the item element if it was moved from a container\r\n    // to another.\r\n    if (targetContainer !== currentContainer) {\r\n      element.style[transformProp] = getTranslateString(translate.x, translate.y);\r\n    }\r\n\r\n    // Update child element's styles to reflect the current visibility state.\r\n    item._child.removeAttribute('style');\r\n    setStyles(item._child, isActive ? targetSettings.visibleStyles : targetSettings.hiddenStyles);\r\n\r\n    // Start the release.\r\n    release.start();\r\n  }\r\n\r\n  /**\r\n   * Drag start handler.\r\n   *\r\n   * @private\r\n   * @memberof ItemDrag.prototype\r\n   * @param {Object} event\r\n   */\r\n  _onStart(event) {\r\n    const item = this._item;\r\n\r\n    // If item is not active, don't start the drag.\r\n    if (!item._isActive) return;\r\n\r\n    const element = item._element;\r\n    const grid = this._getGrid();\r\n    const settings = grid._settings;\r\n    const release = item._release;\r\n    const migrate = item._migrate;\r\n    const gridContainer = grid._element;\r\n    const dragContainer = settings.dragContainer || gridContainer;\r\n    const containingBlock = getContainingBlock(dragContainer, true);\r\n    const translate = getTranslate(element);\r\n    let currentLeft = translate.x;\r\n    let currentTop = translate.y;\r\n    const elementRect = element.getBoundingClientRect();\r\n    const hasDragContainer = dragContainer !== gridContainer;\r\n    let offsetDiff;\r\n\r\n    // If grid container is not the drag container, we need to calculate the\r\n    // offset difference between grid container and drag container's containing\r\n    // element.\r\n    if (hasDragContainer) {\r\n      offsetDiff = getOffsetDiff(containingBlock, gridContainer);\r\n    }\r\n\r\n    // Stop current positioning animation.\r\n    if (item.isPositioning()) {\r\n      item._layout.stop(true, { transform: getTranslateString(currentLeft, currentTop) });\r\n    }\r\n\r\n    // Stop current migration animation.\r\n    if (migrate._isActive) {\r\n      currentLeft -= migrate._containerDiffX;\r\n      currentTop -= migrate._containerDiffY;\r\n      migrate.stop(true, { transform: getTranslateString(currentLeft, currentTop) });\r\n    }\r\n\r\n    // If item is being released reset release data.\r\n    if (item.isReleasing()) release._reset();\r\n\r\n    // Setup drag data.\r\n    this._isActive = true;\r\n    this._lastEvent = event;\r\n    this._container = dragContainer;\r\n    this._containingBlock = containingBlock;\r\n    this._elementClientX = elementRect.left;\r\n    this._elementClientY = elementRect.top;\r\n    this._left = this._gridX = currentLeft;\r\n    this._top = this._gridY = currentTop;\r\n\r\n    // Emit dragInit event.\r\n    grid._emit(eventDragInit, item, event);\r\n\r\n    // If a specific drag container is set and it is different from the\r\n    // grid's container element we need to cast some extra spells.\r\n    if (hasDragContainer) {\r\n      // Store the container offset diffs to drag data.\r\n      this._containerDiffX = offsetDiff.left;\r\n      this._containerDiffY = offsetDiff.top;\r\n\r\n      // If the dragged element is a child of the drag container all we need to\r\n      // do is setup the relative drag position data.\r\n      if (element.parentNode === dragContainer) {\r\n        this._gridX = currentLeft - this._containerDiffX;\r\n        this._gridY = currentTop - this._containerDiffY;\r\n      }\r\n\r\n      // Otherwise we need to append the element inside the correct container,\r\n      // setup the actual drag position data and adjust the element's translate\r\n      // values to account for the DOM position shift.\r\n      else {\r\n        this._left = currentLeft + this._containerDiffX;\r\n        this._top = currentTop + this._containerDiffY;\r\n        dragContainer.appendChild(element);\r\n        element.style[transformProp] = getTranslateString(this._left, this._top);\r\n      }\r\n    }\r\n\r\n    // Set drag class and bind scrollers.\r\n    addClass(element, settings.itemDraggingClass);\r\n    this._bindScrollListeners();\r\n\r\n    // Emit dragStart event.\r\n    grid._emit(eventDragStart, item, event);\r\n  }\r\n\r\n  /**\r\n   * Drag move handler.\r\n   *\r\n   * @private\r\n   * @memberof ItemDrag.prototype\r\n   * @param {Object} event\r\n   */\r\n  _onMove(event) {\r\n    const item = this._item;\r\n\r\n    // If item is not active, reset drag.\r\n    if (!item._isActive) {\r\n      this.stop();\r\n      return;\r\n    }\r\n\r\n    const settings = this._getGrid()._settings;\r\n    const axis = settings.dragAxis;\r\n    const xDiff = event.deltaX - this._lastEvent.deltaX;\r\n    const yDiff = event.deltaY - this._lastEvent.deltaY;\r\n\r\n    // Update last event.\r\n    this._lastEvent = event;\r\n\r\n    // Update horizontal position data.\r\n    if (axis !== 'y') {\r\n      this._left += xDiff;\r\n      this._gridX += xDiff;\r\n      this._elementClientX += xDiff;\r\n    }\r\n\r\n    // Update vertical position data.\r\n    if (axis !== 'x') {\r\n      this._top += yDiff;\r\n      this._gridY += yDiff;\r\n      this._elementClientY += yDiff;\r\n    }\r\n\r\n    // Do move prepare/apply handling in the next tick.\r\n    addMoveTick(item._id, this._prepareMove, this._applyMove);\r\n  }\r\n\r\n  /**\r\n   * Prepare dragged item for moving.\r\n   *\r\n   * @private\r\n   * @memberof ItemDrag.prototype\r\n   */\r\n  _prepareMove() {\r\n    // Do nothing if item is not active.\r\n    if (!this._item._isActive) return;\r\n\r\n    // If drag sort is enabled -> check overlap.\r\n    if (this._getGrid()._settings.dragSort) this._checkOverlapDebounce();\r\n  }\r\n\r\n  /**\r\n   * Apply movement to dragged item.\r\n   *\r\n   * @private\r\n   * @memberof ItemDrag.prototype\r\n   */\r\n  _applyMove() {\r\n    const item = this._item;\r\n\r\n    // Do nothing if item is not active.\r\n    if (!item._isActive) return;\r\n\r\n    // Update element's translateX/Y values.\r\n    item._element.style[transformProp] = getTranslateString(this._left, this._top);\r\n\r\n    // Emit dragMove event.\r\n    this._getGrid()._emit(eventDragMove, item, this._lastEvent);\r\n  }\r\n\r\n  /**\r\n   * Drag scroll handler.\r\n   *\r\n   * @private\r\n   * @memberof ItemDrag.prototype\r\n   * @param {Object} event\r\n   */\r\n  _onScroll(event) {\r\n    const item = this._item;\r\n\r\n    // If item is not active, reset drag.\r\n    if (!item._isActive) {\r\n      this.stop();\r\n      return;\r\n    }\r\n\r\n    // Update last scroll event.\r\n    this._lastScrollEvent = event;\r\n\r\n    // Do scroll prepare/apply handling in the next tick.\r\n    addScrollTick(item._id, this._prepareScroll, this._applyScroll);\r\n  }\r\n\r\n  /**\r\n   * Prepare dragged item for scrolling.\r\n   *\r\n   * @private\r\n   * @memberof ItemDrag.prototype\r\n   */\r\n  _prepareScroll() {\r\n    const item = this._item;\r\n\r\n    // If item is not active do nothing.\r\n    if (!item._isActive) return;\r\n\r\n    const element = item._element;\r\n    const grid = this._getGrid();\r\n    const settings = grid._settings;\r\n    const axis = settings.dragAxis;\r\n    const gridContainer = grid._element;\r\n    let offsetDiff;\r\n\r\n    // Calculate element's rect and x/y diff.\r\n    const rect = element.getBoundingClientRect();\r\n    const xDiff = this._elementClientX - rect.left;\r\n    const yDiff = this._elementClientY - rect.top;\r\n\r\n    // Update container diff.\r\n    if (this._container !== gridContainer) {\r\n      offsetDiff = getOffsetDiff(this._containingBlock, gridContainer);\r\n      this._containerDiffX = offsetDiff.left;\r\n      this._containerDiffY = offsetDiff.top;\r\n    }\r\n\r\n    // Update horizontal position data.\r\n    if (axis !== 'y') {\r\n      this._left += xDiff;\r\n      this._gridX = this._left - this._containerDiffX;\r\n    }\r\n\r\n    // Update vertical position data.\r\n    if (axis !== 'x') {\r\n      this._top += yDiff;\r\n      this._gridY = this._top - this._containerDiffY;\r\n    }\r\n\r\n    // Overlap handling.\r\n    if (settings.dragSort) this._checkOverlapDebounce();\r\n  }\r\n\r\n  /**\r\n   * Apply scroll to dragged item.\r\n   *\r\n   * @private\r\n   * @memberof ItemDrag.prototype\r\n   */\r\n  _applyScroll() {\r\n    const item = this._item;\r\n\r\n    // If item is not active do nothing.\r\n    if (!item._isActive) return;\r\n\r\n    // Update element's translateX/Y values.\r\n    item._element.style[transformProp] = getTranslateString(this._left, this._top);\r\n\r\n    // Emit dragScroll event.\r\n    this._getGrid()._emit(eventDragScroll, item, this._lastScrollEvent);\r\n  }\r\n\r\n  /**\r\n   * Drag end handler.\r\n   *\r\n   * @private\r\n   * @memberof ItemDrag.prototype\r\n   * @param {Object} event\r\n   */\r\n  _onEnd(event) {\r\n    const item = this._item;\r\n    const element = item._element;\r\n    const grid = this._getGrid();\r\n    const settings = grid._settings;\r\n    const release = item._release;\r\n\r\n    // If item is not active, reset drag.\r\n    if (!item._isActive) {\r\n      this.stop();\r\n      return;\r\n    }\r\n\r\n    // Cancel queued move and scroll ticks.\r\n    cancelMoveTick(item._id);\r\n    cancelScrollTick(item._id);\r\n\r\n    // Finish currently queued overlap check.\r\n    settings.dragSort && this._checkOverlapDebounce('finish');\r\n\r\n    // Remove scroll listeners.\r\n    this._unbindScrollListeners();\r\n\r\n    // Setup release data.\r\n    release._containerDiffX = this._containerDiffX;\r\n    release._containerDiffY = this._containerDiffY;\r\n\r\n    // Reset drag data.\r\n    this._reset();\r\n\r\n    // Remove drag class name from element.\r\n    removeClass(element, settings.itemDraggingClass);\r\n\r\n    // Emit dragEnd event.\r\n    grid._emit(eventDragEnd, item, event);\r\n\r\n    // Finish up the migration process or start the release process.\r\n    this._isMigrating ? this._finishMigration() : release.start();\r\n  }\r\n}\r\n\r\n/**\r\n * Public static methods\r\n * *********************\r\n */\r\n\r\n/**\r\n * Default drag start predicate handler that handles anchor elements\r\n * gracefully. The return value of this function defines if the drag is\r\n * started, rejected or pending. When true is returned the dragging is started\r\n * and when false is returned the dragging is rejected. If nothing is returned\r\n * the predicate will be called again on the next drag movement.\r\n *\r\n * @public\r\n * @memberof ItemDrag\r\n * @param {Item} item\r\n * @param {Object} event\r\n * @param {Object} [options]\r\n *   - An optional options object which can be used to pass the predicate\r\n *     it's options manually. By default the predicate retrieves the options\r\n *     from the grid's settings.\r\n * @returns {Boolean}\r\n */\r\nItemDrag.defaultStartPredicate = (item, event, options) => {\r\n  const drag = item._drag;\r\n  const predicate = drag._startPredicateData || drag._setupStartPredicate(options);\r\n\r\n  // Final event logic. At this stage return value does not matter anymore,\r\n  // the predicate is either resolved or it's not and there's nothing to do\r\n  // about it. Here we just reset data and if the item element is a link\r\n  // we follow it (if there has only been slight movement).\r\n  if (event.isFinal) {\r\n    drag._finishStartPredicate(event);\r\n    return;\r\n  }\r\n\r\n  // Find and store the handle element so we can check later on if the\r\n  // cursor is within the handle. If we have a handle selector let's find\r\n  // the corresponding element. Otherwise let's use the item element as the\r\n  // handle.\r\n  if (!predicate.handleElement) {\r\n    predicate.handleElement = drag._getStartPredicateHandle(event);\r\n    if (!predicate.handleElement) return false;\r\n  }\r\n\r\n  // If delay is defined let's keep track of the latest event and initiate\r\n  // delay if it has not been done yet.\r\n  if (predicate.delay) {\r\n    predicate.event = event;\r\n    if (!predicate.delayTimer) {\r\n      predicate.delayTimer = window.setTimeout(() => {\r\n        predicate.delay = 0;\r\n        if (drag._resolveStartPredicate(predicate.event)) {\r\n          drag._forceResolveStartPredicate(predicate.event);\r\n          drag._resetStartPredicate();\r\n        }\r\n      }, predicate.delay);\r\n    }\r\n  }\r\n\r\n  return drag._resolveStartPredicate(event);\r\n};\r\n\r\n/**\r\n * Default drag sort predicate.\r\n *\r\n * @public\r\n * @memberof ItemDrag\r\n * @param {Item} item\r\n * @param {Object} [options]\r\n * @param {Number} [options.threshold=50]\r\n * @param {String} [options.action='move']\r\n * @returns {(Boolean|DragSortCommand)}\r\n *   - Returns false if no valid index was found. Otherwise returns drag sort\r\n *     command.\r\n */\r\nItemDrag.defaultSortPredicate = ((() => {\r\n  const itemRect = {};\r\n  const targetRect = {};\r\n  const returnData = {};\r\n  const rootGridArray = [];\r\n\r\n  function getTargetGrid(item, rootGrid, threshold) {\r\n    let target = null;\r\n    const dragSort = rootGrid._settings.dragSort;\r\n    let bestScore = -1;\r\n    let gridScore;\r\n    let grids;\r\n    let grid;\r\n    let i;\r\n\r\n    // Get potential target grids.\r\n    if (dragSort === true) {\r\n      rootGridArray[0] = rootGrid;\r\n      grids = rootGridArray;\r\n    } else {\r\n      grids = dragSort.call(rootGrid, item);\r\n    }\r\n\r\n    // Return immediately if there are no grids.\r\n    if (!Array.isArray(grids)) return target;\r\n\r\n    // Loop through the grids and get the best match.\r\n    for (i = 0; i < grids.length; i++) {\r\n      grid = grids[i];\r\n\r\n      // Filter out all destroyed grids.\r\n      if (grid._isDestroyed) continue;\r\n\r\n      // We need to update the grid's offsets and dimensions since they might\r\n      // have changed (e.g during scrolling).\r\n      grid._updateBoundingRect();\r\n\r\n      // Check how much dragged element overlaps the container element.\r\n      targetRect.width = grid._width;\r\n      targetRect.height = grid._height;\r\n      targetRect.left = grid._left;\r\n      targetRect.top = grid._top;\r\n      gridScore = getRectOverlapScore(itemRect, targetRect);\r\n\r\n      // Check if this grid is the best match so far.\r\n      if (gridScore > threshold && gridScore > bestScore) {\r\n        bestScore = gridScore;\r\n        target = grid;\r\n      }\r\n    }\r\n\r\n    // Always reset root grid array.\r\n    rootGridArray.length = 0;\r\n\r\n    return target;\r\n  }\r\n\r\n  return (item, options) => {\r\n    const drag = item._drag;\r\n    const rootGrid = drag._getGrid();\r\n\r\n    // Get drag sort predicate settings.\r\n    const sortThreshold = options && typeof options.threshold === 'number' ? options.threshold : 50;\r\n    const sortAction = options && options.action === 'swap' ? 'swap' : 'move';\r\n\r\n    // Populate item rect data.\r\n    itemRect.width = item._width;\r\n    itemRect.height = item._height;\r\n    itemRect.left = drag._elementClientX;\r\n    itemRect.top = drag._elementClientY;\r\n\r\n    // Calculate the target grid.\r\n    const grid = getTargetGrid(item, rootGrid, sortThreshold);\r\n\r\n    // Return early if we found no grid container element that overlaps the\r\n    // dragged item enough.\r\n    if (!grid) return false;\r\n\r\n    let gridOffsetLeft = 0;\r\n    let gridOffsetTop = 0;\r\n    let matchScore = -1;\r\n    let matchIndex;\r\n    let hasValidTargets;\r\n    let target;\r\n    let score;\r\n    let i;\r\n\r\n    // If item is moved within it's originating grid adjust item's left and\r\n    // top props. Otherwise if item is moved to/within another grid get the\r\n    // container element's offset (from the element's content edge).\r\n    if (grid === rootGrid) {\r\n      itemRect.left = drag._gridX + item._marginLeft;\r\n      itemRect.top = drag._gridY + item._marginTop;\r\n    } else {\r\n      grid._updateBorders(1, 0, 1, 0);\r\n      gridOffsetLeft = grid._left + grid._borderLeft;\r\n      gridOffsetTop = grid._top + grid._borderTop;\r\n    }\r\n\r\n    // Loop through the target grid items and try to find the best match.\r\n    for (i = 0; i < grid._items.length; i++) {\r\n      target = grid._items[i];\r\n\r\n      // If the target item is not active or the target item is the dragged\r\n      // item let's skip to the next item.\r\n      if (!target._isActive || target === item) {\r\n        continue;\r\n      }\r\n\r\n      // Mark the grid as having valid target items.\r\n      hasValidTargets = true;\r\n\r\n      // Calculate the target's overlap score with the dragged item.\r\n      targetRect.width = target._width;\r\n      targetRect.height = target._height;\r\n      targetRect.left = target._left + target._marginLeft + gridOffsetLeft;\r\n      targetRect.top = target._top + target._marginTop + gridOffsetTop;\r\n      score = getRectOverlapScore(itemRect, targetRect);\r\n\r\n      // Update best match index and score if the target's overlap score with\r\n      // the dragged item is higher than the current best match score.\r\n      if (score > matchScore) {\r\n        matchIndex = i;\r\n        matchScore = score;\r\n      }\r\n    }\r\n\r\n    // If there is no valid match and the item is being moved into another\r\n    // grid.\r\n    if (matchScore < sortThreshold && item.getGrid() !== grid) {\r\n      matchIndex = hasValidTargets ? -1 : 0;\r\n      matchScore = Infinity;\r\n    }\r\n\r\n    // Check if the best match overlaps enough to justify a placement switch.\r\n    if (matchScore >= sortThreshold) {\r\n      returnData.grid = grid;\r\n      returnData.index = matchIndex;\r\n      returnData.action = sortAction;\r\n      return returnData;\r\n    }\r\n\r\n    return false;\r\n  };\r\n}))();\r\n\r\n/**\r\n * Private helpers\r\n * ***************\r\n */\r\n\r\n/**\r\n * Prevent default.\r\n *\r\n * @param {Object} e\r\n */\r\nfunction preventDefault(e) {\r\n  if (e.preventDefault) e.preventDefault();\r\n}\r\n\r\n/**\r\n * Calculate how many percent the intersection area of two rectangles is from\r\n * the maximum potential intersection area between the rectangles.\r\n *\r\n * @param {Rectangle} a\r\n * @param {Rectangle} b\r\n * @returns {Number}\r\n *   - A number between 0-100.\r\n */\r\nfunction getRectOverlapScore(a, b) {\r\n  // Return 0 immediately if the rectangles do not overlap.\r\n  if (\r\n    a.left + a.width <= b.left ||\r\n    b.left + b.width <= a.left ||\r\n    a.top + a.height <= b.top ||\r\n    b.top + b.height <= a.top\r\n  ) {\r\n    return 0;\r\n  }\r\n\r\n  // Calculate intersection area's width, height, max height and max width.\r\n  const width = Math.min(a.left + a.width, b.left + b.width) - Math.max(a.left, b.left);\r\n  const height = Math.min(a.top + a.height, b.top + b.height) - Math.max(a.top, b.top);\r\n  const maxWidth = Math.min(a.width, b.width);\r\n  const maxHeight = Math.min(a.height, b.height);\r\n\r\n  return ((width * height) / (maxWidth * maxHeight)) * 100;\r\n}\r\n\r\n/**\r\n * Get element's scroll parents.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {Array} [data]\r\n * @returns {HTMLElement[]}\r\n */\r\nfunction getScrollParents(element, data) {\r\n  const ret = data || [];\r\n  let parent = element.parentNode;\r\n\r\n  //\r\n  // If transformed elements leak fixed elements.\r\n  //\r\n\r\n  if (hasTransformLeak) {\r\n    // If the element is fixed it can not have any scroll parents.\r\n    if (getStyle(element, 'position') === 'fixed') return ret;\r\n\r\n    // Find scroll parents.\r\n    while (parent && parent !== document && parent !== document.documentElement) {\r\n      if (isScrollable(parent)) ret.push(parent);\r\n      parent = getStyle(parent, 'position') === 'fixed' ? null : parent.parentNode;\r\n    }\r\n\r\n    // If parent is not fixed element, add window object as the last scroll\r\n    // parent.\r\n    parent !== null && ret.push(window);\r\n    return ret;\r\n  }\r\n\r\n  //\r\n  // If fixed elements behave as defined in the W3C specification.\r\n  //\r\n\r\n  // Find scroll parents.\r\n  while (parent && parent !== document) {\r\n    // If the currently looped element is fixed ignore all parents that are\r\n    // not transformed.\r\n    if (getStyle(element, 'position') === 'fixed' && !isTransformed(parent)) {\r\n      parent = parent.parentNode;\r\n      continue;\r\n    }\r\n\r\n    // Add the parent element to return items if it is scrollable.\r\n    if (isScrollable(parent)) ret.push(parent);\r\n\r\n    // Update element and parent references.\r\n    element = parent;\r\n    parent = parent.parentNode;\r\n  }\r\n\r\n  // If the last item is the root element, replace it with window. The root\r\n  // element scroll is propagated to the window.\r\n  if (ret[ret.length - 1] === document.documentElement) {\r\n    ret[ret.length - 1] = window;\r\n  }\r\n  // Otherwise add window as the last scroll parent.\r\n  else {\r\n    ret.push(window);\r\n  }\r\n\r\n  return ret;\r\n}\r\n\r\n/**\r\n * Check if an element is scrollable.\r\n *\r\n * @param {HTMLElement} element\r\n * @returns {Boolean}\r\n */\r\nfunction isScrollable(element) {\r\n  let overflow = getStyle(element, 'overflow');\r\n  if (overflow === 'auto' || overflow === 'scroll') return true;\r\n\r\n  overflow = getStyle(element, 'overflow-x');\r\n  if (overflow === 'auto' || overflow === 'scroll') return true;\r\n\r\n  overflow = getStyle(element, 'overflow-y');\r\n  if (overflow === 'auto' || overflow === 'scroll') return true;\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Check if drag gesture can be interpreted as a click, based on final drag\r\n * event data.\r\n *\r\n * @param {Object} element\r\n * @returns {Boolean}\r\n */\r\nfunction isClick(event) {\r\n  return Math.abs(event.deltaX) < 2 && Math.abs(event.deltaY) < 2 && event.deltaTime < 200;\r\n}\r\n\r\n/**\r\n * Check if an element is an anchor element and open the href url if possible.\r\n *\r\n * @param {HTMLElement} element\r\n */\r\nfunction openAnchorHref(element) {\r\n  // Make sure the element is anchor element.\r\n  if (element.tagName.toLowerCase() !== 'a') return;\r\n\r\n  // Get href and make sure it exists.\r\n  const href = element.getAttribute('href');\r\n  if (!href) return;\r\n\r\n  // Finally let's navigate to the link href.\r\n  let target = element.getAttribute('target');\r\n  if (target && target !== '_self') {\r\n    window.open(href, target);\r\n  } else {\r\n    window.location.href = href;\r\n  }\r\n}\r\n\r\n/**\r\n * Detects if transformed elements leak fixed elements. According W3C\r\n * transform rendering spec a transformed element should contain even fixed\r\n * elements. Meaning that fixed elements are positioned relative to the\r\n * closest transformed ancestor element instead of window. However, not every\r\n * browser follows the spec (IE and older Firefox). So we need to test it.\r\n * https://www.w3.org/TR/css3-2d-transforms/#transform-rendering\r\n *\r\n * Borrowed from Mezr (v0.6.1):\r\n * https://github.com/niklasramo/mezr/blob/0.6.1/mezr.js#L607\r\n */\r\nfunction checkTransformLeak() {\r\n  // No transforms -> definitely leaks.\r\n  if (!isTransformSupported) return true;\r\n\r\n  // No body available -> can't check it.\r\n  if (!document.body) return null;\r\n\r\n  // Do the test.\r\n  const elems = [0, 1].map((elem, isInner) => {\r\n    elem = document.createElement('div');\r\n    elem.style.position = isInner ? 'fixed' : 'absolute';\r\n    elem.style.display = 'block';\r\n    elem.style.visibility = 'hidden';\r\n    elem.style.left = isInner ? '0px' : '1px';\r\n    elem.style[transformProp] = 'none';\r\n    return elem;\r\n  });\r\n  const outer = document.body.appendChild(elems[0]);\r\n  const inner = outer.appendChild(elems[1]);\r\n  const left = inner.getBoundingClientRect().left;\r\n  outer.style[transformProp] = 'scale(1)';\r\n  const ret = left === inner.getBoundingClientRect().left;\r\n  document.body.removeChild(outer);\r\n  return ret;\r\n}\r\n\r\nexport default ItemDrag;\r\n","/**\r\n * Muuri Queue\r\n * Copyright (c) 2018-present, Niklas Rämö <inramo@gmail.com>\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/src/Queue/LICENSE.md\r\n */\r\n\r\nimport { Component } from 'react';\r\n\r\n/**\r\n * Queue constructor.\r\n *\r\n * @class\r\n */\r\nclass Queue extends Component {\r\n  constructor() {\r\n    super();\r\n    this._queue = [];\r\n    this._isDestroyed = false;\r\n  };\r\n\r\n  /**\r\n  * Public prototype methods\r\n  * ************************\r\n  */\r\n\r\n  /**\r\n  * Add callback to the queue.\r\n  *\r\n  * @public\r\n  * @memberof Queue.prototype\r\n  * @param {Function} callback\r\n  * @returns {Queue}\r\n  */\r\n  add(callback) {\r\n    if (this._isDestroyed) return this;\r\n    this._queue.push(callback);\r\n    return this;\r\n  };\r\n\r\n  /**\r\n  * Process queue callbacks and reset the queue.\r\n  *\r\n  * @public\r\n  * @memberof Queue.prototype\r\n  * @param {*} arg1\r\n  * @param {*} arg2\r\n  * @returns {Queue}\r\n  */\r\n  flush(arg1, arg2) {\r\n    if (this._isDestroyed) return this;\r\n\r\n    const queue = this._queue;\r\n    const length = queue.length;\r\n    let i;\r\n\r\n    // Quit early if the queue is empty.\r\n    if (!length) return this;\r\n\r\n    const singleCallback = length === 1;\r\n    const snapshot = singleCallback ? queue[0] : queue.slice(0);\r\n\r\n    // Reset queue.\r\n    queue.length = 0;\r\n\r\n    // If we only have a single callback let's just call it.\r\n    if (singleCallback) {\r\n      snapshot(arg1, arg2);\r\n      return this;\r\n    }\r\n\r\n    // If we have multiple callbacks, let's process them.\r\n    for (i = 0; i < length; i++) {\r\n      snapshot[i](arg1, arg2);\r\n      if (this._isDestroyed) break;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n  * Destroy Queue instance.\r\n  *\r\n  * @public\r\n  * @memberof Queue.prototype\r\n  * @returns {Queue}\r\n  */\r\n  destroy() {\r\n    if (this._isDestroyed) return this;\r\n\r\n    this._isDestroyed = true;\r\n    this._queue.length = 0;\r\n\r\n    return this;\r\n  }\r\n}\r\n\r\nexport default Queue;\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\nimport { Component } from 'react';\r\n\r\nimport { addLayoutTick, cancelLayoutTick } from '../ticker.js';\r\n\r\nimport Queue from '../Queue/Queue.js';\r\n\r\nimport addClass from '../utils/addClass.js';\r\nimport getTranslate from '../utils/getTranslate.js';\r\nimport getTranslateString from '../utils/getTranslateString.js';\r\nimport removeClass from '../utils/removeClass.js';\r\nimport setStyles from '../utils/setStyles.js';\r\n\r\n/**\r\n * Layout manager for Item instance.\r\n *\r\n * @class\r\n * @param {Item} item\r\n */\r\nclass ItemLayout extends Component {\r\n  constructor(item) {\r\n    super(item);\r\n    this._item = item;\r\n    this._isActive = false;\r\n    this._isDestroyed = false;\r\n    this._isInterrupted = false;\r\n    this._currentStyles = {};\r\n    this._targetStyles = {};\r\n    this._currentLeft = 0;\r\n    this._currentTop = 0;\r\n    this._offsetLeft = 0;\r\n    this._offsetTop = 0;\r\n    this._skipNextAnimation = false;\r\n    this._animateOptions = {\r\n      onFinish: this._finish.bind(this)\r\n    };\r\n    this._queue = new Queue();\r\n\r\n    // Bind animation handlers and finish method.\r\n    this._setupAnimation = this._setupAnimation.bind(this);\r\n    this._startAnimation = this._startAnimation.bind(this);\r\n  }\r\n\r\n  /**\r\n   * Public prototype methods\r\n   * ************************\r\n   */\r\n\r\n  /**\r\n   * Start item layout based on it's current data.\r\n   *\r\n   * @public\r\n   * @memberof ItemLayout.prototype\r\n   * @param {Boolean} [instant=false]\r\n   * @param {Function} [onFinish]\r\n   * @returns {ItemLayout}\r\n   */\r\n  start(instant, onFinish) {\r\n    if (this._isDestroyed) return;\r\n\r\n    const item = this._item;\r\n    const element = item._element;\r\n    const release = item._release;\r\n    const gridSettings = item.getGrid()._settings;\r\n    const isPositioning = this._isActive;\r\n    const isJustReleased = release._isActive && release._isPositioningStarted === false;\r\n    const animDuration = isJustReleased\r\n      ? gridSettings.dragReleaseDuration\r\n      : gridSettings.layoutDuration;\r\n    const animEasing = isJustReleased ? gridSettings.dragReleaseEasing : gridSettings.layoutEasing;\r\n    const animEnabled = !instant && !this._skipNextAnimation && animDuration > 0;\r\n    let isAnimating;\r\n\r\n    // If the item is currently positioning process current layout callback\r\n    // queue with interrupted flag on.\r\n    if (isPositioning) this._queue.flush(true, item);\r\n\r\n    // Mark release positioning as started.\r\n    if (isJustReleased) release._isPositioningStarted = true;\r\n\r\n    // Push the callback to the callback queue.\r\n    if (typeof onFinish === 'function') this._queue.add(onFinish);\r\n\r\n    // If no animations are needed, easy peasy!\r\n    if (!animEnabled) {\r\n      this._updateOffsets();\r\n      this._updateTargetStyles();\r\n      isPositioning && cancelLayoutTick(item._id);\r\n      isAnimating = item._animate.isAnimating();\r\n      this.stop(false, this._targetStyles);\r\n      !isAnimating && setStyles(element, this._targetStyles);\r\n      this._skipNextAnimation = false;\r\n      return this._finish();\r\n    }\r\n\r\n    // Set item active and store some data for the animation that is about to be\r\n    // triggered.\r\n    this._isActive = true;\r\n    this._animateOptions.easing = animEasing;\r\n    this._animateOptions.duration = animDuration;\r\n    this._isInterrupted = isPositioning;\r\n\r\n    // Start the item's layout animation in the next tick.\r\n    addLayoutTick(item._id, this._setupAnimation, this._startAnimation);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Stop item's position animation if it is currently animating.\r\n   *\r\n   * @public\r\n   * @memberof ItemLayout.prototype\r\n   * @param {Boolean} [processCallbackQueue=false]\r\n   * @param {Object} [targetStyles]\r\n   * @returns {ItemLayout}\r\n   */\r\n  stop(processCallbackQueue, targetStyles) {\r\n    if (this._isDestroyed || !this._isActive) return this;\r\n\r\n    const item = this._item;\r\n\r\n    // Cancel animation init.\r\n    cancelLayoutTick(item._id);\r\n\r\n    // Stop animation.\r\n    item._animate.stop(targetStyles);\r\n\r\n    // Remove positioning class.\r\n    removeClass(item._element, item.getGrid()._settings.itemPositioningClass);\r\n\r\n    // Reset active state.\r\n    this._isActive = false;\r\n\r\n    // Process callback queue if needed.\r\n    if (processCallbackQueue) this._queue.flush(true, item);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Destroy the instance and stop current animation if it is running.\r\n   *\r\n   * @public\r\n   * @memberof ItemLayout.prototype\r\n   * @returns {ItemLayout}\r\n   */\r\n  destroy() {\r\n    if (this._isDestroyed) return this;\r\n    this.stop(true, {});\r\n    this._queue.destroy();\r\n    this._item = this._currentStyles = this._targetStyles = this._animateOptions = null;\r\n    this._isDestroyed = true;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Private prototype methods\r\n   * *************************\r\n   */\r\n\r\n  /**\r\n   * Calculate and update item's current layout offset data.\r\n   *\r\n   * @private\r\n   * @memberof ItemLayout.prototype\r\n   */\r\n  _updateOffsets() {\r\n    if (this._isDestroyed) return;\r\n\r\n    const item = this._item;\r\n    const migrate = item._migrate;\r\n    const release = item._release;\r\n\r\n    this._offsetLeft = release._isActive\r\n      ? release._containerDiffX\r\n      : migrate._isActive\r\n        ? migrate._containerDiffX\r\n        : 0;\r\n\r\n    this._offsetTop = release._isActive\r\n      ? release._containerDiffY\r\n      : migrate._isActive\r\n        ? migrate._containerDiffY\r\n        : 0;\r\n  }\r\n\r\n  /**\r\n   * Calculate and update item's layout target styles.\r\n   *\r\n   * @private\r\n   * @memberof ItemLayout.prototype\r\n   */\r\n  _updateTargetStyles() {\r\n    if (this._isDestroyed) return;\r\n\r\n    const item = this._item;\r\n\r\n    this._targetStyles.transform = getTranslateString(\r\n      item._left + this._offsetLeft,\r\n      item._top + this._offsetTop\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Finish item layout procedure.\r\n   *\r\n   * @private\r\n   * @memberof ItemLayout.prototype\r\n   */\r\n  _finish() {\r\n    if (this._isDestroyed) return;\r\n\r\n    const item = this._item;\r\n    const migrate = item._migrate;\r\n    const release = item._release;\r\n\r\n    // Mark the item as inactive and remove positioning classes.\r\n    if (this._isActive) {\r\n      this._isActive = false;\r\n      removeClass(item._element, item.getGrid()._settings.itemPositioningClass);\r\n    }\r\n\r\n    // Finish up release and migration.\r\n    if (release._isActive) release.stop();\r\n    if (migrate._isActive) migrate.stop();\r\n\r\n    // Process the callback queue.\r\n    this._queue.flush(false, item);\r\n  }\r\n\r\n  /**\r\n   * Prepare item for layout animation.\r\n   *\r\n   * @private\r\n   * @memberof ItemLayout.prototype\r\n   */\r\n  _setupAnimation() {\r\n    const element = this._item._element;\r\n    const translate = getTranslate(element);\r\n    this._currentLeft = translate.x;\r\n    this._currentTop = translate.y;\r\n  }\r\n\r\n  /**\r\n   * Start layout animation.\r\n   *\r\n   * @private\r\n   * @memberof ItemLayout.prototype\r\n   */\r\n  _startAnimation() {\r\n    const item = this._item;\r\n    const element = item._element;\r\n    const grid = item.getGrid();\r\n    const settings = grid._settings;\r\n\r\n    // Let's update the offset data and target styles.\r\n    this._updateOffsets();\r\n    this._updateTargetStyles();\r\n\r\n    // If the item is already in correct position let's quit early.\r\n    if (\r\n      item._left === this._currentLeft - this._offsetLeft &&\r\n      item._top === this._currentTop - this._offsetTop\r\n    ) {\r\n      if (this._isInterrupted) this.stop(false, this._targetStyles);\r\n      this._isActive = false;\r\n      this._finish();\r\n      return;\r\n    }\r\n\r\n    // Set item's positioning class if needed.\r\n    !this._isInterrupted && addClass(element, settings.itemPositioningClass);\r\n\r\n    // Get current styles for animation.\r\n    this._currentStyles.transform = getTranslateString(this._currentLeft, this._currentTop);\r\n\r\n    // Animate.\r\n    item._animate.start(this._currentStyles, this._targetStyles, this._animateOptions);\r\n  }\r\n}\r\n\r\nexport default ItemLayout;\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\nimport { Component } from 'react';\r\n\r\nimport { eventBeforeSend, eventBeforeReceive, eventSend, eventReceive } from '../shared.js';\r\n\r\nimport ItemDrag from './ItemDrag.js';\r\n\r\nimport addClass from '../utils/addClass.js';\r\nimport getOffsetDiff from '../utils/getOffsetDiff.js';\r\nimport getTranslate from '../utils/getTranslate.js';\r\nimport getTranslateString from '../utils/getTranslateString.js';\r\nimport arrayInsert from '../utils/arrayInsert.js';\r\nimport normalizeArrayIndex from '../utils/normalizeArrayIndex.js';\r\nimport removeClass from '../utils/removeClass.js';\r\nimport setStyles from '../utils/setStyles.js';\r\nimport { transformProp } from '../utils/supportedTransform.js';\r\n\r\nconst tempStyles = {};\r\n\r\n/**\r\n * The migrate process handler constructor.\r\n *\r\n * @class\r\n * @param {Item} item\r\n */\r\nclass ItemMigrate extends Component {\r\n  constructor(item) {\r\n    super(item);\r\n    // Private props.\r\n    this._item = item;\r\n    this._isActive = false;\r\n    this._isDestroyed = false;\r\n    this._container = false;\r\n    this._containerDiffX = 0;\r\n    this._containerDiffY = 0;\r\n  }\r\n\r\n  /**\r\n   * Public prototype methods\r\n   * ************************\r\n   */\r\n\r\n  /**\r\n   * Start the migrate process of an item.\r\n   *\r\n   * @public\r\n   * @memberof ItemMigrate.prototype\r\n   * @param {Grid} targetGrid\r\n   * @param {GridSingleItemQuery} position\r\n   * @param {HTMLElement} [container]\r\n   * @returns {ItemMigrate}\r\n   */\r\n  start(targetGrid, position, container) {\r\n    if (this._isDestroyed) return this;\r\n\r\n    const item = this._item;\r\n    const element = item._element;\r\n    const isVisible = item.isVisible();\r\n    const grid = item.getGrid();\r\n    const settings = grid._settings;\r\n    const targetSettings = targetGrid._settings;\r\n    const targetElement = targetGrid._element;\r\n    const targetItems = targetGrid._items;\r\n    const currentIndex = grid._items.indexOf(item);\r\n    const targetContainer = container || document.body;\r\n    let targetIndex;\r\n    let targetItem;\r\n    let currentContainer;\r\n    let offsetDiff;\r\n    let containerDiff;\r\n    let translate;\r\n    let translateX;\r\n    let translateY;\r\n\r\n    // Get target index.\r\n    if (typeof position === 'number') {\r\n      targetIndex = normalizeArrayIndex(targetItems, position, true);\r\n    } else {\r\n      targetItem = targetGrid._getItem(position);\r\n      /** @todo Consider throwing an error here instead of silently failing. */\r\n      if (!targetItem) return this;\r\n      targetIndex = targetItems.indexOf(targetItem);\r\n    }\r\n\r\n    // Get current translateX and translateY values if needed.\r\n    if (item.isPositioning() || this._isActive || item.isReleasing()) {\r\n      translate = getTranslate(element);\r\n      translateX = translate.x;\r\n      translateY = translate.y;\r\n    }\r\n\r\n    // Abort current positioning.\r\n    if (item.isPositioning()) {\r\n      item._layout.stop(true, { transform: getTranslateString(translateX, translateY) });\r\n    }\r\n\r\n    // Abort current migration.\r\n    if (this._isActive) {\r\n      translateX -= this._containerDiffX;\r\n      translateY -= this._containerDiffY;\r\n      this.stop(true, { transform: getTranslateString(translateX, translateY) });\r\n    }\r\n\r\n    // Abort current release.\r\n    if (item.isReleasing()) {\r\n      translateX -= item._release._containerDiffX;\r\n      translateY -= item._release._containerDiffY;\r\n      item._release.stop(true, { transform: getTranslateString(translateX, translateY) });\r\n    }\r\n\r\n    // Stop current visibility animations.\r\n    item._visibility._stopAnimation();\r\n\r\n    // Destroy current drag.\r\n    if (item._drag) item._drag.destroy();\r\n\r\n    // Process current visibility animation queue.\r\n    item._visibility._queue.flush(true, item);\r\n\r\n    // Emit beforeSend event.\r\n    if (grid._hasListeners(eventBeforeSend)) {\r\n      grid._emit(eventBeforeSend, {\r\n        item,\r\n        fromGrid: grid,\r\n        fromIndex: currentIndex,\r\n        toGrid: targetGrid,\r\n        toIndex: targetIndex\r\n      });\r\n    }\r\n\r\n    // Emit beforeReceive event.\r\n    if (targetGrid._hasListeners(eventBeforeReceive)) {\r\n      targetGrid._emit(eventBeforeReceive, {\r\n        item,\r\n        fromGrid: grid,\r\n        fromIndex: currentIndex,\r\n        toGrid: targetGrid,\r\n        toIndex: targetIndex\r\n      });\r\n    }\r\n\r\n    // Remove current classnames.\r\n    removeClass(element, settings.itemClass);\r\n    removeClass(element, settings.itemVisibleClass);\r\n    removeClass(element, settings.itemHiddenClass);\r\n\r\n    // Add new classnames.\r\n    addClass(element, targetSettings.itemClass);\r\n    addClass(element, isVisible ? targetSettings.itemVisibleClass : targetSettings.itemHiddenClass);\r\n\r\n    // Move item instance from current grid to target grid.\r\n    grid._items.splice(currentIndex, 1);\r\n    arrayInsert(targetItems, item, targetIndex);\r\n\r\n    // Update item's grid id reference.\r\n    item._gridId = targetGrid._id;\r\n\r\n    // Get current container.\r\n    currentContainer = element.parentNode;\r\n\r\n    // Move the item inside the target container if it's different than the\r\n    // current container.\r\n    if (targetContainer !== currentContainer) {\r\n      targetContainer.appendChild(element);\r\n      offsetDiff = getOffsetDiff(targetContainer, currentContainer, true);\r\n      if (!translate) {\r\n        translate = getTranslate(element);\r\n        translateX = translate.x;\r\n        translateY = translate.y;\r\n      }\r\n      element.style[transformProp] = getTranslateString(\r\n        translateX + offsetDiff.left,\r\n        translateY + offsetDiff.top\r\n      );\r\n    }\r\n\r\n    // Update child element's styles to reflect the current visibility state.\r\n    item._child.removeAttribute('style');\r\n    setStyles(item._child, isVisible ? targetSettings.visibleStyles : targetSettings.hiddenStyles);\r\n\r\n    // Update display style.\r\n    element.style.display = isVisible ? 'block' : 'hidden';\r\n\r\n    // Get offset diff for the migration data.\r\n    containerDiff = getOffsetDiff(targetContainer, targetElement, true);\r\n\r\n    // Update item's cached dimensions and sort data.\r\n    item._refreshDimensions();\r\n    item._refreshSortData();\r\n\r\n    // Create new drag handler.\r\n    item._drag = targetSettings.dragEnabled ? new ItemDrag(item) : null;\r\n\r\n    // Setup migration data.\r\n    this._isActive = true;\r\n    this._container = targetContainer;\r\n    this._containerDiffX = containerDiff.left;\r\n    this._containerDiffY = containerDiff.top;\r\n\r\n    // Emit send event.\r\n    if (grid._hasListeners(eventSend)) {\r\n      grid._emit(eventSend, {\r\n        item,\r\n        fromGrid: grid,\r\n        fromIndex: currentIndex,\r\n        toGrid: targetGrid,\r\n        toIndex: targetIndex\r\n      });\r\n    }\r\n\r\n    // Emit receive event.\r\n    if (targetGrid._hasListeners(eventReceive)) {\r\n      targetGrid._emit(eventReceive, {\r\n        item,\r\n        fromGrid: grid,\r\n        fromIndex: currentIndex,\r\n        toGrid: targetGrid,\r\n        toIndex: targetIndex\r\n      });\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * End the migrate process of an item. This method can be used to abort an\r\n   * ongoing migrate process (animation) or finish the migrate process.\r\n   *\r\n   * @public\r\n   * @memberof ItemMigrate.prototype\r\n   * @param {Boolean} [abort=false]\r\n   *  - Should the migration be aborted?\r\n   * @param {Object} [currentStyles]\r\n   *  - Optional current translateX and translateY styles.\r\n   * @returns {ItemMigrate}\r\n   */\r\n  stop(abort, currentStyles) {\r\n    if (this._isDestroyed || !this._isActive) return this;\r\n\r\n    const item = this._item;\r\n    const element = item._element;\r\n    const grid = item.getGrid();\r\n    const gridElement = grid._element;\r\n    let translate;\r\n\r\n    if (this._container !== gridElement) {\r\n      if (!currentStyles) {\r\n        if (abort) {\r\n          translate = getTranslate(element);\r\n          tempStyles.transform = getTranslateString(\r\n            translate.x - this._containerDiffX,\r\n            translate.y - this._containerDiffY\r\n          );\r\n        } else {\r\n          tempStyles.transform = getTranslateString(item._left, item._top);\r\n        }\r\n        currentStyles = tempStyles;\r\n      }\r\n      gridElement.appendChild(element);\r\n      setStyles(element, currentStyles);\r\n    }\r\n\r\n    this._isActive = false;\r\n    this._container = null;\r\n    this._containerDiffX = 0;\r\n    this._containerDiffY = 0;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Destroy instance.\r\n   *\r\n   * @public\r\n   * @memberof ItemMigrate.prototype\r\n   * @returns {ItemMigrate}\r\n   */\r\n  destroy() {\r\n    if (this._isDestroyed) return this;\r\n    this.stop(true);\r\n    this._item = null;\r\n    this._isDestroyed = true;\r\n    return this;\r\n  }\r\n}\r\n\r\nexport default ItemMigrate;\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\nimport { Component } from 'react';\r\n\r\nimport { eventDragReleaseStart, eventDragReleaseEnd } from '../shared.js';\r\n\r\nimport addClass from '../utils/addClass.js';\r\nimport getTranslate from '../utils/getTranslate.js';\r\nimport getTranslateString from '../utils/getTranslateString.js';\r\nimport removeClass from '../utils/removeClass.js';\r\nimport setStyles from '../utils/setStyles.js';\r\n\r\nconst tempStyles = {};\r\n\r\n/**\r\n * The release process handler constructor. Although this might seem as proper\r\n * fit for the drag process this needs to be separated into it's own logic\r\n * because there might be a scenario where drag is disabled, but the release\r\n * process still needs to be implemented (dragging from a grid to another).\r\n *\r\n * @class\r\n * @param {Item} item\r\n */\r\nclass ItemRelease extends Component {\r\n  constructor(item) {\r\n    super(item);\r\n    this._item = item;\r\n    this._isActive = false;\r\n    this._isDestroyed = false;\r\n    this._isPositioningStarted = false;\r\n    this._containerDiffX = 0;\r\n    this._containerDiffY = 0;\r\n  }\r\n\r\n  /**\r\n   * Public prototype methods\r\n   * ************************\r\n   */\r\n\r\n  /**\r\n   * Start the release process of an item.\r\n   *\r\n   * @public\r\n   * @memberof ItemRelease.prototype\r\n   * @returns {ItemRelease}\r\n   */\r\n  start() {\r\n    if (this._isDestroyed || this._isActive) return this;\r\n\r\n    const item = this._item;\r\n    const grid = item.getGrid();\r\n\r\n    // Flag release as active.\r\n    this._isActive = true;\r\n\r\n    // Add release class name to the released element.\r\n    addClass(item._element, grid._settings.itemReleasingClass);\r\n\r\n    // Emit dragReleaseStart event.\r\n    grid._emit(eventDragReleaseStart, item);\r\n\r\n    // Position the released item.\r\n    item._layout.start(false);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * End the release process of an item. This method can be used to abort an\r\n   * ongoing release process (animation) or finish the release process.\r\n   *\r\n   * @public\r\n   * @memberof ItemRelease.prototype\r\n   * @param {Boolean} [abort=false]\r\n   *  - Should the release be aborted? When true, the release end event won't be\r\n   *    emitted. Set to true only when you need to abort the release process\r\n   *    while the item is animating to it's position.\r\n   * @param {Object} [currentStyles]\r\n   *  - Optional current translateX and translateY styles.\r\n   * @returns {ItemRelease}\r\n   */\r\n  stop(abort, currentStyles) {\r\n    if (this._isDestroyed || !this._isActive) return this;\r\n\r\n    const item = this._item;\r\n    const element = item._element;\r\n    const grid = item.getGrid();\r\n    const container = grid._element;\r\n    let translate;\r\n\r\n    // Reset data and remove releasing class name from the element.\r\n    this._reset();\r\n\r\n    // If the released element is outside the grid's container element put it\r\n    // back there and adjust position accordingly.\r\n    if (element.parentNode !== container) {\r\n      if (!currentStyles) {\r\n        if (abort) {\r\n          translate = getTranslate(element);\r\n          tempStyles.transform = getTranslateString(\r\n            translate.x - this._containerDiffX,\r\n            translate.y - this._containerDiffY\r\n          );\r\n        } else {\r\n          tempStyles.transform = getTranslateString(item._left, item._top);\r\n        }\r\n        currentStyles = tempStyles;\r\n      }\r\n      container.appendChild(element);\r\n      setStyles(element, currentStyles);\r\n    }\r\n\r\n    // Emit dragReleaseEnd event.\r\n    if (!abort) grid._emit(eventDragReleaseEnd, item);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Destroy instance.\r\n   *\r\n   * @public\r\n   * @memberof ItemRelease.prototype\r\n   * @returns {ItemRelease}\r\n   */\r\n  destroy() {\r\n    if (this._isDestroyed) return this;\r\n    this.stop(true);\r\n    this._item = null;\r\n    this._isDestroyed = true;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Private prototype methods\r\n   * *************************\r\n   */\r\n\r\n  /**\r\n   * Reset public data and remove releasing class.\r\n   *\r\n   * @private\r\n   * @memberof ItemRelease.prototype\r\n   */\r\n  _reset() {\r\n    if (this._isDestroyed) return;\r\n    const item = this._item;\r\n    this._isActive = false;\r\n    this._isPositioningStarted = false;\r\n    this._containerDiffX = 0;\r\n    this._containerDiffY = 0;\r\n    removeClass(item._element, item.getGrid()._settings.itemReleasingClass);\r\n  }\r\n}\r\n\r\nexport default ItemRelease;\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\nimport getStyle from './getStyle.js';\r\nimport getStyleName from './getStyleName.js';\r\n\r\n/**\r\n * Get current values of the provided styles definition object.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {Object} styles\r\n * @return {Object}\r\n */\r\nexport default function getCurrentStyles(element, styles) {\r\n  const current = {};\r\n  for (const prop in styles) {\r\n    current[prop] = getStyle(element, getStyleName(prop));\r\n  }\r\n  return current;\r\n}\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\nimport { Component } from 'react';\r\n\r\nimport { addVisibilityTick, cancelVisibilityTick } from '../ticker.js';\r\n\r\nimport Queue from '../Queue/Queue.js';\r\n\r\nimport addClass from '../utils/addClass.js';\r\nimport getCurrentStyles from '../utils/getCurrentStyles.js';\r\nimport getTranslateString from '../utils/getTranslateString.js';\r\nimport removeClass from '../utils/removeClass.js';\r\nimport setStyles from '../utils/setStyles.js';\r\n\r\n/**\r\n * Visibility manager for Item instance.\r\n *\r\n * @class\r\n * @param {Item} item\r\n */\r\nclass ItemVisibility extends Component {\r\n  constructor(item) {\r\n    super(item);\r\n    const isActive = item._isActive;\r\n    const element = item._element;\r\n    const settings = item.getGrid()._settings;\r\n\r\n    this._item = item;\r\n    this._isDestroyed = false;\r\n\r\n    // Set up visibility states.\r\n    this._isHidden = !isActive;\r\n    this._isHiding = false;\r\n    this._isShowing = false;\r\n\r\n    // Callback queue.\r\n    this._queue = new Queue();\r\n\r\n    // Bind show/hide finishers.\r\n    this._finishShow = this._finishShow.bind(this);\r\n    this._finishHide = this._finishHide.bind(this);\r\n\r\n    // Force item to be either visible or hidden on init.\r\n    element.style.display = isActive ? 'block' : 'none';\r\n\r\n    // Set visible/hidden class.\r\n    addClass(element, isActive ? settings.itemVisibleClass : settings.itemHiddenClass);\r\n\r\n    // Set initial styles for the child element.\r\n    setStyles(item._child, isActive ? settings.visibleStyles : settings.hiddenStyles);\r\n  }\r\n\r\n  /**\r\n   * Public prototype methods\r\n   * ************************\r\n   */\r\n\r\n  /**\r\n   * Show item.\r\n   *\r\n   * @public\r\n   * @memberof ItemVisibility.prototype\r\n   * @param {Boolean} instant\r\n   * @param {Function} [onFinish]\r\n   * @returns {ItemVisibility}\r\n   */\r\n  show(instant, onFinish) {\r\n    if (this._isDestroyed) return this;\r\n\r\n    const item = this._item;\r\n    const element = item._element;\r\n    const queue = this._queue;\r\n    const callback = typeof onFinish === 'function' ? onFinish : null;\r\n    const grid = item.getGrid();\r\n    const settings = grid._settings;\r\n\r\n    // If item is visible call the callback and be done with it.\r\n    if (!this._isShowing && !this._isHidden) {\r\n      callback && callback(false, item);\r\n      return this;\r\n    }\r\n\r\n    // If item is showing and does not need to be shown instantly, let's just\r\n    // push callback to the callback queue and be done with it.\r\n    if (this._isShowing && !instant) {\r\n      callback && queue.add(callback);\r\n      return this;\r\n    }\r\n\r\n    // If the item is hiding or hidden process the current visibility callback\r\n    // queue with the interrupted flag active, update classes and set display\r\n    // to block if necessary.\r\n    if (!this._isShowing) {\r\n      queue.flush(true, item);\r\n      removeClass(element, settings.itemHiddenClass);\r\n      addClass(element, settings.itemVisibleClass);\r\n      if (!this._isHiding) element.style.display = 'block';\r\n    }\r\n\r\n    // Push callback to the callback queue.\r\n    callback && queue.add(callback);\r\n\r\n    // Update visibility states.\r\n    item._isActive = this._isShowing = true;\r\n    this._isHiding = this._isHidden = false;\r\n\r\n    // Finally let's start show animation.\r\n    this._startAnimation(true, instant, this._finishShow);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Hide item.\r\n   *\r\n   * @public\r\n   * @memberof ItemVisibility.prototype\r\n   * @param {Boolean} instant\r\n   * @param {Function} [onFinish]\r\n   * @returns {ItemVisibility}\r\n   */\r\n  hide(instant, onFinish) {\r\n    if (this._isDestroyed) return this;\r\n\r\n    const item = this._item;\r\n    const element = item._element;\r\n    const queue = this._queue;\r\n    const callback = typeof onFinish === 'function' ? onFinish : null;\r\n    const grid = item.getGrid();\r\n    const settings = grid._settings;\r\n\r\n    // If item is already hidden call the callback and be done with it.\r\n    if (!this._isHiding && this._isHidden) {\r\n      callback && callback(false, item);\r\n      return this;\r\n    }\r\n\r\n    // If item is hiding and does not need to be hidden instantly, let's just\r\n    // push callback to the callback queue and be done with it.\r\n    if (this._isHiding && !instant) {\r\n      callback && queue.add(callback);\r\n      return this;\r\n    }\r\n\r\n    // If the item is showing or visible process the current visibility callback\r\n    // queue with the interrupted flag active, update classes and set display\r\n    // to block if necessary.\r\n    if (!this._isHiding) {\r\n      queue.flush(true, item);\r\n      addClass(element, settings.itemHiddenClass);\r\n      removeClass(element, settings.itemVisibleClass);\r\n    }\r\n\r\n    // Push callback to the callback queue.\r\n    callback && queue.add(callback);\r\n\r\n    // Update visibility states.\r\n    this._isHidden = this._isHiding = true;\r\n    item._isActive = this._isShowing = false;\r\n\r\n    // Finally let's start hide animation.\r\n    this._startAnimation(false, instant, this._finishHide);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Destroy the instance and stop current animation if it is running.\r\n   *\r\n   * @public\r\n   * @memberof ItemVisibility.prototype\r\n   * @returns {ItemVisibility}\r\n   */\r\n  destroy() {\r\n    if (this._isDestroyed) return this;\r\n\r\n    const item = this._item;\r\n    const element = item._element;\r\n    const grid = item.getGrid();\r\n    const queue = this._queue;\r\n    const settings = grid._settings;\r\n\r\n    // Stop visibility animation.\r\n    this._stopAnimation({});\r\n\r\n    // Fire all uncompleted callbacks with interrupted flag and destroy the queue.\r\n    queue.flush(true, item).destroy();\r\n\r\n    // Remove visible/hidden classes.\r\n    removeClass(element, settings.itemVisibleClass);\r\n    removeClass(element, settings.itemHiddenClass);\r\n\r\n    // Reset state.\r\n    this._item = null;\r\n    this._isHiding = this._isShowing = false;\r\n    this._isDestroyed = this._isHidden = true;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Private prototype methods\r\n   * *************************\r\n   */\r\n\r\n  /**\r\n   * Start visibility animation.\r\n   *\r\n   * @private\r\n   * @memberof ItemVisibility.prototype\r\n   * @param {Boolean} toVisible\r\n   * @param {Boolean} [instant]\r\n   * @param {Function} [onFinish]\r\n   */\r\n  _startAnimation(toVisible, instant, onFinish) {\r\n    if (this._isDestroyed) return;\r\n\r\n    const item = this._item;\r\n    const settings = item.getGrid()._settings;\r\n    const targetStyles = toVisible ? settings.visibleStyles : settings.hiddenStyles;\r\n    const duration = parseInt(toVisible ? settings.showDuration : settings.hideDuration) || 0;\r\n    const easing = (toVisible ? settings.showEasing : settings.hideEasing) || 'ease';\r\n    const isInstant = instant || duration <= 0;\r\n    let currentStyles;\r\n\r\n    // No target styles? Let's quit early.\r\n    if (!targetStyles) {\r\n      onFinish && onFinish();\r\n      return;\r\n    }\r\n\r\n    // Cancel queued visibility tick.\r\n    cancelVisibilityTick(item._id);\r\n\r\n    // If we need to apply the styles instantly without animation.\r\n    if (isInstant) {\r\n      if (item._animateChild.isAnimating()) {\r\n        item._animateChild.stop(targetStyles);\r\n      } else {\r\n        setStyles(item._child, targetStyles);\r\n      }\r\n      onFinish && onFinish();\r\n      return;\r\n    }\r\n\r\n    // Start the animation in the next tick (to avoid layout thrashing).\r\n    addVisibilityTick(\r\n      item._id,\r\n      () => {\r\n        currentStyles = getCurrentStyles(item._child, targetStyles);\r\n      },\r\n      () => {\r\n        item._animateChild.start(currentStyles, targetStyles, {\r\n          duration,\r\n          easing,\r\n          onFinish\r\n        });\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Stop visibility animation.\r\n   *\r\n   * @private\r\n   * @memberof ItemVisibility.prototype\r\n   * @param {Object} [targetStyles]\r\n   */\r\n  _stopAnimation(targetStyles) {\r\n    if (this._isDestroyed) return;\r\n    const item = this._item;\r\n    cancelVisibilityTick(item._id);\r\n    item._animateChild.stop(targetStyles);\r\n  }\r\n\r\n  /**\r\n   * Finish show procedure.\r\n   *\r\n   * @private\r\n   * @memberof ItemVisibility.prototype\r\n   */\r\n  _finishShow() {\r\n    if (this._isHidden) return;\r\n    this._isShowing = false;\r\n    this._queue.flush(false, this._item);\r\n  }\r\n\r\n  _finishHide() {\r\n    if (!this._isHidden) return;\r\n    const item = this._item;\r\n    this._isHiding = false;\r\n    finishStyles.transform = getTranslateString(0, 0);\r\n    item._layout.stop(true, finishStyles);\r\n    item._element.style.display = 'none';\r\n    this._queue.flush(false, item);\r\n  }\r\n}\r\n\r\n/**\r\n * Finish hide procedure.\r\n *\r\n * @private\r\n * @memberof ItemVisibility.prototype\r\n */\r\nconst finishStyles = {};\r\n\r\nexport default ItemVisibility;\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\nlet id = 0;\r\n\r\n/**\r\n * Returns a unique numeric id (increments a base value on every call).\r\n * @returns {Number}\r\n */\r\nexport default function createUid() {\r\n  return ++id;\r\n}\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\nimport { gridInstances } from '../shared.js';\r\n\r\nimport ItemAnimate from './ItemAnimate.js';\r\nimport ItemDrag from './ItemDrag.js';\r\nimport ItemLayout from './ItemLayout.js';\r\nimport ItemMigrate from './ItemMigrate.js';\r\nimport ItemRelease from './ItemRelease.js';\r\nimport ItemVisibility from './ItemVisibility.js';\r\n\r\nimport addClass from '../utils/addClass.js';\r\nimport createUid from '../utils/createUid.js';\r\nimport getStyle from '../utils/getStyle.js';\r\nimport getStyleAsFloat from '../utils/getStyleAsFloat.js';\r\nimport getTranslateString from '../utils/getTranslateString.js';\r\nimport removeClass from '../utils/removeClass.js';\r\nimport { transformProp } from '../utils/supportedTransform.js';\r\n\r\n/**\r\n * Creates a new Item instance for a Grid instance.\r\n *\r\n * @class\r\n * @param {Grid} grid\r\n * @param {HTMLElement} element\r\n * @param {Boolean} [isActive]\r\n */\r\nclass Item {\r\n  constructor(grid, element, isActive) {\r\n    const settings = grid._settings;\r\n\r\n    // Create instance id.\r\n    this._id = createUid();\r\n\r\n    // Reference to connected Grid instance's id.\r\n    this._gridId = grid._id;\r\n\r\n    // Destroyed flag.\r\n    this._isDestroyed = false;\r\n\r\n    // Set up initial positions.\r\n    this._left = 0;\r\n    this._top = 0;\r\n\r\n    // The elements.\r\n    this._element = element;\r\n    this._child = element.children[0];\r\n\r\n    // If the provided item element is not a direct child of the grid container\r\n    // element, append it to the grid container.\r\n    if (element.parentNode !== grid._element) {\r\n      grid._element.appendChild(element);\r\n    }\r\n\r\n    // Set item class.\r\n    addClass(element, settings.itemClass);\r\n\r\n    // If isActive is not defined, let's try to auto-detect it.\r\n    if (typeof isActive !== 'boolean') {\r\n      isActive = getStyle(element, 'display') !== 'none';\r\n    }\r\n\r\n    // Set up active state (defines if the item is considered part of the layout\r\n    // or not).\r\n    this._isActive = isActive;\r\n\r\n    // Set element's initial position styles.\r\n    element.style.left = '0';\r\n    element.style.top = '0';\r\n    element.style[transformProp] = getTranslateString(0, 0);\r\n\r\n    // Initiate item's animation controllers.\r\n    this._animate = new ItemAnimate(element);\r\n    this._animateChild = new ItemAnimate(this._child);\r\n\r\n    // Setup visibility handler.\r\n    this._visibility = new ItemVisibility(this);\r\n\r\n    // Set up layout handler.\r\n    this._layout = new ItemLayout(this);\r\n\r\n    // Set up migration handler data.\r\n    this._migrate = new ItemMigrate(this);\r\n\r\n    // Set up release handler\r\n    this._release = new ItemRelease(this);\r\n\r\n    // Set up drag handler.\r\n    this._drag = settings.dragEnabled ? new ItemDrag(this) : null;\r\n\r\n    // Set up the initial dimensions and sort data.\r\n    this._refreshDimensions();\r\n    this._refreshSortData();\r\n  }\r\n\r\n  /**\r\n   * Public prototype methods\r\n   * ************************\r\n   */\r\n\r\n  /**\r\n   * Get the instance grid reference.\r\n   *\r\n   * @public\r\n   * @memberof Item.prototype\r\n   * @returns {Grid}\r\n   */\r\n  getGrid() {\r\n    return gridInstances[this._gridId];\r\n  }\r\n\r\n  /**\r\n   * Get the instance element.\r\n   *\r\n   * @public\r\n   * @memberof Item.prototype\r\n   * @returns {HTMLElement}\r\n   */\r\n  getElement() {\r\n    return this._element;\r\n  }\r\n\r\n  /**\r\n   * Get instance element's cached width.\r\n   *\r\n   * @public\r\n   * @memberof Item.prototype\r\n   * @returns {Number}\r\n   */\r\n  getWidth() {\r\n    return this._width;\r\n  }\r\n\r\n  /**\r\n   * Get instance element's cached height.\r\n   *\r\n   * @public\r\n   * @memberof Item.prototype\r\n   * @returns {Number}\r\n   */\r\n  getHeight() {\r\n    return this._height;\r\n  }\r\n\r\n  /**\r\n   * Get instance element's cached margins.\r\n   *\r\n   * @public\r\n   * @memberof Item.prototype\r\n   * @returns {Object}\r\n   *   - The returned object contains left, right, top and bottom properties\r\n   *     which indicate the item element's cached margins.\r\n   */\r\n  getMargin() {\r\n    return {\r\n      left: this._marginLeft,\r\n      right: this._marginRight,\r\n      top: this._marginTop,\r\n      bottom: this._marginBottom\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get instance element's cached position.\r\n   *\r\n   * @public\r\n   * @memberof Item.prototype\r\n   * @returns {Object}\r\n   *   - The returned object contains left and top properties which indicate the\r\n   *     item element's cached position in the grid.\r\n   */\r\n  getPosition() {\r\n    return {\r\n      left: this._left,\r\n      top: this._top\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Is the item active?\r\n   *\r\n   * @public\r\n   * @memberof Item.prototype\r\n   * @returns {Boolean}\r\n   */\r\n  isActive() {\r\n    return this._isActive;\r\n  }\r\n\r\n  /**\r\n   * Is the item visible?\r\n   *\r\n   * @public\r\n   * @memberof Item.prototype\r\n   * @returns {Boolean}\r\n   */\r\n  isVisible() {\r\n    return !!this._visibility && !this._visibility._isHidden;\r\n  }\r\n\r\n  /**\r\n   * Is the item being animated to visible?\r\n   *\r\n   * @public\r\n   * @memberof Item.prototype\r\n   * @returns {Boolean}\r\n   */\r\n  isShowing() {\r\n    return !!(this._visibility && this._visibility._isShowing);\r\n  }\r\n\r\n  /**\r\n   * Is the item being animated to hidden?\r\n   *\r\n   * @public\r\n   * @memberof Item.prototype\r\n   * @returns {Boolean}\r\n   */\r\n  isHiding() {\r\n    return !!(this._visibility && this._visibility._isHiding);\r\n  }\r\n\r\n  /**\r\n   * Is the item positioning?\r\n   *\r\n   * @public\r\n   * @memberof Item.prototype\r\n   * @returns {Boolean}\r\n   */\r\n  isPositioning() {\r\n    return !!(this._layout && this._layout._isActive);\r\n  }\r\n\r\n  /**\r\n   * Is the item being dragged?\r\n   *\r\n   * @public\r\n   * @memberof Item.prototype\r\n   * @returns {Boolean}\r\n   */\r\n  isDragging() {\r\n    return !!(this._drag && this._drag._isActive);\r\n  }\r\n\r\n  /**\r\n   * Is the item being released?\r\n   *\r\n   * @public\r\n   * @memberof Item.prototype\r\n   * @returns {Boolean}\r\n   */\r\n  isReleasing() {\r\n    return !!(this._release && this._release._isActive);\r\n  }\r\n\r\n  /**\r\n   * Is the item destroyed?\r\n   *\r\n   * @public\r\n   * @memberof Item.prototype\r\n   * @returns {Boolean}\r\n   */\r\n  isDestroyed() {\r\n    return this._isDestroyed;\r\n  }\r\n\r\n  /**\r\n   * Private prototype methods\r\n   * *************************\r\n   */\r\n\r\n  /**\r\n   * Recalculate item's dimensions.\r\n   *\r\n   * @private\r\n   * @memberof Item.prototype\r\n   */\r\n  _refreshDimensions() {\r\n    if (this._isDestroyed || this._visibility._isHidden) return;\r\n\r\n    const element = this._element;\r\n    const rect = element.getBoundingClientRect();\r\n\r\n    // Calculate width and height.\r\n    this._width = rect.width;\r\n    this._height = rect.height;\r\n\r\n    // Calculate margins (ignore negative margins).\r\n    this._marginLeft = Math.max(0, getStyleAsFloat(element, 'margin-left'));\r\n    this._marginRight = Math.max(0, getStyleAsFloat(element, 'margin-right'));\r\n    this._marginTop = Math.max(0, getStyleAsFloat(element, 'margin-top'));\r\n    this._marginBottom = Math.max(0, getStyleAsFloat(element, 'margin-bottom'));\r\n  }\r\n\r\n  /**\r\n   * Fetch and store item's sort data.\r\n   *\r\n   * @private\r\n   * @memberof Item.prototype\r\n   */\r\n  _refreshSortData() {\r\n    if (this._isDestroyed) return;\r\n\r\n    const data = (this._sortData = {});\r\n    const getters = this.getGrid()._settings.sortData;\r\n    let prop;\r\n\r\n    for (prop in getters) {\r\n      data[prop] = getters[prop](this, this._element);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Destroy item instance.\r\n   *\r\n   * @private\r\n   * @memberof Item.prototype\r\n   * @param {Boolean} [removeElement=false]\r\n   */\r\n  _destroy(removeElement) {\r\n    if (this._isDestroyed) return;\r\n\r\n    const element = this._element;\r\n    const grid = this.getGrid();\r\n    const settings = grid._settings;\r\n    const index = grid._items.indexOf(this);\r\n\r\n    // Destroy handlers.\r\n    this._release.destroy();\r\n    this._migrate.destroy();\r\n    this._layout.destroy();\r\n    this._visibility.destroy();\r\n    this._animate.destroy();\r\n    this._animateChild.destroy();\r\n    this._drag && this._drag.destroy();\r\n\r\n    // Remove all inline styles.\r\n    element.removeAttribute('style');\r\n    this._child.removeAttribute('style');\r\n\r\n    // Remove item class.\r\n    removeClass(element, settings.itemClass);\r\n\r\n    // Remove item from Grid instance if it still exists there.\r\n    index > -1 && grid._items.splice(index, 1);\r\n\r\n    // Remove element from DOM.\r\n    removeElement && element.parentNode.removeChild(element);\r\n\r\n    // Reset state.\r\n    this._isActive = false;\r\n    this._isDestroyed = true;\r\n  }\r\n}\r\n\r\nexport default Item;\r\n","/**\r\n * Muuri Packer\r\n * Copyright (c) 2016-present, Niklas Rämö <inramo@gmail.com>\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/src/Packer/LICENSE.md\r\n */\r\n\r\nimport { Component } from 'react';\r\n\r\n/**\r\n * This is the default layout algorithm for Muuri. Based on MAXRECTS approach\r\n * as described by Jukka Jylänki in his survey: \"A Thousand Ways to Pack the\r\n * Bin - A Practical Approach to Two-Dimensional Rectangle Bin Packing.\".\r\n *\r\n * @class\r\n */\r\nclass Packer extends Component {\r\n  constructor() {\r\n    super();\r\n    this._slots = [];\r\n    this._slotSizes = [];\r\n    this._freeSlots = [];\r\n    this._newSlots = [];\r\n    this._rectItem = {};\r\n    this._rectStore = [];\r\n    this._rectId = 0;\r\n\r\n    // The layout return data, which will be populated in getLayout.\r\n    this._layout = {\r\n      slots: null,\r\n      setWidth: false,\r\n      setHeight: false,\r\n      width: false,\r\n      height: false\r\n    };\r\n\r\n    // Bind sort handlers.\r\n    this._sortRectsLeftTop = this._sortRectsLeftTop.bind(this);\r\n    this._sortRectsTopLeft = this._sortRectsTopLeft.bind(this);\r\n  }\r\n\r\n  /**\r\n   * @public\r\n   * @memberof Packer.prototype\r\n   * @param {Item[]} items\r\n   * @param {Number} width\r\n   * @param {Number} height\r\n   * @param {Number[]} [slots]\r\n   * @param {Object} [options]\r\n   * @param {Boolean} [options.fillGaps=false]\r\n   * @param {Boolean} [options.horizontal=false]\r\n   * @param {Boolean} [options.alignRight=false]\r\n   * @param {Boolean} [options.alignBottom=false]\r\n   * @returns {LayoutData}\r\n   */\r\n  getLayout(items, width, height, slots, options) {\r\n    const layout = this._layout;\r\n    const fillGaps = !!(options && options.fillGaps);\r\n    const isHorizontal = !!(options && options.horizontal);\r\n    const alignRight = !!(options && options.alignRight);\r\n    const alignBottom = !!(options && options.alignBottom);\r\n    const rounding = !!(options && options.rounding);\r\n    const slotSizes = this._slotSizes;\r\n    let i;\r\n\r\n    // Reset layout data.\r\n    layout.slots = slots || this._slots;\r\n    layout.width = isHorizontal ? 0 : rounding ? Math.round(width) : width;\r\n    layout.height = !isHorizontal ? 0 : rounding ? Math.round(height) : height;\r\n    layout.setWidth = isHorizontal;\r\n    layout.setHeight = !isHorizontal;\r\n\r\n    // Make sure slots and slot size arrays are reset.\r\n    layout.slots.length = 0;\r\n    slotSizes.length = 0;\r\n\r\n    // No need to go further if items do not exist.\r\n    if (!items.length) return layout;\r\n\r\n    // Find slots for items.\r\n    for (i = 0; i < items.length; i++) {\r\n      this._addSlot(items[i], isHorizontal, fillGaps, rounding, alignRight || alignBottom);\r\n    }\r\n\r\n    // If the alignment is set to right we need to adjust the results.\r\n    if (alignRight) {\r\n      for (i = 0; i < layout.slots.length; i = i + 2) {\r\n        layout.slots[i] = layout.width - (layout.slots[i] + slotSizes[i]);\r\n      }\r\n    }\r\n\r\n    // If the alignment is set to bottom we need to adjust the results.\r\n    if (alignBottom) {\r\n      for (i = 1; i < layout.slots.length; i = i + 2) {\r\n        layout.slots[i] = layout.height - (layout.slots[i] + slotSizes[i]);\r\n      }\r\n    }\r\n\r\n    // Reset slots arrays and rect id.\r\n    slotSizes.length = 0;\r\n    this._freeSlots.length = 0;\r\n    this._newSlots.length = 0;\r\n    this._rectId = 0;\r\n\r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Add a new rectangle to the rectangle store. Returns the id of the new\r\n   * rectangle.\r\n   *\r\n   * @private\r\n   * @memberof Packer.prototype\r\n   * @param {Number} left\r\n   * @param {Number} top\r\n   * @param {Number} width\r\n   * @param {Number} height\r\n   * @returns {RectId}\r\n   */\r\n  _addRect(left, top, width, height) {\r\n    const rectId = ++this._rectId;\r\n    const rectStore = this._rectStore;\r\n\r\n    rectStore[rectId] = left || 0;\r\n    rectStore[++this._rectId] = top || 0;\r\n    rectStore[++this._rectId] = width || 0;\r\n    rectStore[++this._rectId] = height || 0;\r\n\r\n    return rectId;\r\n  }\r\n\r\n  /**\r\n   * Get rectangle data from the rectangle store by id. Optionally you can\r\n   * provide a target object where the rectangle data will be written in. By\r\n   * default an internal object is reused as a target object.\r\n   *\r\n   * @private\r\n   * @memberof Packer.prototype\r\n   * @param {RectId} id\r\n   * @param {Object} [target]\r\n   * @returns {Object}\r\n   */\r\n  _getRect(id, target) {\r\n    const rectItem = target || this._rectItem;\r\n    const rectStore = this._rectStore;\r\n\r\n    rectItem.left = rectStore[id] || 0;\r\n    rectItem.top = rectStore[++id] || 0;\r\n    rectItem.width = rectStore[++id] || 0;\r\n    rectItem.height = rectStore[++id] || 0;\r\n\r\n    return rectItem;\r\n  }\r\n\r\n  /**\r\n   * Check if two rectangles overlap.\r\n   *\r\n   * @private\r\n   * @memberof Packer.prototype\r\n   * @param {Rectangle} a\r\n   * @param {Rectangle} b\r\n   * @returns {Boolean}\r\n   */\r\n  _doRectsOverlap(a, b) {\r\n    return !(\r\n      a.left + a.width <= b.left ||\r\n      b.left + b.width <= a.left ||\r\n      a.top + a.height <= b.top ||\r\n      b.top + b.height <= a.top\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Check if a rectangle is fully within another rectangle.\r\n   *\r\n   * @private\r\n   * @memberof Packer.prototype\r\n   * @param {Rectangle} a\r\n   * @param {Rectangle} b\r\n   * @returns {Boolean}\r\n   */\r\n  _isRectWithinRect(a, b) {\r\n    return (\r\n      a.left >= b.left &&\r\n      a.top >= b.top &&\r\n      a.left + a.width <= b.left + b.width &&\r\n      a.top + a.height <= b.top + b.height\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate position for the layout item. Returns the left and top position\r\n * of the item in pixels.\r\n *\r\n * @private\r\n * @memberof Packer.prototype\r\n * @param {Item} item\r\n * @param {Boolean} isHorizontal\r\n * @param {Boolean} fillGaps\r\n * @param {Boolean} rounding\r\n * @returns {Array}\r\n */\r\nPacker.prototype._addSlot = ((() => {\r\n  const leeway = 0.001;\r\n  const itemSlot = {};\r\n  return function(item, isHorizontal, fillGaps, rounding, trackSize) {\r\n    const layout = this._layout;\r\n    const freeSlots = this._freeSlots;\r\n    const newSlots = this._newSlots;\r\n    let rect;\r\n    let rectId;\r\n    let potentialSlots;\r\n    let ignoreCurrentSlots;\r\n    let i;\r\n    let ii;\r\n\r\n    // Reset new slots.\r\n    newSlots.length = 0;\r\n\r\n    // Set item slot initial data.\r\n    itemSlot.left = null;\r\n    itemSlot.top = null;\r\n    itemSlot.width = item._width + item._marginLeft + item._marginRight;\r\n    itemSlot.height = item._height + item._marginTop + item._marginBottom;\r\n\r\n    // Round item slot width and height if needed.\r\n    if (rounding) {\r\n      itemSlot.width = Math.round(itemSlot.width);\r\n      itemSlot.height = Math.round(itemSlot.height);\r\n    }\r\n\r\n    // Try to find a slot for the item.\r\n    for (i = 0; i < freeSlots.length; i++) {\r\n      rectId = freeSlots[i];\r\n      if (!rectId) continue;\r\n      rect = this._getRect(rectId);\r\n      if (itemSlot.width <= rect.width + leeway && itemSlot.height <= rect.height + leeway) {\r\n        itemSlot.left = rect.left;\r\n        itemSlot.top = rect.top;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // If no slot was found for the item.\r\n    if (itemSlot.left === null) {\r\n      // Position the item in to the bottom left (vertical mode) or top right\r\n      // (horizontal mode) of the grid.\r\n      itemSlot.left = !isHorizontal ? 0 : layout.width;\r\n      itemSlot.top = !isHorizontal ? layout.height : 0;\r\n\r\n      // If gaps don't needs filling do not add any current slots to the new\r\n      // slots array.\r\n      if (!fillGaps) {\r\n        ignoreCurrentSlots = true;\r\n      }\r\n    }\r\n\r\n    // In vertical mode, if the item's bottom overlaps the grid's bottom.\r\n    if (!isHorizontal && itemSlot.top + itemSlot.height > layout.height) {\r\n      // If item is not aligned to the left edge, create a new slot.\r\n      if (itemSlot.left > 0) {\r\n        newSlots.push(this._addRect(0, layout.height, itemSlot.left, Infinity));\r\n      }\r\n\r\n      // If item is not aligned to the right edge, create a new slot.\r\n      if (itemSlot.left + itemSlot.width < layout.width) {\r\n        newSlots.push(\r\n          this._addRect(\r\n            itemSlot.left + itemSlot.width,\r\n            layout.height,\r\n            layout.width - itemSlot.left - itemSlot.width,\r\n            Infinity\r\n          )\r\n        );\r\n      }\r\n\r\n      // Update grid height.\r\n      layout.height = itemSlot.top + itemSlot.height;\r\n    }\r\n\r\n    // In horizontal mode, if the item's right overlaps the grid's right edge.\r\n    if (isHorizontal && itemSlot.left + itemSlot.width > layout.width) {\r\n      // If item is not aligned to the top, create a new slot.\r\n      if (itemSlot.top > 0) {\r\n        newSlots.push(this._addRect(layout.width, 0, Infinity, itemSlot.top));\r\n      }\r\n\r\n      // If item is not aligned to the bottom, create a new slot.\r\n      if (itemSlot.top + itemSlot.height < layout.height) {\r\n        newSlots.push(\r\n          this._addRect(\r\n            layout.width,\r\n            itemSlot.top + itemSlot.height,\r\n            Infinity,\r\n            layout.height - itemSlot.top - itemSlot.height\r\n          )\r\n        );\r\n      }\r\n\r\n      // Update grid width.\r\n      layout.width = itemSlot.left + itemSlot.width;\r\n    }\r\n\r\n    // Clean up the current slots making sure there are no old slots that\r\n    // overlap with the item. If an old slot overlaps with the item, split it\r\n    // into smaller slots if necessary.\r\n    for (i = fillGaps ? 0 : ignoreCurrentSlots ? freeSlots.length : i; i < freeSlots.length; i++) {\r\n      rectId = freeSlots[i];\r\n      if (!rectId) continue;\r\n      rect = this._getRect(rectId);\r\n      potentialSlots = this._splitRect(rect, itemSlot);\r\n      for (ii = 0; ii < potentialSlots.length; ii++) {\r\n        rectId = potentialSlots[ii];\r\n        rect = this._getRect(rectId);\r\n        // Let's make sure here that we have a big enough slot\r\n        // (width/height > 0.49px) and also let's make sure that the slot is\r\n        // within the boundaries of the grid.\r\n        if (\r\n          rect.width > 0.49 &&\r\n          rect.height > 0.49 &&\r\n          ((!isHorizontal && rect.top < layout.height) ||\r\n            (isHorizontal && rect.left < layout.width))\r\n        ) {\r\n          newSlots.push(rectId);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Sanitize new slots.\r\n    if (newSlots.length) {\r\n      this._purgeRects(newSlots).sort(\r\n        isHorizontal ? this._sortRectsLeftTop : this._sortRectsTopLeft\r\n      );\r\n    }\r\n\r\n    // Update layout width/height.\r\n    if (isHorizontal) {\r\n      layout.width = Math.max(layout.width, itemSlot.left + itemSlot.width);\r\n    } else {\r\n      layout.height = Math.max(layout.height, itemSlot.top + itemSlot.height);\r\n    }\r\n\r\n    // Add item slot data to layout slots (and store the slot size for later\r\n    // usage too if necessary).\r\n    layout.slots.push(itemSlot.left, itemSlot.top);\r\n    if (trackSize) this._slotSizes.push(itemSlot.width, itemSlot.height);\r\n\r\n    // Free/new slots switcheroo!\r\n    this._freeSlots = newSlots;\r\n    this._newSlots = freeSlots;\r\n  };\r\n}))();\r\n\r\n/**\r\n * Punch a hole into a rectangle and split the remaining area into smaller\r\n * rectangles (4 at max).\r\n *\r\n * @private\r\n * @memberof Packer.prototype\r\n * @param {Rectangle} rect\r\n * @param {Rectangle} hole\r\n * @returns {RectId[]}\r\n */\r\nPacker.prototype._splitRect = ((() => {\r\n  const results = [];\r\n  return function(rect, hole) {\r\n    // Reset old results.\r\n    results.length = 0;\r\n\r\n    // If the rect does not overlap with the hole add rect to the return data\r\n    // as is.\r\n    if (!this._doRectsOverlap(rect, hole)) {\r\n      results.push(this._addRect(rect.left, rect.top, rect.width, rect.height));\r\n      return results;\r\n    }\r\n\r\n    // Left split.\r\n    if (rect.left < hole.left) {\r\n      results.push(this._addRect(rect.left, rect.top, hole.left - rect.left, rect.height));\r\n    }\r\n\r\n    // Right split.\r\n    if (rect.left + rect.width > hole.left + hole.width) {\r\n      results.push(\r\n        this._addRect(\r\n          hole.left + hole.width,\r\n          rect.top,\r\n          rect.left + rect.width - (hole.left + hole.width),\r\n          rect.height\r\n        )\r\n      );\r\n    }\r\n\r\n    // Top split.\r\n    if (rect.top < hole.top) {\r\n      results.push(this._addRect(rect.left, rect.top, rect.width, hole.top - rect.top));\r\n    }\r\n\r\n    // Bottom split.\r\n    if (rect.top + rect.height > hole.top + hole.height) {\r\n      results.push(\r\n        this._addRect(\r\n          rect.left,\r\n          hole.top + hole.height,\r\n          rect.width,\r\n          rect.top + rect.height - (hole.top + hole.height)\r\n        )\r\n      );\r\n    }\r\n\r\n    return results;\r\n  };\r\n}))();\r\n\r\n/**\r\n * Loops through an array of rectangle ids and resets all that are fully\r\n * within another rectangle in the array. Resetting in this case means that\r\n * the rectangle id value is replaced with zero.\r\n *\r\n * @private\r\n * @memberof Packer.prototype\r\n * @param {RectId[]} rectIds\r\n * @returns {RectId[]}\r\n */\r\nPacker.prototype._purgeRects = ((() => {\r\n  const rectA = {};\r\n  const rectB = {};\r\n  return function(rectIds) {\r\n    let i = rectIds.length;\r\n    let ii;\r\n\r\n    while (i--) {\r\n      ii = rectIds.length;\r\n      if (!rectIds[i]) continue;\r\n      this._getRect(rectIds[i], rectA);\r\n      while (ii--) {\r\n        if (!rectIds[ii] || i === ii) continue;\r\n        if (this._isRectWithinRect(rectA, this._getRect(rectIds[ii], rectB))) {\r\n          rectIds[i] = 0;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return rectIds;\r\n  };\r\n}))();\r\n\r\n/**\r\n * Sort rectangles with top-left gravity.\r\n *\r\n * @private\r\n * @memberof Packer.prototype\r\n * @param {RectId} aId\r\n * @param {RectId} bId\r\n * @returns {Number}\r\n */\r\nPacker.prototype._sortRectsTopLeft = ((() => {\r\n  const rectA = {};\r\n  const rectB = {};\r\n  return function(aId, bId) {\r\n    this._getRect(aId, rectA);\r\n    this._getRect(bId, rectB);\r\n    // prettier-ignore\r\n    return rectA.top < rectB.top ? -1 : // eslint-disable-line\r\n           rectA.top > rectB.top ? 1 : // eslint-disable-line\r\n           rectA.left < rectB.left ? -1 : // eslint-disable-line\r\n           rectA.left > rectB.left ? 1 : 0; // eslint-disable-line\r\n  };\r\n}))();\r\n\r\n/**\r\n * Sort rectangles with left-top gravity.\r\n *\r\n * @private\r\n * @memberof Packer.prototype\r\n * @param {RectId} aId\r\n * @param {RectId} bId\r\n * @returns {Number}\r\n */\r\nPacker.prototype._sortRectsLeftTop = ((() => {\r\n  const rectA = {};\r\n  const rectB = {};\r\n  return function(aId, bId) {\r\n    this._getRect(aId, rectA);\r\n    this._getRect(bId, rectB);\r\n    // standard-ignore\r\n    return rectA.left < rectB.left ? -1 : // eslint-disable-line\r\n           rectA.left > rectB.left ? 1 : // eslint-disable-line\r\n           rectA.top < rectB.top ? -1 : // eslint-disable-line\r\n           rectA.top > rectB.top ? 1 : 0; // eslint-disable-line\r\n  };\r\n}))();\r\n\r\nexport default Packer;\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\nconst htmlCollectionType = '[object HTMLCollection]';\r\nconst nodeListType = '[object NodeList]';\r\n\r\n/**\r\n * Check if a value is a node list\r\n *\r\n * @param {*} val\r\n * @returns {Boolean}\r\n */\r\nexport default function isNodeList(val) {\r\n  const type = Object.prototype.toString.call(val);\r\n  return type === htmlCollectionType || type === nodeListType;\r\n}\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\nimport isNodeList from './isNodeList.js';\r\n\r\n/**\r\n * Converts a value to an array or clones an array.\r\n *\r\n * @param {*} target\r\n * @returns {Array}\r\n */\r\nexport default function toArray(target) {\r\n  return isNodeList(target) ? Array.prototype.slice.call(target) : Array.prototype.concat(target);\r\n}\r\n","/**\r\n * Copyright (c) 2015-present, Haltu Oy\r\n * Released under the MIT license\r\n * https://github.com/haltu/muuri/blob/master/LICENSE.md\r\n */\r\n\r\nimport { Component } from 'react';\r\nimport {\r\n  eventSynchronize,\r\n  eventLayoutStart,\r\n  eventLayoutEnd,\r\n  eventAdd,\r\n  eventRemove,\r\n  eventShowStart,\r\n  eventShowEnd,\r\n  eventHideStart,\r\n  eventHideEnd,\r\n  eventFilter,\r\n  eventSort,\r\n  eventMove,\r\n  eventDestroy,\r\n  gridInstances,\r\n  namespace\r\n} from '../shared.js';\r\n\r\nimport Emitter from '../Emitter/Emitter.js';\r\nimport Item from '../Item/Item.js';\r\nimport ItemAnimate from '../Item/ItemAnimate.js';\r\nimport ItemDrag from '../Item/ItemDrag.js';\r\nimport ItemLayout from '../Item/ItemLayout.js';\r\nimport ItemMigrate from '../Item/ItemMigrate.js';\r\nimport ItemRelease from '../Item/ItemRelease.js';\r\nimport ItemVisibility from '../Item/ItemVisibility.js';\r\nimport Packer from '../Packer/Packer.js';\r\n\r\nimport addClass from '../utils/addClass.js';\r\nimport arrayMove from '../utils/arrayMove.js';\r\nimport arraySwap from '../utils/arraySwap.js';\r\nimport createUid from '../utils/createUid.js';\r\nimport debounce from '../utils/debounce.js';\r\nimport elementMatches from '../utils/elementMatches.js';\r\nimport getStyle from '../utils/getStyle.js';\r\nimport getStyleAsFloat from '../utils/getStyleAsFloat.js';\r\nimport arrayInsert from '../utils/arrayInsert.js';\r\nimport isNodeList from '../utils/isNodeList.js';\r\nimport isPlainObject from '../utils/isPlainObject.js';\r\nimport removeClass from '../utils/removeClass.js';\r\nimport toArray from '../utils/toArray.js';\r\n\r\nconst packer = new Packer();\r\nfunction noop () {}\r\n\r\n/**\r\n * Creates a new Grid instance.\r\n *\r\n * @class\r\n * @param {(HTMLElement|String)} element\r\n * @param {Object} [options]\r\n * @param {(?HTMLElement[]|NodeList|String)} [options.items]\r\n * @param {Number} [options.showDuration=300]\r\n * @param {String} [options.showEasing=\"ease\"]\r\n * @param {Object} [options.visibleStyles]\r\n * @param {Number} [options.hideDuration=300]\r\n * @param {String} [options.hideEasing=\"ease\"]\r\n * @param {Object} [options.hiddenStyles]\r\n * @param {(Function|Object)} [options.layout]\r\n * @param {Boolean} [options.layout.fillGaps=false]\r\n * @param {Boolean} [options.layout.horizontal=false]\r\n * @param {Boolean} [options.layout.alignRight=false]\r\n * @param {Boolean} [options.layout.alignBottom=false]\r\n * @param {Boolean} [options.layout.rounding=true]\r\n * @param {(Boolean|Number)} [options.layoutOnResize=100]\r\n * @param {Boolean} [options.layoutOnInit=true]\r\n * @param {Number} [options.layoutDuration=300]\r\n * @param {String} [options.layoutEasing=\"ease\"]\r\n * @param {?Object} [options.sortData=null]\r\n * @param {Boolean} [options.dragEnabled=false]\r\n * @param {?HtmlElement} [options.dragContainer=null]\r\n * @param {?Function} [options.dragStartPredicate]\r\n * @param {Number} [options.dragStartPredicate.distance=0]\r\n * @param {Number} [options.dragStartPredicate.delay=0]\r\n * @param {(Boolean|String)} [options.dragStartPredicate.handle=false]\r\n * @param {?String} [options.dragAxis]\r\n * @param {(Boolean|Function)} [options.dragSort=true]\r\n * @param {Number} [options.dragSortInterval=100]\r\n * @param {(Function|Object)} [options.dragSortPredicate]\r\n * @param {Number} [options.dragSortPredicate.threshold=50]\r\n * @param {String} [options.dragSortPredicate.action=\"move\"]\r\n * @param {Number} [options.dragReleaseDuration=300]\r\n * @param {String} [options.dragReleaseEasing=\"ease\"]\r\n * @param {Object} [options.dragHammerSettings={touchAction: \"none\"}]\r\n * @param {String} [options.containerClass=\"muuri\"]\r\n * @param {String} [options.itemClass=\"muuri-item\"]\r\n * @param {String} [options.itemVisibleClass=\"muuri-item-visible\"]\r\n * @param {String} [options.itemHiddenClass=\"muuri-item-hidden\"]\r\n * @param {String} [options.itemPositioningClass=\"muuri-item-positioning\"]\r\n * @param {String} [options.itemDraggingClass=\"muuri-item-dragging\"]\r\n * @param {String} [options.itemReleasingClass=\"muuri-item-releasing\"]\r\n */\r\nclass Grid extends Component {\r\n  constructor(element, options) {\r\n    super(element, options);\r\n    const inst = this;\r\n    let settings;\r\n    let items;\r\n    let layoutOnResize;\r\n\r\n    // Allow passing element as selector string. Store element for instance.\r\n    element = this._element = typeof element === 'string' ? document.querySelector(element) : element;\r\n\r\n    // Throw an error if the container element is not body element or does not\r\n    // exist within the body element.\r\n    if (!document.body.contains(element)) {\r\n      throw new Error('Container element must be an existing DOM element');\r\n    }\r\n\r\n    // Create instance settings by merging the options with default options.\r\n    settings = this._settings = mergeSettings(Grid.defaultOptions, options);\r\n\r\n    // Sanitize dragSort setting.\r\n    if (typeof settings.dragSort !== 'function') {\r\n      settings.dragSort = !!settings.dragSort;\r\n    }\r\n\r\n    // Create instance id and store it to the grid instances collection.\r\n    this._id = createUid();\r\n    gridInstances[this._id] = inst;\r\n\r\n    // Destroyed flag.\r\n    this._isDestroyed = false;\r\n\r\n    // The layout object (mutated on every layout).\r\n    this._layout = {\r\n      id: 0,\r\n      items: [],\r\n      slots: [],\r\n      setWidth: false,\r\n      setHeight: false,\r\n      width: 0,\r\n      height: 0\r\n    };\r\n\r\n    // Create private Emitter instance.\r\n    this._emitter = new Emitter();\r\n\r\n    // Add container element's class name.\r\n    addClass(element, settings.containerClass);\r\n\r\n    // Create initial items.\r\n    this._items = [];\r\n    items = settings.items;\r\n    if (typeof items === 'string') {\r\n      toArray(element.children).forEach(itemElement => {\r\n        if (items === '*' || elementMatches(itemElement, items)) {\r\n          inst._items.push(new Item(inst, itemElement));\r\n        }\r\n      });\r\n    } else if (Array.isArray(items) || isNodeList(items)) {\r\n      this._items = toArray(items).map(itemElement => new Item(inst, itemElement));\r\n    }\r\n\r\n    // If layoutOnResize option is a valid number sanitize it and bind the resize\r\n    // handler.\r\n    layoutOnResize = settings.layoutOnResize;\r\n    if (typeof layoutOnResize !== 'number') {\r\n      layoutOnResize = layoutOnResize === true ? 0 : -1;\r\n    }\r\n    if (layoutOnResize >= 0) {\r\n      window.addEventListener(\r\n        'resize',\r\n        (inst._resizeHandler = debounce(() => {\r\n          inst.refreshItems().layout();\r\n        }, layoutOnResize))\r\n      );\r\n    }\r\n\r\n    // Layout on init if necessary.\r\n    if (settings.layoutOnInit) {\r\n      this.layout(true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Public prototype methods\r\n   * ************************\r\n   */\r\n\r\n  /**\r\n   * Bind an event listener.\r\n   *\r\n   * @public\r\n   * @memberof Grid.prototype\r\n   * @param {String} event\r\n   * @param {Function} listener\r\n   * @returns {Grid}\r\n   */\r\n  on(event, listener) {\r\n    this._emitter.on(event, listener);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Bind an event listener that is triggered only once.\r\n   *\r\n   * @public\r\n   * @memberof Grid.prototype\r\n   * @param {String} event\r\n   * @param {Function} listener\r\n   * @returns {Grid}\r\n   */\r\n  once(event, listener) {\r\n    this._emitter.once(event, listener);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Unbind an event listener.\r\n   *\r\n   * @public\r\n   * @memberof Grid.prototype\r\n   * @param {String} event\r\n   * @param {Function} listener\r\n   * @returns {Grid}\r\n   */\r\n  off(event, listener) {\r\n    this._emitter.off(event, listener);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Get the container element.\r\n   *\r\n   * @public\r\n   * @memberof Grid.prototype\r\n   * @returns {HTMLElement}\r\n   */\r\n  getElement() {\r\n    return this._element;\r\n  }\r\n\r\n  /**\r\n   * Get all items. Optionally you can provide specific targets (elements and\r\n   * indices). Note that the returned array is not the same object used by the\r\n   * instance so modifying it will not affect instance's items. All items that\r\n   * are not found are omitted from the returned array.\r\n   *\r\n   * @public\r\n   * @memberof Grid.prototype\r\n   * @param {GridMultiItemQuery} [targets]\r\n   * @returns {Item[]}\r\n   */\r\n  getItems(targets) {\r\n    // Return all items immediately if no targets were provided or if the\r\n    // instance is destroyed.\r\n    if (this._isDestroyed || (!targets && targets !== 0)) {\r\n      return this._items.slice(0);\r\n    }\r\n\r\n    const ret = [];\r\n    const targetItems = toArray(targets);\r\n    let item;\r\n    let i;\r\n\r\n    // If target items are defined return filtered results.\r\n    for (i = 0; i < targetItems.length; i++) {\r\n      item = this._getItem(targetItems[i]);\r\n      item && ret.push(item);\r\n    }\r\n\r\n    return ret;\r\n  }\r\n\r\n  /**\r\n   * Update the cached dimensions of the instance's items.\r\n   *\r\n   * @public\r\n   * @memberof Grid.prototype\r\n   * @param {GridMultiItemQuery} [items]\r\n   * @returns {Grid}\r\n   */\r\n  refreshItems(items) {\r\n    if (this._isDestroyed) return this;\r\n\r\n    const targets = this.getItems(items);\r\n    let i;\r\n\r\n    for (i = 0; i < targets.length; i++) {\r\n      targets[i]._refreshDimensions();\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Update the sort data of the instance's items.\r\n   *\r\n   * @public\r\n   * @memberof Grid.prototype\r\n   * @param {GridMultiItemQuery} [items]\r\n   * @returns {Grid}\r\n   */\r\n  refreshSortData(items) {\r\n    if (this._isDestroyed) return this;\r\n\r\n    const targetItems = this.getItems(items);\r\n    let i;\r\n\r\n    for (i = 0; i < targetItems.length; i++) {\r\n      targetItems[i]._refreshSortData();\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Synchronize the item elements to match the order of the items in the DOM.\r\n   * This comes handy if you need to keep the DOM structure matched with the\r\n   * order of the items. Note that if an item's element is not currently a child\r\n   * of the container element (if it is dragged for example) it is ignored and\r\n   * left untouched.\r\n   *\r\n   * @public\r\n   * @memberof Grid.prototype\r\n   * @returns {Grid}\r\n   */\r\n  synchronize() {\r\n    if (this._isDestroyed) return this;\r\n\r\n    const container = this._element;\r\n    const items = this._items;\r\n    let fragment;\r\n    let element;\r\n    let i;\r\n\r\n    // Append all elements in order to the container element.\r\n    if (items.length) {\r\n      for (i = 0; i < items.length; i++) {\r\n        element = items[i]._element;\r\n        if (element.parentNode === container) {\r\n          fragment = fragment || document.createDocumentFragment();\r\n          fragment.appendChild(element);\r\n        }\r\n      }\r\n\r\n      if (fragment) container.appendChild(fragment);\r\n    }\r\n\r\n    // Emit synchronize event.\r\n    this._emit(eventSynchronize);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Calculate and apply item positions.\r\n   *\r\n   * @public\r\n   * @memberof Grid.prototype\r\n   * @param {Boolean} [instant=false]\r\n   * @param {LayoutCallback} [onFinish]\r\n   * @returns {Grid}\r\n   */\r\n  layout(instant, onFinish) {\r\n    if (this._isDestroyed) return this;\r\n\r\n    const inst = this;\r\n    const element = this._element;\r\n    const layout = this._updateLayout();\r\n    const layoutId = layout.id;\r\n    const itemsLength = layout.items.length;\r\n    let counter = itemsLength;\r\n    const callback = typeof instant === 'function' ? instant : onFinish;\r\n    const isCallbackFunction = typeof callback === 'function';\r\n    const callbackItems = isCallbackFunction ? layout.items.slice(0) : null;\r\n    let isBorderBox;\r\n    let item;\r\n    let i;\r\n\r\n    // The finish function, which will be used for checking if all the items\r\n    // have laid out yet. After all items have finished their animations call\r\n    // callback and emit layoutEnd event. Only emit layoutEnd event if there\r\n    // hasn't been a new layout call during this layout.\r\n    function tryFinish() {\r\n      if (--counter > 0) return;\r\n      const hasLayoutChanged = inst._layout.id !== layoutId;\r\n      isCallbackFunction && callback(hasLayoutChanged, callbackItems);\r\n      if (!hasLayoutChanged && inst._hasListeners(eventLayoutEnd)) {\r\n        inst._emit(eventLayoutEnd, layout.items.slice(0));\r\n      }\r\n    };\r\n\r\n    // If grid's width or height was modified, we need to update it's cached\r\n    // dimensions. Also keep in mind that grid's cached width/height should\r\n    // always equal to what elem.getBoundingClientRect() would return, so\r\n    // therefore we need to add the grid element's borders to the dimensions if\r\n    // it's box-sizing is border-box.\r\n    if (\r\n      (layout.setHeight && typeof layout.height === 'number') ||\r\n      (layout.setWidth && typeof layout.width === 'number')\r\n    ) {\r\n      isBorderBox = getStyle(element, 'box-sizing') === 'border-box';\r\n    }\r\n    if (layout.setHeight) {\r\n      if (typeof layout.height === 'number') {\r\n        element.style.height =\r\n          `${isBorderBox ? layout.height + this._borderTop + this._borderBottom : layout.height}px`;\r\n      } else {\r\n        element.style.height = layout.height;\r\n      }\r\n    }\r\n    if (layout.setWidth) {\r\n      if (typeof layout.width === 'number') {\r\n        element.style.width =\r\n          `${isBorderBox ? layout.width + this._borderLeft + this._borderRight : layout.width}px`;\r\n      } else {\r\n        element.style.width = layout.width;\r\n      }\r\n    }\r\n\r\n    // Emit layoutStart event. Note that this is intentionally emitted after the\r\n    // container element's dimensions are set, because otherwise there would be\r\n    // no hook for reacting to container dimension changes.\r\n    if (this._hasListeners(eventLayoutStart)) {\r\n      this._emit(eventLayoutStart, layout.items.slice(0));\r\n    }\r\n\r\n    // If there are no items let's finish quickly.\r\n    if (!itemsLength) {\r\n      tryFinish();\r\n      return this;\r\n    }\r\n\r\n    // If there are items let's position them.\r\n    for (i = 0; i < itemsLength; i++) {\r\n      item = layout.items[i];\r\n      if (!item) continue;\r\n\r\n      // Update item's position.\r\n      item._left = layout.slots[i * 2];\r\n      item._top = layout.slots[i * 2 + 1];\r\n\r\n      // Layout item if it is not dragged.\r\n      item.isDragging() ? tryFinish() : item._layout.start(instant === true, tryFinish);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Add new items by providing the elements you wish to add to the instance and\r\n   * optionally provide the index where you want the items to be inserted into.\r\n   * All elements that are not already children of the container element will be\r\n   * automatically appended to the container element. If an element has it's CSS\r\n   * display property set to \"none\" it will be marked as inactive during the\r\n   * initiation process. As long as the item is inactive it will not be part of\r\n   * the layout, but it will retain it's index. You can activate items at any\r\n   * point with grid.show() method. This method will automatically call\r\n   * grid.layout() if one or more of the added elements are visible. If only\r\n   * hidden items are added no layout will be called. All the new visible items\r\n   * are positioned without animation during their first layout.\r\n   *\r\n   * @public\r\n   * @memberof Grid.prototype\r\n   * @param {(HTMLElement|HTMLElement[])} elements\r\n   * @param {Object} [options]\r\n   * @param {Number} [options.index=-1]\r\n   * @param {Boolean} [options.isActive]\r\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\r\n   * @returns {Item[]}\r\n   */\r\n  add(elements, options) {\r\n    if (this._isDestroyed || !elements) return [];\r\n\r\n    const newItems = toArray(elements);\r\n    if (!newItems.length) return newItems;\r\n\r\n    const opts = options || 0;\r\n    const layout = opts.layout ? opts.layout : opts.layout === undefined;\r\n    const items = this._items;\r\n    let needsLayout = false;\r\n    let item;\r\n    let i;\r\n\r\n    // Map provided elements into new grid items.\r\n    for (i = 0; i < newItems.length; i++) {\r\n      item = new Item(this, newItems[i], opts.isActive);\r\n      newItems[i] = item;\r\n\r\n      // If the item to be added is active, we need to do a layout. Also, we\r\n      // need to mark the item with the skipNextAnimation flag to make it\r\n      // position instantly (without animation) during the next layout. Without\r\n      // the hack the item would animate to it's new position from the northwest\r\n      // corner of the grid, which feels a bit buggy (imho).\r\n      if (item._isActive) {\r\n        needsLayout = true;\r\n        item._layout._skipNextAnimation = true;\r\n      }\r\n    }\r\n\r\n    // Add the new items to the items collection to correct index.\r\n    arrayInsert(items, newItems, opts.index);\r\n\r\n    // Emit add event.\r\n    if (this._hasListeners(eventAdd)) {\r\n      this._emit(eventAdd, newItems.slice(0));\r\n    }\r\n\r\n    // If layout is needed.\r\n    if (needsLayout && layout) {\r\n      this.layout(layout === 'instant', typeof layout === 'function' ? layout : undefined);\r\n    }\r\n\r\n    return newItems;\r\n  }\r\n\r\n  /**\r\n   * Remove items from the instance.\r\n   *\r\n   * @public\r\n   * @memberof Grid.prototype\r\n   * @param {GridMultiItemQuery} items\r\n   * @param {Object} [options]\r\n   * @param {Boolean} [options.removeElements=false]\r\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\r\n   * @returns {Item[]}\r\n   */\r\n  remove(items, options) {\r\n    if (this._isDestroyed) return this;\r\n\r\n    const opts = options || 0;\r\n    const layout = opts.layout ? opts.layout : opts.layout === undefined;\r\n    let needsLayout = false;\r\n    const allItems = this.getItems();\r\n    const targetItems = this.getItems(items);\r\n    const indices = [];\r\n    let item;\r\n    let i;\r\n\r\n    // Remove the individual items.\r\n    for (i = 0; i < targetItems.length; i++) {\r\n      item = targetItems[i];\r\n      indices.push(allItems.indexOf(item));\r\n      if (item._isActive) needsLayout = true;\r\n      item._destroy(opts.removeElements);\r\n    }\r\n\r\n    // Emit remove event.\r\n    if (this._hasListeners(eventRemove)) {\r\n      this._emit(eventRemove, targetItems.slice(0), indices);\r\n    }\r\n\r\n    // If layout is needed.\r\n    if (needsLayout && layout) {\r\n      this.layout(layout === 'instant', typeof layout === 'function' ? layout : undefined);\r\n    }\r\n\r\n    return targetItems;\r\n  }\r\n\r\n  /**\r\n   * Show instance items.\r\n   *\r\n   * @public\r\n   * @memberof Grid.prototype\r\n   * @param {GridMultiItemQuery} items\r\n   * @param {Object} [options]\r\n   * @param {Boolean} [options.instant=false]\r\n   * @param {ShowCallback} [options.onFinish]\r\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\r\n   * @returns {Grid}\r\n   */\r\n  show(items, options) {\r\n    if (this._isDestroyed) return this;\r\n    this._setItemsVisibility(items, true, options);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Hide instance items.\r\n   *\r\n   * @public\r\n   * @memberof Grid.prototype\r\n   * @param {GridMultiItemQuery} items\r\n   * @param {Object} [options]\r\n   * @param {Boolean} [options.instant=false]\r\n   * @param {HideCallback} [options.onFinish]\r\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\r\n   * @returns {Grid}\r\n   */\r\n  hide(items, options) {\r\n    if (this._isDestroyed) return this;\r\n    this._setItemsVisibility(items, false, options);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Filter items. Expects at least one argument, a predicate, which should be\r\n   * either a function or a string. The predicate callback is executed for every\r\n   * item in the instance. If the return value of the predicate is truthy the\r\n   * item in question will be shown and otherwise hidden. The predicate callback\r\n   * receives the item instance as it's argument. If the predicate is a string\r\n   * it is considered to be a selector and it is checked against every item\r\n   * element in the instance with the native element.matches() method. All the\r\n   * matching items will be shown and others hidden.\r\n   *\r\n   * @public\r\n   * @memberof Grid.prototype\r\n   * @param {(Function|String)} predicate\r\n   * @param {Object} [options]\r\n   * @param {Boolean} [options.instant=false]\r\n   * @param {FilterCallback} [options.onFinish]\r\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\r\n   * @returns {Grid}\r\n   */\r\n  filter(predicate, options) {\r\n    if (this._isDestroyed || !this._items.length) return this;\r\n\r\n    const itemsToShow = [];\r\n    const itemsToHide = [];\r\n    const isPredicateString = typeof predicate === 'string';\r\n    const isPredicateFn = typeof predicate === 'function';\r\n    const opts = options || 0;\r\n    const isInstant = opts.instant === true;\r\n    const layout = opts.layout ? opts.layout : opts.layout === undefined;\r\n    const onFinish = typeof opts.onFinish === 'function' ? opts.onFinish : null;\r\n    let tryFinishCounter = -1;\r\n    let tryFinish = noop;\r\n    let item;\r\n    let i;\r\n\r\n    // If we have onFinish callback, let's create proper tryFinish callback.\r\n    if (onFinish) {\r\n      tryFinish = function() {\r\n        ++tryFinishCounter && onFinish(itemsToShow.slice(0), itemsToHide.slice(0));\r\n      };\r\n    }\r\n\r\n    // Check which items need to be shown and which hidden.\r\n    if (isPredicateFn || isPredicateString) {\r\n      for (i = 0; i < this._items.length; i++) {\r\n        item = this._items[i];\r\n        if (isPredicateFn ? predicate(item) : elementMatches(item._element, predicate)) {\r\n          itemsToShow.push(item);\r\n        } else {\r\n          itemsToHide.push(item);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Show items that need to be shown.\r\n    if (itemsToShow.length) {\r\n      this.show(itemsToShow, {\r\n        instant: isInstant,\r\n        onFinish: tryFinish,\r\n        layout: false\r\n      });\r\n    } else {\r\n      tryFinish();\r\n    }\r\n\r\n    // Hide items that need to be hidden.\r\n    if (itemsToHide.length) {\r\n      this.hide(itemsToHide, {\r\n        instant: isInstant,\r\n        onFinish: tryFinish,\r\n        layout: false\r\n      });\r\n    } else {\r\n      tryFinish();\r\n    }\r\n\r\n    // If there are any items to filter.\r\n    if (itemsToShow.length || itemsToHide.length) {\r\n      // Emit filter event.\r\n      if (this._hasListeners(eventFilter)) {\r\n        this._emit(eventFilter, itemsToShow.slice(0), itemsToHide.slice(0));\r\n      }\r\n\r\n      // If layout is needed.\r\n      if (layout) {\r\n        this.layout(layout === 'instant', typeof layout === 'function' ? layout : undefined);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Move item to another index or in place of another item.\r\n   *\r\n   * @public\r\n   * @memberof Grid.prototype\r\n   * @param {GridSingleItemQuery} item\r\n   * @param {GridSingleItemQuery} position\r\n   * @param {Object} [options]\r\n   * @param {String} [options.action=\"move\"]\r\n   *   - Accepts either \"move\" or \"swap\".\r\n   *   - \"move\" moves the item in place of the other item.\r\n   *   - \"swap\" swaps the position of the items.\r\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\r\n   * @returns {Grid}\r\n   */\r\n  move(item, position, options) {\r\n    if (this._isDestroyed || this._items.length < 2) return this;\r\n\r\n    const items = this._items;\r\n    const opts = options || 0;\r\n    const layout = opts.layout ? opts.layout : opts.layout === undefined;\r\n    const isSwap = opts.action === 'swap';\r\n    const action = isSwap ? 'swap' : 'move';\r\n    const fromItem = this._getItem(item);\r\n    const toItem = this._getItem(position);\r\n    let fromIndex;\r\n    let toIndex;\r\n\r\n    // Make sure the items exist and are not the same.\r\n    if (fromItem && toItem && fromItem !== toItem) {\r\n      // Get the indices of the items.\r\n      fromIndex = items.indexOf(fromItem);\r\n      toIndex = items.indexOf(toItem);\r\n\r\n      // Do the move/swap.\r\n      if (isSwap) {\r\n        arraySwap(items, fromIndex, toIndex);\r\n      } else {\r\n        arrayMove(items, fromIndex, toIndex);\r\n      }\r\n\r\n      // Emit move event.\r\n      if (this._hasListeners(eventMove)) {\r\n        this._emit(eventMove, {\r\n          item: fromItem,\r\n          fromIndex,\r\n          toIndex,\r\n          action\r\n        });\r\n      }\r\n\r\n      // If layout is needed.\r\n      if (layout) {\r\n        this.layout(layout === 'instant', typeof layout === 'function' ? layout : undefined);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Send item to another Grid instance.\r\n   *\r\n   * @public\r\n   * @memberof Grid.prototype\r\n   * @param {GridSingleItemQuery} item\r\n   * @param {Grid} grid\r\n   * @param {GridSingleItemQuery} position\r\n   * @param {Object} [options]\r\n   * @param {HTMLElement} [options.appendTo=document.body]\r\n   * @param {(Boolean|LayoutCallback|String)} [options.layoutSender=true]\r\n   * @param {(Boolean|LayoutCallback|String)} [options.layoutReceiver=true]\r\n   * @returns {Grid}\r\n   */\r\n  send(item, grid, position, options) {\r\n    if (this._isDestroyed || grid._isDestroyed || this === grid) return this;\r\n\r\n    // Make sure we have a valid target item.\r\n    item = this._getItem(item);\r\n    if (!item) return this;\r\n\r\n    const opts = options || 0;\r\n    const container = opts.appendTo || document.body;\r\n    const layoutSender = opts.layoutSender ? opts.layoutSender : opts.layoutSender === undefined;\r\n    const layoutReceiver = opts.layoutReceiver\r\n      ? opts.layoutReceiver\r\n      : opts.layoutReceiver === undefined;\r\n\r\n    // Start the migration process.\r\n    item._migrate.start(grid, position, container);\r\n\r\n    // If migration was started successfully and the item is active, let's layout\r\n    // the grids.\r\n    if (item._migrate._isActive && item._isActive) {\r\n      if (layoutSender) {\r\n        this.layout(\r\n          layoutSender === 'instant',\r\n          typeof layoutSender === 'function' ? layoutSender : undefined\r\n        );\r\n      }\r\n      if (layoutReceiver) {\r\n        grid.layout(\r\n          layoutReceiver === 'instant',\r\n          typeof layoutReceiver === 'function' ? layoutReceiver : undefined\r\n        );\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Destroy the instance.\r\n   *\r\n   * @public\r\n   * @memberof Grid.prototype\r\n   * @param {Boolean} [removeElements=false]\r\n   * @returns {Grid}\r\n   */\r\n  destroy(removeElements) {\r\n    if (this._isDestroyed) return this;\r\n\r\n    const container = this._element;\r\n    const items = this._items.slice(0);\r\n    let i;\r\n\r\n    // Unbind window resize event listener.\r\n    if (this._resizeHandler) {\r\n      window.removeEventListener('resize', this._resizeHandler);\r\n    }\r\n\r\n    // Destroy items.\r\n    for (i = 0; i < items.length; i++) {\r\n      items[i]._destroy(removeElements);\r\n    }\r\n\r\n    // Restore container.\r\n    removeClass(container, this._settings.containerClass);\r\n    container.style.height = '';\r\n    container.style.width = '';\r\n\r\n    // Emit destroy event and unbind all events.\r\n    this._emit(eventDestroy);\r\n    this._emitter.destroy();\r\n\r\n    // Remove reference from the grid instances collection.\r\n    gridInstances[this._id] = undefined;\r\n\r\n    // Flag instance as destroyed.\r\n    this._isDestroyed = true;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Private prototype methods\r\n   * *************************\r\n   */\r\n\r\n  /**\r\n   * Get instance's item by element or by index. Target can also be an Item\r\n   * instance in which case the function returns the item if it exists within\r\n   * related Grid instance. If nothing is found with the provided target, null\r\n   * is returned.\r\n   *\r\n   * @private\r\n   * @memberof Grid.prototype\r\n   * @param {GridSingleItemQuery} [target]\r\n   * @returns {?Item}\r\n   */\r\n  _getItem(target) {\r\n    // If no target is specified or the instance is destroyed, return null.\r\n    if (this._isDestroyed || (!target && target !== 0)) {\r\n      return null;\r\n    }\r\n\r\n    // If target is number return the item in that index. If the number is lower\r\n    // than zero look for the item starting from the end of the items array. For\r\n    // example -1 for the last item, -2 for the second last item, etc.\r\n    if (typeof target === 'number') {\r\n      return this._items[target > -1 ? target : this._items.length + target] || null;\r\n    }\r\n\r\n    // If the target is an instance of Item return it if it is attached to this\r\n    // Grid instance, otherwise return null.\r\n    if (target instanceof Item) {\r\n      return target._gridId === this._id ? target : null;\r\n    }\r\n\r\n    // In other cases let's assume that the target is an element, so let's try\r\n    // to find an item that matches the element and return it. If item is not\r\n    // found return null.\r\n    /** @todo This could be made a lot faster by using Map/WeakMap of elements. */\r\n    for (let i = 0; i < this._items.length; i++) {\r\n      if (this._items[i]._element === target) {\r\n        return this._items[i];\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Recalculates and updates instance's layout data.\r\n   *\r\n   * @private\r\n   * @memberof Grid.prototype\r\n   * @returns {LayoutData}\r\n   */\r\n  _updateLayout() {\r\n    const layout = this._layout;\r\n    const settings = this._settings.layout;\r\n    let width;\r\n    let height;\r\n    let newLayout;\r\n    let i;\r\n\r\n    // Let's increment layout id.\r\n    ++layout.id;\r\n\r\n    // Let's update layout items\r\n    layout.items.length = 0;\r\n    for (i = 0; i < this._items.length; i++) {\r\n      if (this._items[i]._isActive) layout.items.push(this._items[i]);\r\n    }\r\n\r\n    // Let's make sure we have the correct container dimensions.\r\n    this._refreshDimensions();\r\n\r\n    // Calculate container width and height (without borders).\r\n    width = this._width - this._borderLeft - this._borderRight;\r\n    height = this._height - this._borderTop - this._borderBottom;\r\n\r\n    // Calculate new layout.\r\n    if (typeof settings === 'function') {\r\n      newLayout = settings(layout.items, width, height);\r\n    } else {\r\n      newLayout = packer.getLayout(layout.items, width, height, layout.slots, settings);\r\n    }\r\n\r\n    // Let's update the grid's layout.\r\n    layout.slots = newLayout.slots;\r\n    layout.setWidth = Boolean(newLayout.setWidth);\r\n    layout.setHeight = Boolean(newLayout.setHeight);\r\n    layout.width = newLayout.width;\r\n    layout.height = newLayout.height;\r\n\r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Emit a grid event.\r\n   *\r\n   * @private\r\n   * @memberof Grid.prototype\r\n   * @param {String} event\r\n   * @param {...*} [arg]\r\n   */\r\n  _emit() {\r\n    if (this._isDestroyed) return;\r\n    this._emitter.emit(...arguments);\r\n  }\r\n\r\n  /**\r\n   * Check if there are any events listeners for an event.\r\n   *\r\n   * @private\r\n   * @memberof Grid.prototype\r\n   * @param {String} event\r\n   * @returns {Boolean}\r\n   */\r\n  _hasListeners(event) {\r\n    const listeners = this._emitter._events[event];\r\n    return !!(listeners && listeners.length);\r\n  }\r\n\r\n  /**\r\n   * Update container's width, height and offsets.\r\n   *\r\n   * @private\r\n   * @memberof Grid.prototype\r\n   */\r\n  _updateBoundingRect() {\r\n    const element = this._element;\r\n    const rect = element.getBoundingClientRect();\r\n    this._width = rect.width;\r\n    this._height = rect.height;\r\n    this._left = rect.left;\r\n    this._top = rect.top;\r\n  }\r\n\r\n  /**\r\n   * Update container's border sizes.\r\n   *\r\n   * @private\r\n   * @memberof Grid.prototype\r\n   * @param {Boolean} left\r\n   * @param {Boolean} right\r\n   * @param {Boolean} top\r\n   * @param {Boolean} bottom\r\n   */\r\n  _updateBorders(left, right, top, bottom) {\r\n    const element = this._element;\r\n    if (left) this._borderLeft = getStyleAsFloat(element, 'border-left-width');\r\n    if (right) this._borderRight = getStyleAsFloat(element, 'border-right-width');\r\n    if (top) this._borderTop = getStyleAsFloat(element, 'border-top-width');\r\n    if (bottom) this._borderBottom = getStyleAsFloat(element, 'border-bottom-width');\r\n  }\r\n\r\n  /**\r\n   * Refresh all of container's internal dimensions and offsets.\r\n   *\r\n   * @private\r\n   * @memberof Grid.prototype\r\n   */\r\n  _refreshDimensions() {\r\n    this._updateBoundingRect();\r\n    this._updateBorders(1, 1, 1, 1);\r\n  }\r\n\r\n  /**\r\n   * Show or hide Grid instance's items.\r\n   *\r\n   * @private\r\n   * @memberof Grid.prototype\r\n   * @param {GridMultiItemQuery} items\r\n   * @param {Boolean} toVisible\r\n   * @param {Object} [options]\r\n   * @param {Boolean} [options.instant=false]\r\n   * @param {(ShowCallback|HideCallback)} [options.onFinish]\r\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\r\n   */\r\n  _setItemsVisibility(items, toVisible, options) {\r\n    const grid = this;\r\n    const targetItems = this.getItems(items);\r\n    const opts = options || 0;\r\n    const isInstant = opts.instant === true;\r\n    const callback = opts.onFinish;\r\n    const layout = opts.layout ? opts.layout : opts.layout === undefined;\r\n    let counter = targetItems.length;\r\n    const startEvent = toVisible ? eventShowStart : eventHideStart;\r\n    const endEvent = toVisible ? eventShowEnd : eventHideEnd;\r\n    const method = toVisible ? 'show' : 'hide';\r\n    let needsLayout = false;\r\n    const completedItems = [];\r\n    const hiddenItems = [];\r\n    let item;\r\n    let i;\r\n\r\n    // If there are no items call the callback, but don't emit any events.\r\n    if (!counter) {\r\n      if (typeof callback === 'function') callback(targetItems);\r\n      return;\r\n    }\r\n\r\n    // Emit showStart/hideStart event.\r\n    if (this._hasListeners(startEvent)) {\r\n      this._emit(startEvent, targetItems.slice(0));\r\n    }\r\n\r\n    // Show/hide items.\r\n    for (i = 0; i < targetItems.length; i++) {\r\n      item = targetItems[i];\r\n\r\n      // If inactive item is shown or active item is hidden we need to do\r\n      // layout.\r\n      if ((toVisible && !item._isActive) || (!toVisible && item._isActive)) {\r\n        needsLayout = true;\r\n      }\r\n\r\n      // If inactive item is shown we also need to do a little hack to make the\r\n      // item not animate it's next positioning (layout).\r\n      if (toVisible && !item._isActive) {\r\n        item._layout._skipNextAnimation = true;\r\n      }\r\n\r\n      // If a hidden item is being shown we need to refresh the item's\r\n      // dimensions.\r\n      if (toVisible && item._visibility._isHidden) {\r\n        hiddenItems.push(item);\r\n      }\r\n\r\n      // Show/hide the item.\r\n      item._visibility[method](isInstant, (interrupted, item) => {\r\n        // If the current item's animation was not interrupted add it to the\r\n        // completedItems array.\r\n        if (!interrupted) completedItems.push(item);\r\n\r\n        // If all items have finished their animations call the callback\r\n        // and emit showEnd/hideEnd event.\r\n        if (--counter < 1) {\r\n          if (typeof callback === 'function') callback(completedItems.slice(0));\r\n          if (grid._hasListeners(endEvent)) grid._emit(endEvent, completedItems.slice(0));\r\n        }\r\n      });\r\n    }\r\n\r\n    // Refresh hidden items.\r\n    if (hiddenItems.length) this.refreshItems(hiddenItems);\r\n\r\n    // Layout if needed.\r\n    if (needsLayout && layout) {\r\n      this.layout(layout === 'instant', typeof layout === 'function' ? layout : undefined);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Public properties\r\n * *****************\r\n */\r\n\r\n/**\r\n * @see Item\r\n */\r\nGrid.Item = Item;\r\n\r\n/**\r\n * @see ItemLayout\r\n */\r\nGrid.ItemLayout = ItemLayout;\r\n\r\n/**\r\n * @see ItemVisibility\r\n */\r\nGrid.ItemVisibility = ItemVisibility;\r\n\r\n/**\r\n * @see ItemRelease\r\n */\r\nGrid.ItemRelease = ItemRelease;\r\n\r\n/**\r\n * @see ItemMigrate\r\n */\r\nGrid.ItemMigrate = ItemMigrate;\r\n\r\n/**\r\n * @see ItemAnimate\r\n */\r\nGrid.ItemAnimate = ItemAnimate;\r\n\r\n/**\r\n * @see ItemDrag\r\n */\r\nGrid.ItemDrag = ItemDrag;\r\n\r\n/**\r\n * @see Emitter\r\n */\r\nGrid.Emitter = Emitter;\r\n\r\n/**\r\n * Default options for Grid instance.\r\n *\r\n * @public\r\n * @memberof Grid\r\n */\r\nGrid.defaultOptions = {\r\n  // Item elements\r\n  items: '*',\r\n\r\n  // Default show animation\r\n  showDuration: 300,\r\n  showEasing: 'ease',\r\n\r\n  // Default hide animation\r\n  hideDuration: 300,\r\n  hideEasing: 'ease',\r\n\r\n  // Item's visible/hidden state styles\r\n  visibleStyles: {\r\n    opacity: '1',\r\n    transform: 'scale(1)'\r\n  },\r\n  hiddenStyles: {\r\n    opacity: '0',\r\n    transform: 'scale(0.5)'\r\n  },\r\n\r\n  // Layout\r\n  layout: {\r\n    fillGaps: false,\r\n    horizontal: false,\r\n    alignRight: false,\r\n    alignBottom: false,\r\n    rounding: true\r\n  },\r\n  layoutOnResize: 100,\r\n  layoutOnInit: true,\r\n  layoutDuration: 300,\r\n  layoutEasing: 'ease',\r\n\r\n  // Sorting\r\n  sortData: null,\r\n\r\n  // Drag & Drop\r\n  dragEnabled: false,\r\n  dragContainer: null,\r\n  dragStartPredicate: {\r\n    distance: 0,\r\n    delay: 0,\r\n    handle: false\r\n  },\r\n  dragAxis: null,\r\n  dragSort: true,\r\n  dragSortInterval: 100,\r\n  dragSortPredicate: {\r\n    threshold: 50,\r\n    action: 'move'\r\n  },\r\n  dragReleaseDuration: 300,\r\n  dragReleaseEasing: 'ease',\r\n  dragHammerSettings: {\r\n    touchAction: 'none'\r\n  },\r\n\r\n  // Classnames\r\n  containerClass: 'muuri',\r\n  itemClass: 'muuri-item',\r\n  itemVisibleClass: 'muuri-item-shown',\r\n  itemHiddenClass: 'muuri-item-hidden',\r\n  itemPositioningClass: 'muuri-item-positioning',\r\n  itemDraggingClass: 'muuri-item-dragging',\r\n  itemReleasingClass: 'muuri-item-releasing'\r\n};\r\n\r\n/**\r\n * Sort items. There are three ways to sort the items. The first is simply by\r\n * providing a function as the comparer which works identically to native\r\n * array sort. Alternatively you can sort by the sort data you have provided\r\n * in the instance's options. Just provide the sort data key(s) as a string\r\n * (separated by space) and the items will be sorted based on the provided\r\n * sort data keys. Lastly you have the opportunity to provide a presorted\r\n * array of items which will be used to sync the internal items array in the\r\n * same order.\r\n *\r\n * @public\r\n * @memberof Grid.prototype\r\n * @param {(Function|Item[]|String|String[])} comparer\r\n * @param {Object} [options]\r\n * @param {Boolean} [options.descending=false]\r\n * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\r\n * @returns {Grid}\r\n */\r\nGrid.prototype.sort = ((() => {\r\n  let sortComparer;\r\n  let isDescending;\r\n  let origItems;\r\n  let indexMap;\r\n\r\n  function parseCriteria(data) {\r\n    return data\r\n      .trim()\r\n      .split(' ')\r\n      .map(val => val.split(':'));\r\n  };\r\n\r\n  function getIndexMap(items) {\r\n    const ret = {};\r\n    for (let i = 0; i < items.length; i++) {\r\n      ret[items[i]._id] = i;\r\n    }\r\n    return ret;\r\n  };\r\n\r\n  function compareIndices(itemA, itemB) {\r\n    const indexA = indexMap[itemA._id];\r\n    const indexB = indexMap[itemB._id];\r\n    return isDescending ? indexB - indexA : indexA - indexB;\r\n  };\r\n\r\n  function defaultComparer(a, b) {\r\n    let result = 0;\r\n    let criteriaName;\r\n    let criteriaOrder;\r\n    let valA;\r\n    let valB;\r\n\r\n    // Loop through the list of sort criteria.\r\n    for (let i = 0; i < sortComparer.length; i++) {\r\n      // Get the criteria name, which should match an item's sort data key.\r\n      criteriaName = sortComparer[i][0];\r\n      criteriaOrder = sortComparer[i][1];\r\n\r\n      // Get items' cached sort values for the criteria. If the item has no sort\r\n      // data let's update the items sort data (this is a lazy load mechanism).\r\n      valA = (a._sortData ? a : a._refreshSortData())._sortData[criteriaName];\r\n      valB = (b._sortData ? b : b._refreshSortData())._sortData[criteriaName];\r\n\r\n      // Sort the items in descending order if defined so explicitly. Otherwise\r\n      // sort items in ascending order.\r\n      if (criteriaOrder === 'desc' || (!criteriaOrder && isDescending)) {\r\n        result = valB < valA ? -1 : valB > valA ? 1 : 0;\r\n      } else {\r\n        result = valA < valB ? -1 : valA > valB ? 1 : 0;\r\n      }\r\n\r\n      // If we have -1 or 1 as the return value, let's return it immediately.\r\n      if (result) return result;\r\n    }\r\n\r\n    // If values are equal let's compare the item indices to make sure we\r\n    // have a stable sort.\r\n    if (!result) {\r\n      if (!indexMap) indexMap = getIndexMap(origItems);\r\n      result = compareIndices(a, b);\r\n    }\r\n    return result;\r\n  };\r\n\r\n  function customComparer(a, b) {\r\n    let result = sortComparer(a, b);\r\n    // If descending let's invert the result value.\r\n    if (isDescending && result) result = -result;\r\n    // If we have a valid result (not zero) let's return it right away.\r\n    if (result) return result;\r\n    // If result is zero let's compare the item indices to make sure we have a\r\n    // stable sort.\r\n    if (!indexMap) indexMap = getIndexMap(origItems);\r\n    return compareIndices(a, b);\r\n  };\r\n\r\n  return function(comparer, options) {\r\n    if (this._isDestroyed || this._items.length < 2) return this;\r\n\r\n    const items = this._items;\r\n    const opts = options || 0;\r\n    const layout = opts.layout ? opts.layout : opts.layout === undefined;\r\n    let i;\r\n\r\n    // Setup parent scope data.\r\n    sortComparer = comparer;\r\n    isDescending = !!opts.descending;\r\n    origItems = items.slice(0);\r\n    indexMap = null;\r\n\r\n    // If function is provided do a native array sort.\r\n    if (typeof sortComparer === 'function') {\r\n      items.sort(customComparer);\r\n    }\r\n    // Otherwise if we got a string, let's sort by the sort data as provided in\r\n    // the instance's options.\r\n    else if (typeof sortComparer === 'string') {\r\n      sortComparer = parseCriteria(comparer);\r\n      items.sort(defaultComparer);\r\n    }\r\n    // Otherwise if we got an array, let's assume it's a presorted array of the\r\n    // items and order the items based on it.\r\n    else if (Array.isArray(sortComparer)) {\r\n      if (sortComparer.length !== items.length) {\r\n        throw new Error(`[${namespace}] sort reference items do not match with grid items.`);\r\n      }\r\n      for (i = 0; i < items.length; i++) {\r\n        if (!sortComparer.includes(items[i])) {\r\n          throw new Error(`[${namespace}] sort reference items do not match with grid items.`);\r\n        }\r\n        items[i] = sortComparer[i];\r\n      }\r\n      if (isDescending) items.reverse();\r\n    }\r\n    // Otherwise let's just skip it, nothing we can do here.\r\n    else {\r\n      /** @todo Maybe throw an error here? */\r\n      return this;\r\n    }\r\n\r\n    // Emit sort event.\r\n    if (this._hasListeners(eventSort)) {\r\n      this._emit(eventSort, items.slice(0), origItems);\r\n    }\r\n\r\n    // If layout is needed.\r\n    if (layout) {\r\n      this.layout(layout === 'instant', typeof layout === 'function' ? layout : undefined);\r\n    }\r\n\r\n    return this;\r\n  };\r\n}))();\r\n\r\n/**\r\n * Private helpers\r\n * ***************\r\n */\r\n\r\n/**\r\n * Merge default settings with user settings. The returned object is a new\r\n * object with merged values. The merging is a deep merge meaning that all\r\n * objects and arrays within the provided settings objects will be also merged\r\n * so that modifying the values of the settings object will have no effect on\r\n * the returned object.\r\n *\r\n * @param {Object} defaultSettings\r\n * @param {Object} [userSettings]\r\n * @returns {Object} Returns a new object.\r\n */\r\nfunction mergeSettings(defaultSettings, userSettings) {\r\n  // Create a fresh copy of default settings.\r\n  let ret = mergeObjects({}, defaultSettings);\r\n\r\n  // Merge user settings to default settings.\r\n  if (userSettings) {\r\n    ret = mergeObjects(ret, userSettings);\r\n  }\r\n\r\n  // Handle visible/hidden styles manually so that the whole object is\r\n  // overridden instead of the props.\r\n  ret.visibleStyles = (userSettings || 0).visibleStyles || (defaultSettings || 0).visibleStyles;\r\n  ret.hiddenStyles = (userSettings || 0).hiddenStyles || (defaultSettings || 0).hiddenStyles;\r\n\r\n  return ret;\r\n}\r\n\r\n/**\r\n * Merge two objects recursively (deep merge). The source object's properties\r\n * are merged to the target object.\r\n *\r\n * @param {Object} target\r\n *   - The target object.\r\n * @param {Object} source\r\n *   - The source object.\r\n * @returns {Object} Returns the target object.\r\n */\r\nfunction mergeObjects(target, source) {\r\n  const sourceKeys = Object.keys(source);\r\n  const length = sourceKeys.length;\r\n  let isSourceObject;\r\n  let propName;\r\n  let i;\r\n\r\n  for (i = 0; i < length; i++) {\r\n    propName = sourceKeys[i];\r\n    isSourceObject = isPlainObject(source[propName]);\r\n\r\n    // If target and source values are both objects, merge the objects and\r\n    // assign the merged value to the target property.\r\n    if (isPlainObject(target[propName]) && isSourceObject) {\r\n      target[propName] = mergeObjects(mergeObjects({}, target[propName]), source[propName]);\r\n      continue;\r\n    }\r\n\r\n    // If source's value is object and target's is not let's clone the object as\r\n    // the target's value.\r\n    if (isSourceObject) {\r\n      target[propName] = mergeObjects({}, source[propName]);\r\n      continue;\r\n    }\r\n\r\n    // If source's value is an array let's clone the array as the target's\r\n    // value.\r\n    if (Array.isArray(source[propName])) {\r\n      target[propName] = source[propName].slice(0);\r\n      continue;\r\n    }\r\n\r\n    // In all other cases let's just directly assign the source's value as the\r\n    // target's value.\r\n    target[propName] = source[propName];\r\n  }\r\n\r\n  return target;\r\n}\r\n\r\nexport default Grid;\r\n","import { Component } from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport Grid from './Grid/Grid';\r\n\r\nexport default class MuuriGrid extends Component {\r\n  static propTypes = {\r\n    node: PropTypes.node.isRequired,\r\n    defaultOptions: PropTypes.object\r\n  }\r\n\r\n  constructor (props) {\r\n    super(props);\r\n\r\n    this.grid = new Grid(props.node, props.defaultOptions);\r\n    this.getMethod = this.getMethod.bind(this);\r\n    this.getEvent = this.getEvent.bind(this);\r\n    this.getItemMethod = this.getItemMethod.bind(this);\r\n  }\r\n\r\n  getMethod (method, param1, param2, param3, param4) {\r\n    try {\r\n      let result;\r\n\r\n      switch (method) {\r\n        case 'getElement':\r\n          result = this.grid.getElement();\r\n          break;\r\n        case 'getItems':\r\n          result = this.grid.getItems(param1);\r\n          break;\r\n        case 'refreshItems':\r\n          result = this.grid.refreshItems(param1);\r\n          break;\r\n        case 'refreshSortData':\r\n          result = this.grid.refreshSortData(param1);\r\n          break;\r\n        case 'synchronize':\r\n          result = this.grid.synchronize();\r\n          break;\r\n        case 'layout':\r\n          result = this.grid.layout(param1, param2);\r\n          break;\r\n        case 'add':\r\n          result = this.grid.add(param1, param2);\r\n          break;\r\n        case 'remove':\r\n          result = this.grid.remove(param1, param2);\r\n          break;\r\n        case 'show':\r\n          result = this.grid.show(param1, param2);\r\n          break;\r\n        case 'hide':\r\n          result = this.grid.hide(param1, param2);\r\n          break;\r\n        case 'filter':\r\n          result = this.grid.filter(param1, param2);\r\n          break;\r\n        case 'sort':\r\n          result = this.grid.sort(param1, param2);\r\n          break;\r\n        case 'move':\r\n          result = this.grid.move(param1, param2, param3);\r\n          break;\r\n        case 'send':\r\n          result = this.grid.send(param1, param2, param3, param4);\r\n          break;\r\n        case 'on':\r\n          result = this.grid.on(param1, param2);\r\n          break;\r\n        case 'once':\r\n          result = this.grid.once(param1, param2);\r\n          break;\r\n        case 'off':\r\n          result = this.grid.off(param1, param2);\r\n          break;\r\n        case 'destroy':\r\n          result = this.grid.destroy(param1);\r\n          break;\r\n        default:\r\n          result = null;\r\n          console.error(`Invalid 'Method' provided: ${method}`);\r\n          console.error(`Check the Muuri documentation for a list of valid methods.`);\r\n          break;\r\n      }\r\n\r\n      return result;\r\n    } catch (error) {\r\n      console.error(`The following error occured in 'getMethod()': ${error}`);\r\n    }\r\n  }\r\n\r\n  getEvent (event, param1, param2, callback) {\r\n    const eventsList = [\r\n      'synchronize',\r\n      'layoutStart',\r\n      'layoutEnd',\r\n      'add',\r\n      'remove',\r\n      'showStart',\r\n      'showEnd',\r\n      'hideStart',\r\n      'hideEnd',\r\n      'filter',\r\n      'sort',\r\n      'move',\r\n      'send',\r\n      'beforeSend',\r\n      'receive',\r\n      'beforeReceive',\r\n      'dragInit',\r\n      'dragStart',\r\n      'dragMove',\r\n      'dragScroll',\r\n      'dragEnd',\r\n      'dragReleaseStart',\r\n      'dragReleaseEnd',\r\n      'destroy'\r\n    ];\r\n\r\n    if (event === undefined || event === null || eventsList.indexOf(event) === -1) {\r\n      console.error(`Invalid event provided to 'getEvent()': ${event}`);\r\n    } else {\r\n      try {\r\n        this.grid.on(event, (param1, param2) => {\r\n          if (callback) {\r\n            callback(param1, param2);\r\n          }\r\n\r\n          this.grid.synchronize();\r\n        });\r\n      } catch (error) {\r\n        console.error(`The following error occured in 'getEvent()': ${error}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  getItemMethod (method, item) {\r\n    try {\r\n      let result;\r\n\r\n      switch (method) {\r\n        case 'getGrid':\r\n          result = item.getGrid();\r\n          break;\r\n        case 'getElement':\r\n          result = item.getElement();\r\n          break;\r\n        case 'getWidth':\r\n          result = item.getWidth();\r\n          break;\r\n        case 'getHeight':\r\n          result = item.getHeight();\r\n          break;\r\n        case 'getMargin':\r\n          result = item.getMargin();\r\n          break;\r\n        case 'getPosition':\r\n          result = item.getPosition();\r\n          break;\r\n        case 'isActive':\r\n          result = item.isActive();\r\n          break;\r\n        case 'isVisible':\r\n          result = item.isVisible();\r\n          break;\r\n        case 'isShowing':\r\n          result = item.isShowing();\r\n          break;\r\n        case 'isHiding':\r\n          result = item.isHiding();\r\n          break;\r\n        case 'isPositioning':\r\n          result = item.isPositioning();\r\n          break;\r\n        case 'isDragging':\r\n          result = item.isDragging();\r\n          break;\r\n        case 'isReleasing':\r\n          result = item.isReleasing();\r\n          break;\r\n        case 'isDestroyed':\r\n          result = item.isDestroyed();\r\n          break;\r\n        default:\r\n          result = null;\r\n          console.error(`Invalid 'Item Event' provided: ${method}`);\r\n          console.error(`Check the Muuri documentation for a list of valid item events.`);\r\n          break;\r\n      }\r\n\r\n      return result;\r\n    } catch (error) {\r\n      console.error(`The following error occured in 'getItemMethod()': ${error}`);\r\n    }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}